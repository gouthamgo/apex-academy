"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/learn/page",{

/***/ "(app-pages-browser)/./src/data/topicContent.ts":
/*!**********************************!*\
  !*** ./src/data/topicContent.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   topicContent: function() { return /* binding */ topicContent; }\n/* harmony export */ });\nconst topicContent = {\n    \"variables-and-data-types\": {\n        title: \"Variables and Data Types\",\n        overview: \"Master Apex variables, primitive data types, and type conversion. Variables are the foundation of every Apex program - they store information your code needs. Understanding variables is crucial because EVERYTHING in Salesforce development builds on this: from simple field updates to complex business logic. This topic sets the stage for Collections (multiple values), Control Flow (decisions about values), and beyond.\",\n        codeExamples: [\n            {\n                title: \"Basic Variable Declaration\",\n                code: \"public class VariableExample {\\n    // ✅ WHAT: Class declaration with public access\\n    // \\uD83D\\uDC80 EXAM TRAP: Class name must match filename exactly\\n\\n    private String customerName;\\n    // ✅ WHAT: Instance variable for storing text\\n    // ✅ WHY: private = controlled access (encapsulation)\\n    // \\uD83D\\uDC80 COMMON MISTAKE: Variables default to null (not empty)\\n\\n    private Integer age = 0;\\n    // ✅ WHAT: Whole number with safe initialization\\n    // ✅ WHY: Prevents null pointer exceptions\\n    // \\uD83D\\uDC80 EXAM TRAP: Use Integer (not int) in Apex\\n\\n    public VariableExample(String name) {\\n        this.customerName = name;\\n        // ✅ WHAT: this = current object reference\\n        // ✅ WHY: Distinguishes parameter from field\\n    }\\n}\",\n                explanation: \"Apex uses wrapper types (Integer, Boolean, String) instead of Java primitives. All variables can be null and have methods. Always initialize variables or check for null before using them.\"\n            },\n            {\n                title: \"String Operations\",\n                code: \"public class StringDemo {\\n    public void processNames() {\\n        String firstName = 'John';\\n        // \\uD83D\\uDC80 EXAM TRAP: Single quotes (not double) in Apex\\n\\n        String lastName = 'Doe';\\n        String fullName = firstName + ' ' + lastName;\\n        // ✅ RESULT: 'John Doe'\\n\\n        Boolean hasContent = String.isNotBlank(fullName);\\n        // ✅ SAFE: Checks null AND empty AND whitespace\\n        // ✅ BETTER THAN: fullName != null && fullName.length() > 0\\n\\n        if (hasContent) {\\n            System.debug('Name: ' + fullName.toUpperCase());\\n        }\\n    }\\n}\",\n                explanation: \"String operations in Apex are null-safe when using built-in methods like isNotBlank(). Always use these instead of manual null checks for robust code.\"\n            },\n            {\n                title: \"Type Conversion\",\n                code: \"public class ConversionDemo {\\n    public void safeConversion() {\\n        String numberStr = '123';\\n        Integer result;\\n\\n        // ✅ SAFE: Check before converting\\n        if (numberStr.isNumeric()) {\\n            result = Integer.valueOf(numberStr);\\n        } else {\\n            result = 0; // Default fallback\\n        }\\n\\n        // ✅ SAFE: Try-catch for complex conversions\\n        try {\\n            Decimal price = Decimal.valueOf('19.99');\\n            System.debug('Price: ' + price);\\n        } catch (TypeException e) {\\n            System.debug('Invalid number format');\\n        }\\n    }\\n}\",\n                explanation: \"Always validate input before type conversion. Use isNumeric() for basic checks and try-catch for complex scenarios. TypeException is thrown for invalid conversions.\"\n            }\n        ],\n        practiceQuestions: [\n            {\n                number: 1,\n                difficulty: \"beginner\",\n                question: \"What is wrong with this code?\",\n                code: \"String name;\\nInteger length = name.length();\",\n                answer: \"NullPointerException will be thrown\",\n                explanation: \"The variable 'name' is declared but not initialized, so it defaults to null. Calling .length() on a null String throws a NullPointerException at runtime.\",\n                correctCode: \"String name = 'John';  // Initialize the variable\\nInteger length = name.length();  // Now safe to call\",\n                keyLearning: \"Always initialize variables or check for null before using them. Uninitialized reference variables default to null.\",\n                examTip: \"This is a very common PD1 certification question pattern. Always look for uninitialized variables in code samples.\"\n            },\n            {\n                number: 2,\n                difficulty: \"beginner\",\n                question: \"Which data type should you use for storing currency values in Salesforce?\",\n                answer: \"Decimal\",\n                explanation: \"Decimal is the best choice for currency because it provides exact precision without floating-point rounding errors. Double/Float can introduce rounding errors that are unacceptable for financial calculations.\",\n                correctCode: \"Decimal price = 19.99;\\nDecimal total = price * 1.08;  // Exact calculation\",\n                keyLearning: \"Use Decimal for financial calculations to avoid floating-point precision issues. Currency fields in Salesforce are also stored as Decimal.\",\n                examTip: \"Salesforce strongly recommends Decimal for currency. This appears in PD1 questions about data type selection.\"\n            },\n            {\n                number: 3,\n                difficulty: \"beginner\",\n                question: \"What happens when you declare 'Integer count;' without initialization?\",\n                answer: \"count defaults to null\",\n                explanation: \"In Apex, uninitialized primitive wrapper types (Integer, Double, Boolean, etc.) default to null, not zero. This is different from Java where primitives have default values.\",\n                correctCode: \"Integer count = 0;  // Explicitly initialize\\n// OR\\nInteger count;\\nif (count == null) {\\n    count = 0;  // Handle null case\\n}\",\n                keyLearning: \"Apex primitive wrappers default to null, not zero. Always initialize or null-check before using.\",\n                examTip: \"PD1 exam tests understanding of null vs zero. Remember Apex uses wrapper types (Integer) not primitives (int).\"\n            },\n            {\n                number: 4,\n                difficulty: \"beginner\",\n                question: \"Fix this code: 'boolean isActive = true;'\",\n                answer: \"Use Boolean (capital B) instead of boolean\",\n                explanation: \"Apex uses wrapper types, not Java primitives. 'boolean' (lowercase) doesn't exist in Apex - use 'Boolean' (capital B).\",\n                correctCode: \"Boolean isActive = true;  // Correct wrapper type\",\n                keyLearning: \"Apex only has wrapper types (Boolean, Integer, Double), not Java primitives (boolean, int, double).\",\n                examTip: \"Case sensitivity is tested on PD1. Always use capital letters for Apex data types.\"\n            },\n            {\n                number: 5,\n                difficulty: \"intermediate\",\n                question: \"What's the difference between 'Integer' and 'int' in Apex?\",\n                answer: \"'int' doesn't exist in Apex - only 'Integer' is valid\",\n                explanation: \"Unlike Java, Apex only has wrapper types. There are no primitive types like 'int', 'boolean', or 'double' in Apex. All data types are objects that can be null.\",\n                correctCode: \"Integer count = 10;     // Correct\\nBoolean flag = true;    // Correct\\nDouble rate = 2.5;      // Correct\",\n                keyLearning: \"Apex simplifies Java by only having wrapper types. This means all variables can be null and have methods.\",\n                examTip: \"This fundamental difference from Java is frequently tested. Remember: Apex = wrapper types only.\"\n            },\n            {\n                number: 6,\n                difficulty: \"intermediate\",\n                question: \"What happens with this code: Decimal d1 = null; Decimal d2 = 10; Decimal result = d1 + d2;\",\n                answer: \"NullPointerException is thrown\",\n                explanation: \"When performing arithmetic operations with Decimal variables, if any operand is null, the operation throws a NullPointerException. Unlike some languages that might treat null as zero, Apex requires explicit null checking.\",\n                correctCode: \"Decimal d1 = null;\\nDecimal d2 = 10;\\nDecimal result = (d1 != null ? d1 : 0) + d2;  // Safe addition\",\n                keyLearning: \"Always null-check Decimal variables before arithmetic operations. Apex doesn't auto-convert null to zero.\",\n                examTip: \"Null arithmetic operations are frequently tested scenarios on certification exams.\"\n            },\n            {\n                number: 7,\n                difficulty: \"beginner\",\n                question: \"You're reviewing code and see 'String name; System.debug(name.toUpperCase());' - what will happen and how do you fix it?\",\n                answer: \"NullPointerException will be thrown because 'name' is uninitialized (null)\",\n                explanation: \"In Apex, declaring a variable without initialization sets it to null. Calling methods on null objects throws NullPointerException at runtime. This is a common mistake for developers coming from languages where primitives have default values.\",\n                correctCode: \"// Option 1: Initialize with a value\\nString name = 'John';\\nSystem.debug(name.toUpperCase()); // Safe\\n\\n// Option 2: Null-check before use\\nString name;\\nif (String.isNotBlank(name)) {\\n    System.debug(name.toUpperCase());\\n}\",\n                keyLearning: \"Always initialize variables or null-check before calling methods. Uninitialized reference variables default to null in Apex.\",\n                examTip: \"This exact pattern appears frequently on certification exams. Always look for uninitialized variables in code samples.\"\n            },\n            {\n                number: 8,\n                difficulty: \"intermediate\",\n                question: \"A junior developer asks why 'int count = 0;' doesn't work in Apex. How do you explain it?\",\n                answer: \"Apex only has wrapper types like 'Integer', not primitives like 'int'\",\n                explanation: \"Unlike Java, Apex simplified the type system by only providing wrapper types (Integer, Boolean, Double, etc.). There are no primitive types (int, boolean, double) in Apex. This means all variables can be null and have methods.\",\n                correctCode: \"Integer count = 0;        // Correct - wrapper type\\nBoolean isActive = true;  // Correct - wrapper type\\nDouble rate = 2.5;        // Correct - wrapper type\\n\\n// These don't exist in Apex:\\n// int count = 0;        // Compilation error\\n// boolean flag = true;  // Compilation error\",\n                keyLearning: \"Apex = wrapper types only. This simplifies the language but means all variables can be null.\",\n                examTip: \"Type system questions are common. Remember: Apex wrapper types (Integer) vs Java primitives (int) - only wrappers exist in Apex.\"\n            },\n            {\n                number: 9,\n                difficulty: \"intermediate\",\n                question: \"You need to store monetary values with precision. What data type do you choose and why?\",\n                answer: \"Decimal - it provides exact precision without floating-point rounding errors\",\n                explanation: \"For financial calculations, Decimal is the only safe choice because it avoids floating-point arithmetic errors that can occur with Double. Currency fields in Salesforce are stored as Decimal, making this the natural choice for monetary calculations.\",\n                correctCode: \"// Correct for currency\\nDecimal price = 19.99;\\nDecimal tax = price * 0.08;\\nDecimal total = price + tax;  // Exact calculation\\n\\n// Wrong for currency - can have rounding errors\\nDouble price = 19.99;\\nDouble tax = price * 0.08;    // Potential precision loss\",\n                keyLearning: \"Use Decimal for all financial calculations to avoid floating-point precision issues. Currency fields in Salesforce use Decimal.\",\n                examTip: \"Currency data type questions appear frequently. Remember: Decimal for money, Double/Float for scientific calculations.\"\n            },\n            {\n                number: 10,\n                difficulty: \"beginner\",\n                question: \"Code review: 'Boolean isActive;' - what's the potential issue and how do you improve it?\",\n                answer: \"Uninitialized Boolean defaults to null, not false, which can cause unexpected behavior\",\n                explanation: \"In Apex, Boolean variables default to null when uninitialized, not false. This can cause issues in conditional logic where you might expect false behavior. Explicit initialization prevents confusion and potential NPEs.\",\n                correctCode: \"// Better: Explicit initialization\\nBoolean isActive = false;  // Clear intent, no null issues\\n\\n// Or handle null explicitly\\nBoolean isActive;\\nif (isActive == true) {    // Explicit null-safe comparison\\n    System.debug('Active');\\n}\",\n                keyLearning: \"Boolean variables default to null, not false. Always initialize or use explicit null-safe comparisons.\",\n                examTip: \"Boolean null behavior is tested frequently. Remember: null != false in Apex Boolean logic.\"\n            },\n            {\n                number: 11,\n                difficulty: \"intermediate\",\n                question: \"A method receives a String parameter that might be null, empty, or whitespace. Write the safest validation.\",\n                answer: \"Use String.isNotBlank() for comprehensive validation\",\n                explanation: \"String.isNotBlank() is the most comprehensive check as it validates against null, empty string, and strings containing only whitespace characters. This is safer than manual null checks or isEmpty().\",\n                correctCode: \"public void processName(String name) {\\n    // Best: Handles null, empty, and whitespace\\n    if (String.isNotBlank(name)) {\\n        System.debug('Valid name: ' + name.trim());\\n    } else {\\n        System.debug('Invalid name provided');\\n    }\\n}\\n\\n// Alternative for specific cases:\\nif (String.isNotEmpty(name)) { } // null and empty only\\nif (name != null && name.length() > 0) { } // Manual, more verbose\",\n                keyLearning: \"String.isNotBlank() is your best friend for string validation. It handles all edge cases in one call.\",\n                examTip: \"String validation questions are common. Know the difference: isNotBlank (null/empty/whitespace), isNotEmpty (null/empty only).\"\n            },\n            {\n                number: 12,\n                difficulty: \"advanced\",\n                question: \"Explain when you'd use 'final' keyword with variables and give a practical example.\",\n                answer: \"Use 'final' for constants and variables that shouldn't be reassigned after initialization\",\n                explanation: \"The 'final' keyword prevents variable reassignment after initialization, making code more predictable and catching accidental modifications. It's especially useful for constants, configuration values, and protecting important references.\",\n                correctCode: \"public class ConfigurationManager {\\n    // Class constant - compile-time constant\\n    private static final Integer MAX_RETRIES = 3;\\n\\n    // Instance constant - runtime constant\\n    private final String organizationId;\\n\\n    public ConfigurationManager() {\\n        // Can only be set once during construction\\n        this.organizationId = UserInfo.getOrganizationId();\\n    }\\n\\n    public void processData(List<Account> accounts) {\\n        // Method-level constant\\n        final Integer BATCH_SIZE = 200;\\n\\n        // organizationId = 'new-id';  // Compilation error\\n        // BATCH_SIZE = 300;           // Compilation error\\n    }\\n}\",\n                keyLearning: \"'final' prevents reassignment and documents intent. Use for constants, configuration, and protecting important references.\",\n                examTip: \"Final keyword questions test understanding of immutability. Remember: prevents reassignment, not object modification.\"\n            },\n            {\n                number: 13,\n                difficulty: \"intermediate\",\n                question: \"You see 'Object data = someMethod();' - what are the risks and how do you handle them safely?\",\n                answer: \"Risk of ClassCastException and loss of type safety. Use instanceof checks and explicit casting\",\n                explanation: \"Object is the most generic type in Apex. Using it loses compile-time type checking and requires runtime type verification. This can lead to ClassCastException if you cast to the wrong type.\",\n                correctCode: \"Object data = someMethod();\\n\\n// Safe approach with instanceof\\nif (data instanceof String) {\\n    String stringData = (String) data;\\n    System.debug('String value: ' + stringData);\\n} else if (data instanceof Integer) {\\n    Integer intData = (Integer) data;\\n    System.debug('Integer value: ' + intData);\\n} else if (data instanceof List<Object>) {\\n    List<Object> listData = (List<Object>) data;\\n    System.debug('List size: ' + listData.size());\\n} else {\\n    System.debug('Unknown data type: ' + (data != null ? data.getClass() : 'null'));\\n}\",\n                keyLearning: \"Object type loses type safety. Always use instanceof before casting to prevent ClassCastException.\",\n                examTip: \"Object casting questions test type safety understanding. Remember: instanceof before casting, handle null case.\"\n            },\n            {\n                number: 14,\n                difficulty: \"beginner\",\n                question: \"A developer uses 'Double' for currency calculations. What problems could this cause?\",\n                answer: \"Floating-point precision errors that can cause incorrect monetary calculations\",\n                explanation: \"Double uses floating-point arithmetic which can't exactly represent many decimal numbers, leading to rounding errors. For financial calculations, even tiny errors compound and can cause significant issues in accounting and reporting.\",\n                correctCode: \"// Wrong - potential precision errors\\nDouble price = 0.1;\\nDouble tax = 0.2;\\nDouble total = price + tax;  // Might not equal exactly 0.3\\n\\n// Correct - exact decimal arithmetic\\nDecimal price = 0.1;\\nDecimal tax = 0.2;\\nDecimal total = price + tax;  // Exactly 0.3\\n\\n// Real example\\nDecimal itemPrice = 19.99;\\nDecimal taxRate = 0.0825;    // 8.25%\\nDecimal totalPrice = itemPrice * (1 + taxRate);\",\n                keyLearning: \"Never use Double for currency. Decimal provides exact precision for financial calculations.\",\n                examTip: \"Currency precision questions are frequent. Remember: Decimal for money, Double for scientific measurements.\"\n            },\n            {\n                number: 15,\n                difficulty: \"intermediate\",\n                question: \"Write code to safely convert user input from String to Integer with proper error handling.\",\n                answer: \"Use try-catch with Integer.valueOf() and validate input first\",\n                explanation: \"String to Integer conversion can fail if the string contains non-numeric characters. Always validate input and handle TypeException to provide meaningful error messages.\",\n                correctCode: \"public Integer safeStringToInteger(String input, Integer defaultValue) {\\n    // Early validation\\n    if (String.isBlank(input)) {\\n        return defaultValue;\\n    }\\n\\n    // Remove whitespace\\n    input = input.trim();\\n\\n    // Check if purely numeric (optional optimization)\\n    if (!input.isNumeric()) {\\n        System.debug('Non-numeric input: ' + input);\\n        return defaultValue;\\n    }\\n\\n    try {\\n        return Integer.valueOf(input);\\n    } catch (TypeException e) {\\n        System.debug('Conversion error for input \\\"' + input + '\\\": ' + e.getMessage());\\n        return defaultValue;\\n    }\\n}\\n\\n// Usage example\\nInteger userAge = safeStringToInteger(userInput, 0);\",\n                keyLearning: \"Always validate string input before type conversion. Use try-catch for TypeException and provide meaningful defaults.\",\n                examTip: \"Type conversion questions test error handling skills. Remember: validate, try-catch, provide defaults.\"\n            },\n            {\n                number: 16,\n                difficulty: \"beginner\",\n                question: \"You need to compare two String variables for equality. What are the different approaches and their implications?\",\n                answer: \"Use .equals() method for content comparison, never == operator\",\n                explanation: \"In Apex (like Java), the == operator compares object references, not content. For string content comparison, always use .equals() method. This is a common source of bugs for developers new to Apex.\",\n                correctCode: \"String name1 = 'John';\\nString name2 = getName(); // Returns 'John'\\n\\n// Wrong - compares references (might be false even with same content)\\nif (name1 == name2) { }\\n\\n// Correct - compares content\\nif (name1.equals(name2)) { }\\n\\n// Better - null-safe comparison\\nif (name1?.equals(name2) == true) { }\\n\\n// Best - using String utility (handles nulls)\\nif (String.isEmpty(name1) && String.isEmpty(name2)) {\\n    // Both empty/null\\n} else if (name1?.equals(name2) == true) {\\n    // Content matches\\n}\",\n                keyLearning: \"String comparison: == compares references, .equals() compares content. Always use .equals() for string comparison.\",\n                examTip: \"String comparison is heavily tested. Remember: == for primitives/references, .equals() for content comparison.\"\n            },\n            {\n                number: 17,\n                difficulty: \"intermediate\",\n                question: \"A field might contain null or actual data. Write defensive code to handle both cases.\",\n                answer: \"Use null-coalescing operators and safe navigation for robust handling\",\n                explanation: \"Apex provides several mechanisms for safe null handling: null-coalescing (?:), safe navigation (?.), and traditional null checks. Combining these creates robust, readable code.\",\n                correctCode: \"public void processAccountData(Account acc) {\\n    // Null-coalescing - provide default if null\\n    String accountName = acc.Name ?? 'Unknown Account';\\n\\n    // Safe navigation - only call if not null\\n    Integer nameLength = acc.Name?.length();\\n\\n    // Traditional null check for complex logic\\n    if (acc.AnnualRevenue != null) {\\n        Decimal monthlyRevenue = acc.AnnualRevenue / 12;\\n        System.debug('Monthly revenue: ' + monthlyRevenue);\\n    } else {\\n        System.debug('Annual revenue not set');\\n    }\\n\\n    // Combining approaches\\n    String displayText = acc.Description?.abbreviate(50) ?? 'No description available';\\n\\n    // Safe field access with default\\n    String industry = acc.Industry ?? 'Not Specified';\\n    String type = acc.Type ?? 'Standard';\\n}\",\n                keyLearning: \"Use null-coalescing (??) for defaults, safe navigation (?.) for method calls, explicit checks for complex logic.\",\n                examTip: \"Null handling is critical for robust code. Know all three approaches: ??, ?., and explicit null checks.\"\n            },\n            {\n                number: 18,\n                difficulty: \"beginner\",\n                question: \"Explain the difference between 'String s = null;' and 'String s = \\\"\\\";' and when each matters.\",\n                answer: \"null means no object exists, empty string means object exists but contains no characters\",\n                explanation: \"This distinction is crucial for validation and business logic. null typically means 'no value provided' while empty string means 'value provided but empty'. Different validation methods handle these cases differently.\",\n                correctCode: \"String nullString = null;      // No object\\nString emptyString = '';       // Object exists, no content\\nString blankString = '   ';    // Object exists, whitespace only\\n\\n// Different validation results:\\nSystem.debug(String.isEmpty(nullString));     // true\\nSystem.debug(String.isEmpty(emptyString));    // true\\nSystem.debug(String.isEmpty(blankString));    // false\\n\\nSystem.debug(String.isBlank(nullString));     // true\\nSystem.debug(String.isBlank(emptyString));    // true\\nSystem.debug(String.isBlank(blankString));    // true\\n\\n// Null-safe operations:\\nSystem.debug(nullString?.length());           // null\\nSystem.debug(emptyString?.length());          // 0\\nSystem.debug(blankString?.length());          // 3\",\n                keyLearning: \"null = no object, empty = object with no content. Use appropriate validation method based on business needs.\",\n                examTip: \"String state questions are common. Know: null (no object), empty (no content), blank (no meaningful content).\"\n            },\n            {\n                number: 19,\n                difficulty: \"advanced\",\n                question: \"You're processing form data where numbers come as strings. Show the complete safe conversion pattern.\",\n                answer: \"Comprehensive validation with multiple fallback strategies\",\n                explanation: \"Real-world form processing requires handling various edge cases: null values, empty strings, non-numeric content, decimal vs integer, negative values, and range validation.\",\n                correctCode: \"public class FormDataProcessor {\\n    public static Decimal parseDecimalField(String input, String fieldName, Decimal defaultValue) {\\n        // Step 1: Handle null/empty\\n        if (String.isBlank(input)) {\\n            System.debug(fieldName + ' is blank, using default: ' + defaultValue);\\n            return defaultValue;\\n        }\\n\\n        // Step 2: Clean the input\\n        String cleaned = input.trim().replace(',', ''); // Remove commas\\n\\n        // Step 3: Basic numeric validation\\n        String numericPattern = '^-?\\\\d*\\\\.?\\\\d+$';\\n        if (!Pattern.matches(numericPattern, cleaned)) {\\n            System.debug('Invalid numeric format for ' + fieldName + ': ' + input);\\n            return defaultValue;\\n        }\\n\\n        // Step 4: Safe conversion\\n        try {\\n            Decimal result = Decimal.valueOf(cleaned);\\n\\n            // Step 5: Range validation (example)\\n            if (fieldName.contains('Price') && result < 0) {\\n                System.debug('Negative price not allowed: ' + result);\\n                return 0;\\n            }\\n\\n            return result;\\n        } catch (TypeException e) {\\n            System.debug('Conversion failed for ' + fieldName + ': ' + e.getMessage());\\n            return defaultValue;\\n        }\\n    }\\n\\n    // Usage example\\n    public static void processOrderForm(Map<String, String> formData) {\\n        Decimal price = parseDecimalField(formData.get('price'), 'Price', 0.00);\\n        Decimal quantity = parseDecimalField(formData.get('qty'), 'Quantity', 1.00);\\n        Decimal total = price * quantity;\\n    }\\n}\",\n                keyLearning: \"Production form processing needs comprehensive validation: null handling, cleaning, format checking, type conversion, and business rules.\",\n                examTip: \"Complex validation scenarios test real-world skills. Think: validate → clean → convert → business rules.\"\n            },\n            {\n                number: 20,\n                difficulty: \"advanced\",\n                question: \"You're mentoring someone on variable naming. What are the key principles with examples?\",\n                answer: \"Use descriptive names, consistent conventions, and context-appropriate scope indicators\",\n                explanation: \"Good variable naming improves code readability and maintainability. Follow conventions that make intent clear, scope obvious, and purpose explicit.\",\n                correctCode: \"public class VariableNamingBestPractices {\\n    // Constants: SCREAMING_SNAKE_CASE\\n    private static final Integer MAX_RETRY_ATTEMPTS = 3;\\n    private static final String DEFAULT_COUNTRY_CODE = 'US';\\n\\n    // Instance variables: camelCase with descriptive names\\n    private String customerEmailAddress;\\n    private Decimal monthlyRecurringRevenue;\\n    private Date lastLoginTimestamp;\\n\\n    // Method parameters: camelCase, context-clear\\n    public void updateCustomerProfile(String newEmailAddress,\\n                                    Boolean isEmailVerified,\\n                                    Date profileLastModified) {\\n\\n        // Local variables: descriptive within scope\\n        String normalizedEmail = newEmailAddress.toLowerCase().trim();\\n        Boolean isValidEmailFormat = validateEmailFormat(normalizedEmail);\\n\\n        // Loop variables: short names OK for short scopes\\n        for (Integer i = 0; i < MAX_RETRY_ATTEMPTS; i++) {\\n            // Process with clear intent\\n        }\\n\\n        // Collection variables: plural nouns\\n        List<Contact> customerContacts = new List<Contact>();\\n        Map<Id, Account> accountsById = new Map<Id, Account>();\\n\\n        // Boolean variables: is/has/can/should prefixes\\n        Boolean hasValidLicense = checkLicenseStatus();\\n        Boolean canProcessPayment = validatePaymentMethod();\\n        Boolean shouldSendNotification = determineNotificationPreference();\\n    }\\n}\\n\\n// Bad examples to avoid:\\n// String s, str, temp, data          // Too generic\\n// Integer num1, num2                 // Unclear purpose\\n// Boolean flag, check                // What kind of flag/check?\\n// List<Object> list                  // What does it contain?\",\n                keyLearning: \"Good names are self-documenting. Use: descriptive nouns, action verbs, consistent conventions, appropriate scope length.\",\n                examTip: \"Code quality questions include naming conventions. Remember: constants (CAPS), variables (camelCase), booleans (is/has/can).\"\n            }\n        ]\n    },\n    \"collections-deep-dive\": {\n        title: \"Collections Deep Dive\",\n        overview: \"Master Lists, Sets, Maps and bulkification patterns. Now that you understand single values (Variables), learn to handle MULTIPLE values efficiently. Collections are essential for Salesforce bulk processing and prevent governor limit violations. This knowledge directly enables Control Flow (processing collections) and triggers (handling bulk data changes).\",\n        codeExamples: [\n            {\n                title: \"List Fundamentals\",\n                code: \"public class ListDemo {\\n    public void processList() {\\n        // ✅ BUILDING ON: Variables hold ONE value (String name = 'John')\\n        // ✅ NEW CONCEPT: Lists hold MULTIPLE values of same type\\n        List<String> names = new List<String>();\\n        // ✅ CONNECTION: Same String type from Variables topic, but now a container\\n        // ✅ WHY: Processing multiple records requires collections\\n        // \\uD83D\\uDCA1 NEXT TOPIC: You'll use loops (Control Flow) to process these efficiently\\n\\n        names.add('John');\\n        names.add('Jane');\\n        names.add('John'); // ✅ Lists allow duplicates (unlike Sets)\\n\\n        // ✅ BUILDING FORWARD: This validation pattern crucial in Triggers\\n        if (!names.isEmpty()) {\\n            String first = names.get(0);\\n            System.debug('First name: ' + first);\\n        }\\n\\n        // ✅ ENHANCED FOR LOOP: Process each item\\n        // \\uD83D\\uDCA1 NEXT TOPIC: This loop syntax comes from Control Flow\\n        for (String name : names) {\\n            // ✅ CONNECTION: String validation from Variables topic\\n            if (String.isNotBlank(name)) {\\n                System.debug('Processing valid name: ' + name);\\n            }\\n        }\\n        // \\uD83D\\uDCA1 BUILDING FORWARD: This pattern scales to process 200 records in Triggers\\n    }\\n}\",\n                explanation: \"Lists are ordered collections that allow duplicates. Always check isEmpty() before accessing elements to avoid ListException. Use enhanced for loops for cleaner iteration.\"\n            },\n            {\n                title: \"Set Operations\",\n                code: \"public class SetDemo {\\n    public void demonstrateSets() {\\n        // ✅ WHAT: Container for unique values only\\n        Set<String> uniqueEmails = new Set<String>();\\n        // ✅ WHY: Sets automatically prevent duplicates\\n        // ✅ PERFORMANCE: contains() is O(1) vs List O(n)\\n\\n        uniqueEmails.add('john@example.com');\\n        uniqueEmails.add('jane@example.com');\\n        uniqueEmails.add('john@example.com'); // Ignored - duplicate\\n\\n        System.debug('Size: ' + uniqueEmails.size()); // 2, not 3\\n\\n        // ✅ FAST LOOKUP: Use for existence checks\\n        if (uniqueEmails.contains('john@example.com')) {\\n            System.debug('Email found');\\n        }\\n    }\\n}\",\n                explanation: \"Sets enforce uniqueness and provide O(1) lookup performance. Use Sets when you need to prevent duplicates or perform fast existence checks.\"\n            },\n            {\n                title: \"Map Usage\",\n                code: \"public class MapDemo {\\n    public void processAccounts() {\\n        // ✅ WHAT: Key-value storage for fast lookups\\n        Map<Id, Account> accountMap = new Map<Id, Account>();\\n        // ✅ WHY: Get records by ID without loops\\n\\n        List<Account> accounts = [SELECT Id, Name FROM Account LIMIT 10];\\n\\n        // ✅ POPULATE: Add records to map\\n        for (Account acc : accounts) {\\n            accountMap.put(acc.Id, acc);\\n        }\\n\\n        // ✅ SAFE ACCESS: Check key exists\\n        Id searchId = accounts[0].Id;\\n        if (accountMap.containsKey(searchId)) {\\n            Account found = accountMap.get(searchId);\\n            System.debug('Found: ' + found.Name);\\n        }\\n    }\\n}\",\n                explanation: \"Maps provide key-value storage with O(1) lookup performance. Always use containsKey() before get() to avoid null issues. Essential for bulkification patterns.\"\n            }\n        ],\n        practiceQuestions: [\n            {\n                number: 1,\n                difficulty: \"beginner\",\n                question: \"What's the difference between a List and a Set in Apex?\",\n                answer: \"Lists allow duplicates and maintain order, Sets prevent duplicates and don't guarantee order\",\n                explanation: \"Lists are indexed collections that can contain duplicate values and maintain insertion order. Sets automatically enforce uniqueness - attempting to add a duplicate value is ignored, and elements are not stored in any particular order.\",\n                correctCode: \"List<String> names = new List<String>{'John', 'Jane', 'John'};  // 3 items\\nSet<String> uniqueNames = new Set<String>{'John', 'Jane', 'John'};  // 2 items\",\n                keyLearning: \"Choose Lists when order matters and duplicates are allowed. Choose Sets when you need to ensure uniqueness and fast lookups.\",\n                examTip: \"PD1 frequently tests List vs Set differences. Remember: Lists = order + duplicates, Sets = uniqueness + fast contains().\"\n            },\n            {\n                number: 2,\n                difficulty: \"beginner\",\n                question: \"How do you safely access the first element of a List?\",\n                answer: \"Check if the list is not empty first: if (!myList.isEmpty()) { firstElement = myList.get(0); }\",\n                explanation: \"Always check if a List has elements before accessing by index to avoid System.ListException. Using isEmpty() is more readable than checking size() > 0.\",\n                correctCode: \"List<String> names = new List<String>();\\nif (!names.isEmpty()) {\\n    String first = names.get(0);  // Safe access\\n} else {\\n    System.debug('List is empty');\\n}\",\n                keyLearning: \"Never assume a List has elements. Always check isEmpty() or size() before using get(index).\",\n                examTip: \"Index out of bounds exceptions are common exam scenarios. Always validate before accessing.\"\n            },\n            {\n                number: 3,\n                difficulty: \"intermediate\",\n                question: \"What's wrong with this bulkification pattern?\",\n                code: \"for (Account acc : Trigger.new) {\\n    List<Contact> contacts = [SELECT Id FROM Contact WHERE AccountId = :acc.Id];\\n    // Process contacts\\n}\",\n                answer: \"SOQL query inside a loop - will hit governor limits\",\n                explanation: \"Putting SOQL queries inside loops is the most common bulkification anti-pattern. With 200 accounts, this creates 200 separate queries, quickly hitting the 100 SOQL query limit per transaction.\",\n                correctCode: \"Set<Id> accountIds = new Set<Id>();\\nfor (Account acc : Trigger.new) {\\n    accountIds.add(acc.Id);\\n}\\nList<Contact> allContacts = [SELECT Id, AccountId FROM Contact WHERE AccountId IN :accountIds];\",\n                keyLearning: \"Always collect IDs first, then query once outside the loop. This is fundamental to writing scalable Apex.\",\n                examTip: \"Governor limit violations due to queries in loops are heavily tested on certification exams.\"\n            },\n            {\n                number: 4,\n                difficulty: \"intermediate\",\n                question: \"When should you use a Map instead of a List?\",\n                answer: \"When you need fast lookups by key or need to group related data\",\n                explanation: \"Maps provide O(1) lookup performance vs O(n) for Lists. Use Maps when you frequently need to find items by a unique identifier, or when grouping related objects together.\",\n                correctCode: \"// Good: Map for fast account lookup\\nMap<Id, Account> accountMap = new Map<Id, Account>([SELECT Id, Name FROM Account]);\\nAccount found = accountMap.get(someId);  // O(1) lookup\\n\\n// Bad: List requires loop for lookup\\nList<Account> accounts = [SELECT Id, Name FROM Account];\\nfor (Account acc : accounts) {  // O(n) lookup\\n    if (acc.Id == someId) { found = acc; break; }\\n}\",\n                keyLearning: \"Maps excel at key-based lookups and grouping. Lists are better for ordered data and iteration.\",\n                examTip: \"Performance questions about data structures appear frequently on Apex certification exams.\"\n            },\n            {\n                number: 5,\n                difficulty: \"advanced\",\n                question: \"You have a List with 100,000 records and need to check if a specific ID exists. What's the performance concern and solution?\",\n                answer: \"Linear search O(n) performance issue. Convert to Set or Map for O(1) lookups.\",\n                explanation: \"Lists require scanning every element to find matches, which becomes expensive with large datasets. Sets and Maps provide hash-based lookups that are dramatically faster for existence checks.\",\n                correctCode: \"// Problem: O(n) lookup - slow with large lists\\nList<Id> accountIds = new List<Id>(/* 100,000 IDs */);\\nBoolean exists = false;\\nfor (Id accId : accountIds) {\\n    if (accId == targetId) { exists = true; break; }  // Potentially scans all 100K\\n}\\n\\n// Solution 1: Set for existence checks - O(1)\\nSet<Id> accountIdSet = new Set<Id>(accountIds);\\nBoolean exists = accountIdSet.contains(targetId);  // Fast lookup\\n\\n// Solution 2: Map if you need the data too - O(1)\\nMap<Id, Account> accountMap = new Map<Id, Account>([SELECT Id, Name FROM Account]);\\nBoolean exists = accountMap.containsKey(targetId);\\nAccount foundAccount = accountMap.get(targetId);\",\n                keyLearning: \"Performance scales with collection choice. Use the right data structure: List for order, Set for uniqueness, Map for key-value relationships.\",\n                examTip: \"Performance scenarios with large datasets are common interview questions. Always think about time complexity.\"\n            },\n            {\n                number: 6,\n                difficulty: \"beginner\",\n                question: \"Explain when you'd use List vs Set vs Map with real Salesforce scenarios.\",\n                answer: \"List for ordered processing, Set for duplicate prevention, Map for key-based relationships\",\n                explanation: \"Each collection type serves specific business needs in Salesforce. Understanding when to use each prevents performance issues and makes code more maintainable.\",\n                correctCode: \"// List: When order matters and duplicates are OK\\nList<Task> taskHistory = [SELECT Id, Subject FROM Task WHERE AccountId = :accId ORDER BY CreatedDate];\\nfor (Task t : taskHistory) {\\n    // Process in chronological order\\n}\\n\\n// Set: When you need unique values only\\nSet<String> uniqueIndustries = new Set<String>();\\nfor (Account acc : accounts) {\\n    uniqueIndustries.add(acc.Industry);  // Automatically prevents duplicates\\n}\\n\\n// Map: When you need fast lookups or grouping\\nMap<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\nfor (Contact con : contacts) {\\n    if (!contactsByAccount.containsKey(con.AccountId)) {\\n        contactsByAccount.put(con.AccountId, new List<Contact>());\\n    }\\n    contactsByAccount.get(con.AccountId).add(con);\\n}\",\n                keyLearning: \"Collection choice drives performance and functionality. List = order, Set = uniqueness, Map = relationships.\",\n                examTip: \"Scenario-based questions test practical understanding. Think about the business requirement first.\"\n            },\n            {\n                number: 7,\n                difficulty: \"advanced\",\n                question: \"Code review: 'for(Account a : accounts) { for(Contact c : contacts) { if(c.AccountId == a.Id) {...} } }' - what's wrong?\",\n                answer: \"O(n\\xb2) performance problem. Use Map for O(n) solution.\",\n                explanation: \"Nested loops create quadratic time complexity. With 200 accounts and 1000 contacts, this performs 200,000 comparisons instead of the 1,200 needed with proper data structures.\",\n                correctCode: \"// Wrong: O(n\\xb2) - 200 accounts \\xd7 1000 contacts = 200,000 operations\\nfor (Account a : accounts) {\\n    for (Contact c : contacts) {\\n        if (c.AccountId == a.Id) {\\n            // Process - but this is VERY slow\\n        }\\n    }\\n}\\n\\n// Right: O(n) - Group contacts first, then lookup\\nMap<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\nfor (Contact c : contacts) {  // O(n) - 1000 operations\\n    if (!contactsByAccount.containsKey(c.AccountId)) {\\n        contactsByAccount.put(c.AccountId, new List<Contact>());\\n    }\\n    contactsByAccount.get(c.AccountId).add(c);\\n}\\n\\nfor (Account a : accounts) {  // O(n) - 200 operations\\n    List<Contact> accountContacts = contactsByAccount.get(a.Id);\\n    if (accountContacts != null) {\\n        // Process contacts for this account\\n    }\\n}\",\n                keyLearning: \"Avoid nested loops with large datasets. Group data with Maps to convert O(n\\xb2) to O(n) operations.\",\n                examTip: \"Performance anti-patterns are heavily tested. Nested loops = red flag for optimization.\"\n            },\n            {\n                number: 8,\n                difficulty: \"intermediate\",\n                question: \"You need to group Contacts by AccountId efficiently. Walk me through your approach.\",\n                answer: \"Use Map<Id, List<Contact>> to group related records in a single pass\",\n                explanation: \"Grouping is a common pattern in Salesforce. The key is to iterate once and build the grouped structure, avoiding multiple lookups or nested loops.\",\n                correctCode: \"public Map<Id, List<Contact>> groupContactsByAccount(List<Contact> contacts) {\\n    Map<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\n\\n    for (Contact con : contacts) {\\n        // Skip contacts without AccountId\\n        if (con.AccountId == null) continue;\\n\\n        // Initialize list if first contact for this account\\n        if (!contactsByAccount.containsKey(con.AccountId)) {\\n            contactsByAccount.put(con.AccountId, new List<Contact>());\\n        }\\n\\n        // Add contact to the account's list\\n        contactsByAccount.get(con.AccountId).add(con);\\n    }\\n\\n    return contactsByAccount;\\n}\\n\\n// Usage example\\nMap<Id, List<Contact>> grouped = groupContactsByAccount(allContacts);\\nfor (Id accountId : grouped.keySet()) {\\n    List<Contact> accountContacts = grouped.get(accountId);\\n    System.debug('Account ' + accountId + ' has ' + accountContacts.size() + ' contacts');\\n}\",\n                keyLearning: \"Grouping pattern: Map<KeyType, List<ValueType>>. Iterate once, check if key exists, initialize list, add item.\",\n                examTip: \"Grouping questions are common. Master this pattern: it's used everywhere in Salesforce development.\"\n            },\n            {\n                number: 9,\n                difficulty: \"beginner\",\n                question: \"A List might contain nulls and duplicates. Write code to clean it up safely.\",\n                answer: \"Use Set for deduplication and null checks for cleaning\",\n                explanation: \"Real-world data often contains nulls and duplicates. Cleaning collections safely requires handling both issues without causing exceptions.\",\n                correctCode: \"public List<String> cleanStringList(List<String> inputList) {\\n    if (inputList == null || inputList.isEmpty()) {\\n        return new List<String>();\\n    }\\n\\n    Set<String> uniqueValues = new Set<String>();\\n\\n    for (String item : inputList) {\\n        // Skip null and blank values\\n        if (String.isNotBlank(item)) {\\n            // Set automatically handles duplicates\\n            uniqueValues.add(item.trim());\\n        }\\n    }\\n\\n    // Convert back to List if order matters for caller\\n    return new List<String>(uniqueValues);\\n}\\n\\n// Usage\\nList<String> dirtyList = new List<String>{'John', null, 'Jane', 'John', '  ', 'Bob'};\\nList<String> cleanList = cleanStringList(dirtyList);\\n// Result: ['John', 'Jane', 'Bob'] - no nulls, no duplicates, trimmed\",\n                keyLearning: \"Collection cleaning: null checks prevent exceptions, Sets remove duplicates automatically.\",\n                examTip: \"Data validation scenarios are frequent. Always handle null input gracefully.\"\n            },\n            {\n                number: 10,\n                difficulty: \"intermediate\",\n                question: \"You're processing Opportunity data and need fast lookups by Stage. What collection strategy do you use?\",\n                answer: \"Map<String, List<Opportunity>> to group by stage with fast access\",\n                explanation: \"Business reporting often requires grouping records by field values. Maps provide both fast access and logical grouping for analysis.\",\n                correctCode: \"public Map<String, List<Opportunity>> groupOpportunitiesByStage(List<Opportunity> opps) {\\n    Map<String, List<Opportunity>> oppsByStage = new Map<String, List<Opportunity>>();\\n\\n    for (Opportunity opp : opps) {\\n        String stage = opp.StageName ?? 'Unknown';  // Handle null stages\\n\\n        if (!oppsByStage.containsKey(stage)) {\\n            oppsByStage.put(stage, new List<Opportunity>());\\n        }\\n\\n        oppsByStage.get(stage).add(opp);\\n    }\\n\\n    return oppsByStage;\\n}\\n\\n// Business logic usage\\nMap<String, List<Opportunity>> oppsByStage = groupOpportunitiesByStage(opportunities);\\n\\n// Fast analysis\\nList<Opportunity> closedWon = oppsByStage.get('Closed Won');\\nList<Opportunity> negotiation = oppsByStage.get('Negotiation/Review');\\n\\nSystem.debug('Closed Won count: ' + (closedWon?.size() ?? 0));\\nSystem.debug('In Negotiation: ' + (negotiation?.size() ?? 0));\",\n                keyLearning: \"Grouping enables fast business analysis. Map structure mirrors business logic for intuitive access.\",\n                examTip: \"Business scenario questions test practical application. Think about how business users would want to access the data.\"\n            }\n        ]\n    },\n    \"control-flow-and-loops\": {\n        title: \"Control Flow and Loops\",\n        overview: 'Master decision-making in your code. Now that you have Variables (single values) and Collections (multiple values), learn to make DECISIONS about that data. Control flow is where business logic lives - every \"if this then that\" rule in Salesforce. This directly leads to Classes (organizing decision logic) and Triggers (automated decisions).',\n        codeExamples: [\n            {\n                title: \"Decision Making with Business Logic\",\n                code: \"public class ControlFlowDemo {\\n    // ✅ BUILDING ON: Collections from previous topic\\n    public void processLeads(List<Lead> leads) {\\n        // ✅ NEW CONCEPT: Decision making with collected data\\n        List<Lead> hotLeads = new List<Lead>();\\n        List<Lead> coldLeads = new List<Lead>();\\n\\n        // ✅ ENHANCED FOR LOOP: Process each item in collection\\n        for (Lead lead : leads) {\\n            // ✅ CONNECTION: Same for loop pattern you'll use everywhere\\n            // ✅ WHY enhanced for: Safer than index loops, no out-of-bounds\\n\\n            // ✅ CONDITIONAL LOGIC: Business decision making\\n            if (lead.AnnualRevenue != null && lead.AnnualRevenue > 1000000) {\\n                // ✅ NULL SAFETY: Always check null first (from Variables topic)\\n                // ✅ BUSINESS LOGIC: Categorize high-value prospects\\n                hotLeads.add(lead);\\n\\n                // ✅ NESTED CONDITIONS: More complex decision trees\\n                if (lead.Industry == 'Technology') {\\n                    lead.Rating = 'Hot';\\n                    // ✅ CONNECTION: This pattern crucial in Triggers topic\\n                }\\n            } else if (lead.AnnualRevenue != null && lead.AnnualRevenue > 100000) {\\n                // ✅ ELSE IF: Handle multiple conditions efficiently\\n                lead.Rating = 'Warm';\\n            } else {\\n                // ✅ ELSE: Catch-all for remaining cases\\n                coldLeads.add(lead);\\n            }\\n        }\\n\\n        // ✅ CONDITIONAL PROCESSING: Only act if data exists\\n        if (!hotLeads.isEmpty()) {\\n            // \\uD83D\\uDCA1 NEXT TOPIC: You'll organize this logic into Classes\\n            processHotLeads(hotLeads);\\n        }\\n    }\\n\\n    private void processHotLeads(List<Lead> leads) {\\n        for (Lead lead : leads) {\\n            lead.Status = 'Working - Contacted';\\n        }\\n    }\\n}\",\n                explanation: \"Always check for null before comparing values. Use explicit boolean comparisons (== true) for null-safe logic with Boolean fields that can be null.\"\n            },\n            {\n                title: \"Switch Statements and Advanced Patterns\",\n                code: \"public class SwitchPatterns {\\n    // ✅ SWITCH STATEMENT: Clean multiple exact comparisons\\n    public String categorizeBySource(Lead lead) {\\n        // ✅ WHEN TO USE: Multiple exact value comparisons (not ranges)\\n        switch on lead.LeadSource {\\n            when 'Web' {\\n                return 'Digital Marketing';\\n            }\\n            when 'Phone Inquiry', 'Cold Call' {\\n                // ✅ MULTIPLE VALUES: Comma-separated in single case\\n                return 'Direct Sales';\\n            }\\n            when 'Partner Referral' {\\n                return 'Channel Partners';\\n            }\\n            when else {\\n                // ✅ DEFAULT CASE: Handle unmatched values\\n                return 'Unknown Source';\\n            }\\n        }\\n        // \\uD83D\\uDCA1 NEXT TOPIC: This decision logic will be reused in Classes\\n    }\\n\\n    // ✅ EARLY EXIT PATTERNS: Improve performance\\n    public void processOpportunities(List<Opportunity> opps) {\\n        for (Opportunity opp : opps) {\\n            // ✅ GUARD CLAUSE: Early exit for invalid data\\n            if (opp.Amount == null || opp.Amount <= 0) {\\n                continue; // Skip to next iteration\\n            }\\n\\n            // ✅ BUSINESS LOGIC: Only process valid opportunities\\n            if (opp.StageName == 'Closed Won') {\\n                // Process won opportunity\\n                System.debug('Processing won opp: ' + opp.Amount);\\n\\n                // ✅ BREAK: Exit loop if we found what we need\\n                if (opp.Amount > 1000000) {\\n                    System.debug('Found large deal, stopping search');\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n}\",\n                explanation: \"Choose the right loop type: enhanced for when processing all elements, traditional for when you need indexes, while when the iteration count depends on conditions.\"\n            }\n        ],\n        practiceQuestions: [\n            {\n                number: 1,\n                difficulty: \"advanced\",\n                question: \"You see nested for loops processing 1000+ records in a trigger. What's the performance issue and how do you fix it?\",\n                answer: \"O(n\\xb2) complexity causing CPU timeout. Use Maps to flatten to O(n).\",\n                explanation: \"Nested loops create quadratic time complexity. With 1000 records, this means 1,000,000 operations. This quickly hits CPU timeout limits in Salesforce. The solution is to use Maps for grouping data.\",\n                correctCode: \"// Wrong: O(n\\xb2) - 1000 \\xd7 1000 = 1,000,000 operations\\nfor (Account acc : accounts) {\\n    for (Contact con : contacts) {\\n        if (con.AccountId == acc.Id) {\\n            // Process - but VERY slow\\n        }\\n    }\\n}\\n\\n// Right: O(n) - Group first, then process\\nMap<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\nfor (Contact con : contacts) {  // 1000 operations\\n    if (!contactsByAccount.containsKey(con.AccountId)) {\\n        contactsByAccount.put(con.AccountId, new List<Contact>());\\n    }\\n    contactsByAccount.get(con.AccountId).add(con);\\n}\\n\\nfor (Account acc : accounts) {  // 1000 more operations\\n    List<Contact> relatedContacts = contactsByAccount.get(acc.Id);\\n    // Process efficiently\\n}\",\n                keyLearning: \"Nested loops are a performance killer. Always flatten to single loops with Maps for grouping.\",\n                examTip: \"Performance optimization questions are common. Nested loops = immediate red flag for O(n\\xb2) complexity.\"\n            },\n            {\n                number: 2,\n                difficulty: \"intermediate\",\n                question: \"A developer uses `if (lead.Company.startsWith('Acme'))` - what could go wrong and how do you fix it?\",\n                answer: \"NullPointerException if Company is null. Use null-safe navigation.\",\n                explanation: \"Field values in Salesforce can be null. Calling methods directly on potentially null fields throws NullPointerException at runtime. Always check for null first or use safe navigation.\",\n                correctCode: \"// Wrong - throws NPE if Company is null\\nif (lead.Company.startsWith('Acme')) {\\n    // Process\\n}\\n\\n// Option 1: Traditional null check\\nif (lead.Company != null && lead.Company.startsWith('Acme')) {\\n    // Process safely\\n}\\n\\n// Option 2: Safe navigation (modern Apex)\\nif (lead.Company?.startsWith('Acme') == true) {\\n    // Process safely\\n}\\n\\n// Option 3: Null-coalescing for default\\nString company = lead.Company ?? '';\\nif (company.startsWith('Acme')) {\\n    // Process safely\\n}\",\n                keyLearning: \"Always assume Salesforce fields can be null. Use null checks or safe navigation before calling methods.\",\n                examTip: \"Null safety is heavily tested. Look for method calls on fields without null checks.\"\n            },\n            {\n                number: 3,\n                difficulty: \"beginner\",\n                question: \"When would you choose switch over if/else statements?\",\n                answer: \"Switch for multiple exact value comparisons, if/else for ranges or complex conditions\",\n                explanation: \"Switch statements are cleaner and more performant for comparing a single variable against multiple exact values. Use if/else for range comparisons, complex boolean logic, or when you need different variables in each condition.\",\n                correctCode: \"// Good use of switch: exact value matching\\nswitch on lead.Status {\\n    when 'Open - Not Contacted' {\\n        lead.Priority = 'High';\\n    }\\n    when 'Working - Contacted' {\\n        lead.Priority = 'Medium';\\n    }\\n    when 'Closed - Converted', 'Closed - Not Converted' {\\n        lead.Priority = 'Low';\\n    }\\n    when else {\\n        lead.Priority = 'Unknown';\\n    }\\n}\\n\\n// Better with if/else: range comparisons\\nif (lead.AnnualRevenue > 1000000) {\\n    lead.Rating = 'Hot';\\n} else if (lead.AnnualRevenue > 100000) {\\n    lead.Rating = 'Warm';\\n} else {\\n    lead.Rating = 'Cold';\\n}\",\n                keyLearning: \"Switch = exact values, if/else = ranges/complex logic. Choose based on what you're comparing.\",\n                examTip: \"Control structure choice questions test understanding of appropriate usage patterns.\"\n            },\n            {\n                number: 4,\n                difficulty: \"intermediate\",\n                question: \"Explain the difference between `break` and `continue` with examples.\",\n                answer: \"`break` exits the entire loop, `continue` skips to the next iteration\",\n                explanation: \"These control statements change loop execution flow. `break` immediately exits the loop entirely, while `continue` skips the remaining code in the current iteration and moves to the next iteration.\",\n                correctCode: \"List<Account> accounts = [SELECT Id, Name, AnnualRevenue FROM Account];\\n\\n// Using continue - skip invalid records\\nfor (Account acc : accounts) {\\n    if (acc.AnnualRevenue == null) {\\n        continue; // Skip this account, go to next iteration\\n    }\\n\\n    // This code only runs for accounts with revenue\\n    acc.Rating = acc.AnnualRevenue > 1000000 ? 'Hot' : 'Cold';\\n}\\n\\n// Using break - exit when found\\nfor (Account acc : accounts) {\\n    if (acc.Name == 'Target Account') {\\n        System.debug('Found target account');\\n        break; // Exit loop completely, don't process remaining accounts\\n    }\\n\\n    // This code runs until target is found\\n    System.debug('Still searching: ' + acc.Name);\\n}\",\n                keyLearning: \"continue = skip current iteration, break = exit entire loop. Use continue for filtering, break for early termination.\",\n                examTip: \"Loop control questions test understanding of flow modification. Remember: continue skips, break exits.\"\n            },\n            {\n                number: 5,\n                difficulty: \"beginner\",\n                question: \"You need to process only the first 50 records in a list. Show two approaches.\",\n                answer: \"Use LIMIT in SOQL query or traditional for loop with counter\",\n                explanation: \"When you only need a subset of records, it's more efficient to limit at the query level. If you already have the full list, use a traditional for loop with index control.\",\n                correctCode: \"// Approach 1: Limit at query level (BEST)\\nList<Lead> leads = [SELECT Id, Name FROM Lead ORDER BY CreatedDate LIMIT 50];\\nfor (Lead lead : leads) {\\n    // Process all 50 records\\n}\\n\\n// Approach 2: Limit during processing\\nList<Lead> allLeads = [SELECT Id, Name FROM Lead ORDER BY CreatedDate];\\nfor (Integer i = 0; i < Math.min(allLeads.size(), 50); i++) {\\n    Lead lead = allLeads.get(i);\\n    // Process only first 50\\n}\\n\\n// Approach 3: Enhanced for with counter\\nList<Lead> allLeads = [SELECT Id, Name FROM Lead ORDER BY CreatedDate];\\nInteger count = 0;\\nfor (Lead lead : allLeads) {\\n    if (count >= 50) break;\\n\\n    // Process record\\n    count++;\\n}\",\n                keyLearning: \"Always prefer limiting at the database level (SOQL LIMIT) rather than in Apex loops for better performance.\",\n                examTip: \"Query optimization questions favor database-level filtering over Apex-level filtering.\"\n            },\n            {\n                number: 6,\n                difficulty: \"intermediate\",\n                question: \"What's wrong with `if (stringValue == null || stringValue == '') {...}` and how do you improve it?\",\n                answer: \"Verbose and doesn't handle whitespace. Use String.isBlank() for comprehensive checking\",\n                explanation: \"Manual null and empty checking is verbose and error-prone. String.isBlank() handles null, empty string, and whitespace-only strings in one call, making code cleaner and more robust.\",\n                correctCode: \"String stringValue = getValueFromSomewhere();\\n\\n// Verbose and incomplete\\nif (stringValue == null || stringValue == '') {\\n    // Doesn't catch '   ' (whitespace only)\\n}\\n\\n// Better but still verbose\\nif (stringValue == null || stringValue.trim().length() == 0) {\\n    // Handles whitespace but verbose\\n}\\n\\n// Best: comprehensive and concise\\nif (String.isBlank(stringValue)) {\\n    // Handles null, empty, and whitespace-only\\n}\\n\\n// For processing with default\\nString processedValue = String.isBlank(stringValue) ? 'Default' : stringValue.trim();\",\n                keyLearning: \"Use String utility methods (isBlank, isNotBlank, isNotEmpty) instead of manual null/empty checks.\",\n                examTip: \"String validation questions favor utility methods over manual checking. Remember: isBlank includes whitespace.\"\n            },\n            {\n                number: 7,\n                difficulty: \"advanced\",\n                question: \"A loop is causing 'CPU timeout exceeded'. How do you optimize it?\",\n                answer: \"Move to asynchronous processing, reduce complexity, or use database operations instead of loops\",\n                explanation: \"CPU timeouts occur when synchronous Apex runs too long (10 seconds). Solutions include moving heavy processing to async context, optimizing algorithms, or replacing Apex loops with database operations.\",\n                correctCode: \"// Problem: Heavy processing in sync context\\npublic void processLargeDataset(List<Account> accounts) {\\n    for (Account acc : accounts) {\\n        // Complex calculations causing timeout\\n        for (Contact con : [SELECT Id FROM Contact WHERE AccountId = :acc.Id]) {\\n            // Nested query + processing = CPU killer\\n        }\\n    }\\n}\\n\\n// Solution 1: Move to async\\n@future\\npublic static void processLargeDatasetAsync(List<Id> accountIds) {\\n    // 60 second limit instead of 10 seconds\\n    List<Account> accounts = [SELECT Id FROM Account WHERE Id IN :accountIds];\\n    // Process with higher limits\\n}\\n\\n// Solution 2: Bulkify queries\\npublic void processLargeDatasetBulk(List<Account> accounts) {\\n    Set<Id> accountIds = new Set<Id>();\\n    for (Account acc : accounts) {\\n        accountIds.add(acc.Id);\\n    }\\n\\n    // Single query instead of loop queries\\n    Map<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\n    for (Contact con : [SELECT Id, AccountId FROM Contact WHERE AccountId IN :accountIds]) {\\n        // Group efficiently\\n    }\\n}\",\n                keyLearning: \"CPU timeouts require architectural changes: async processing, query bulkification, or database operations.\",\n                examTip: \"Governor limit scenarios test understanding of Salesforce platform constraints and optimization strategies.\"\n            },\n            {\n                number: 8,\n                difficulty: \"beginner\",\n                question: \"You're processing Account records and need to skip inactive ones. Best approach?\",\n                answer: \"Use continue statement to skip inactive accounts in the loop\",\n                explanation: \"When you need to skip certain records during processing, the continue statement provides clean, readable code that moves to the next iteration without deeply nesting the main logic.\",\n                correctCode: \"public void processAccounts(List<Account> accounts) {\\n    for (Account acc : accounts) {\\n        // Guard clause: skip inactive accounts\\n        if (acc.Active__c != true) {\\n            continue; // Skip to next account\\n        }\\n\\n        // Main processing logic only runs for active accounts\\n        if (acc.AnnualRevenue > 1000000) {\\n            acc.Rating = 'Hot';\\n        }\\n\\n        acc.LastProcessed__c = System.now();\\n        System.debug('Processed active account: ' + acc.Name);\\n    }\\n}\\n\\n// Alternative: filter in query (even better)\\nList<Account> activeAccounts = [SELECT Id, Name, AnnualRevenue FROM Account WHERE Active__c = true];\\nfor (Account acc : activeAccounts) {\\n    // All accounts are already active\\n}\",\n                keyLearning: \"Use continue for clean guard clauses, but prefer filtering in SOQL queries when possible.\",\n                examTip: \"Early exit patterns improve code readability. Guard clauses with continue are preferred over deep nesting.\"\n            },\n            {\n                number: 9,\n                difficulty: \"intermediate\",\n                question: \"Explain when enhanced for loops are preferred over traditional for loops.\",\n                answer: \"Enhanced for when processing all elements, traditional for when you need index or skip elements\",\n                explanation: \"Enhanced for loops are safer (no index bounds issues) and cleaner for processing all elements. Traditional for loops give you index control for partial processing or when you need element position.\",\n                correctCode: \"List<Contact> contacts = [SELECT Id, Name, Email FROM Contact];\\n\\n// Enhanced for: Process all elements (PREFERRED)\\nfor (Contact con : contacts) {\\n    // Clean, safe, no index management\\n    if (String.isNotBlank(con.Email)) {\\n        sendEmail(con.Email);\\n    }\\n}\\n\\n// Traditional for: When you need the index\\nfor (Integer i = 0; i < contacts.size(); i++) {\\n    Contact con = contacts.get(i);\\n    System.debug('Processing contact #' + (i + 1) + ': ' + con.Name);\\n}\\n\\n// Traditional for: Process only first half\\nfor (Integer i = 0; i < contacts.size() / 2; i++) {\\n    Contact con = contacts.get(i);\\n    // Process subset\\n}\\n\\n// Traditional for: Skip every other element\\nfor (Integer i = 0; i < contacts.size(); i += 2) {\\n    Contact con = contacts.get(i);\\n    // Process every other contact\\n}\",\n                keyLearning: \"Enhanced for = all elements safely. Traditional for = index control and partial processing.\",\n                examTip: \"Loop choice questions test understanding of when index access is necessary vs. simple iteration.\"\n            },\n            {\n                number: 10,\n                difficulty: \"advanced\",\n                question: \"A business rule has 8 different conditions. How do you structure this cleanly?\",\n                answer: \"Use early returns, switch statements, or strategy pattern to avoid deep nesting\",\n                explanation: \"Multiple conditions can create deeply nested, hard-to-read code. Clean approaches include guard clauses with early returns, switch statements for exact matches, or organizing into separate methods.\",\n                correctCode: \"// Problem: Deep nesting with many conditions\\npublic String categorizeOpportunity(Opportunity opp) {\\n    if (opp.Amount != null) {\\n        if (opp.Amount > 1000000) {\\n            if (opp.Probability > 80) {\\n                if (opp.Type == 'New Customer') {\\n                    // Deep nesting continues...\\n                }\\n            }\\n        }\\n    }\\n    return 'Unknown';\\n}\\n\\n// Solution 1: Early returns (guard clauses)\\npublic String categorizeOpportunityClean(Opportunity opp) {\\n    // Handle invalid cases early\\n    if (opp.Amount == null) return 'No Amount';\\n    if (opp.Probability == null) return 'No Probability';\\n\\n    // Large deals\\n    if (opp.Amount > 1000000) {\\n        if (opp.Probability > 80) return 'Large Sure Deal';\\n        if (opp.Probability > 50) return 'Large Likely Deal';\\n        return 'Large Risky Deal';\\n    }\\n\\n    // Medium deals\\n    if (opp.Amount > 100000) {\\n        return opp.Probability > 70 ? 'Medium Sure Deal' : 'Medium Deal';\\n    }\\n\\n    return 'Small Deal';\\n}\\n\\n// Solution 2: Switch for exact matching\\npublic String categorizeByStage(Opportunity opp) {\\n    switch on opp.StageName {\\n        when 'Prospecting', 'Qualification' { return 'Early Stage'; }\\n        when 'Needs Analysis', 'Value Proposition' { return 'Mid Stage'; }\\n        when 'Id. Decision Makers', 'Perception Analysis' { return 'Late Stage'; }\\n        when 'Proposal/Price Quote', 'Negotiation/Review' { return 'Final Stage'; }\\n        when 'Closed Won' { return 'Won'; }\\n        when 'Closed Lost' { return 'Lost'; }\\n        when else { return 'Unknown Stage'; }\\n    }\\n}\",\n                keyLearning: \"Complex conditions need clean structure: early returns, switch statements, or separate methods to avoid nesting.\",\n                examTip: \"Code quality questions test ability to write maintainable logic. Deep nesting is an anti-pattern.\"\n            }\n        ]\n    },\n    \"classes-and-objects\": {\n        title: \"Classes and Objects\",\n        overview: \"Master object-oriented programming in Apex. Your control flow logic needs organization and reusability - Classes are containers for related functionality. Understanding classes is crucial because 30% of Salesforce development involves creating and using custom classes. This knowledge directly enables SOQL operations (organized data access) and Triggers (organized automation).\",\n        codeExamples: [\n            {\n                title: \"Class Structure\",\n                code: \"public class CustomerManager {\\n    // ✅ BUILDING ON: Control flow logic needs organization and reusability\\n    // ✅ NEW CONCEPT: Classes are containers for related functionality\\n\\n    // ✅ INSTANCE VARIABLES: Data that belongs to each object\\n    private String managerName;\\n    private Integer customersProcessed;\\n    private List<String> processedCustomerIds;\\n    // ✅ WHY private: Encapsulation - controlled access only\\n    // ✅ CONNECTION: Same variable principles from Variables topic\\n    // \\uD83D\\uDCA1 NEXT TOPIC: SOQL will populate these with real data\\n\\n    // ✅ STATIC VARIABLES: Shared across ALL objects of this class\\n    private static Integer totalCustomersProcessed = 0;\\n    // ✅ WHAT: One copy shared by all CustomerManager objects\\n    // ✅ WHY: Track global statistics across all instances\\n\\n    // ✅ CONSTANTS: Values that never change\\n    public static final Integer MAX_CUSTOMERS_PER_BATCH = 200;\\n    // ✅ WHY 200: Salesforce governor limits for bulk processing\\n\\n    // ✅ CONSTRUCTOR: Initialize object when created\\n    public CustomerManager(String name) {\\n        // ✅ WHAT: Runs automatically when object created with 'new'\\n        // ✅ WHY: Ensures object starts in valid state\\n        this.managerName = name;\\n        this.customersProcessed = 0;\\n        this.processedCustomerIds = new List<String>();\\n        // ✅ CONNECTION: List initialization from Collections topic\\n        // \\uD83D\\uDC80 EXAM TRAP: Forgetting to initialize collections = null errors\\n    }\\n\\n    // ✅ INSTANCE METHOD: Operates on specific object's data\\n    public void processCustomer(Account customer) {\\n        // ✅ VALIDATION: Same patterns from Control Flow topic\\n        if (customer == null || String.isBlank(customer.Name)) {\\n            System.debug('Invalid customer data provided');\\n            return; // Early exit pattern\\n        }\\n\\n        // ✅ BUSINESS LOGIC: Apply processing rules\\n        if (customer.AnnualRevenue != null && customer.AnnualRevenue > 100000) {\\n            customer.CustomerPriority__c = 'High';\\n            // ✅ CONNECTION: Conditional logic from Control Flow topic\\n        }\\n\\n        // ✅ STATE TRACKING: Update object's internal data\\n        this.customersProcessed++;\\n        this.processedCustomerIds.add(customer.Id);\\n        totalCustomersProcessed++; // Static variable\\n\\n        System.debug(this.managerName + ' processed: ' + customer.Name);\\n        // \\uD83D\\uDCA1 NEXT TOPIC: SOQL will provide customer data efficiently\\n    }\\n\\n    // ✅ STATIC METHOD: Utility function, no object needed\\n    public static Boolean isHighValueCustomer(Account customer) {\\n        // ✅ WHEN TO USE: Pure function that doesn't need object state\\n        // ✅ REUSABILITY: Can be called from anywhere\\n        if (customer?.AnnualRevenue == null) {\\n            return false;\\n        }\\n        return customer.AnnualRevenue > 500000;\\n        // ✅ CONNECTION: Null safety from Variables topic\\n    }\\n\\n    // ✅ GETTER METHOD: Controlled access to private data\\n    public Integer getCustomersProcessed() {\\n        return this.customersProcessed;\\n        // ✅ ENCAPSULATION: Read-only access to internal state\\n    }\\n}\\n\\n// ✅ USAGE EXAMPLE: How classes work together\\npublic class BusinessLogicExample {\\n    public void demonstrateClassUsage() {\\n        // ✅ OBJECT CREATION: Constructor runs automatically\\n        CustomerManager salesManager = new CustomerManager('John Smith');\\n        CustomerManager supportManager = new CustomerManager('Jane Doe');\\n        // ✅ MULTIPLE OBJECTS: Each has its own state\\n\\n        // ✅ STATIC METHOD: Called on class, not object\\n        List<Account> accounts = [SELECT Id, Name, AnnualRevenue FROM Account LIMIT 10];\\n\\n        for (Account acc : accounts) {\\n            // ✅ DECISION LOGIC: From Control Flow topic\\n            if (CustomerManager.isHighValueCustomer(acc)) {\\n                salesManager.processCustomer(acc);\\n                // ✅ INSTANCE METHOD: Called on specific object\\n            }\\n        }\\n\\n        System.debug('Sales processed: ' + salesManager.getCustomersProcessed());\\n        // \\uD83D\\uDCA1 NEXT TOPIC: SOQL will get data more efficiently\\n    }\\n}\",\n                explanation: \"Classes encapsulate related data and behavior. Use instance variables for object state, constructors for initialization, instance methods for object operations, and static methods for utilities.\"\n            }\n        ],\n        practiceQuestions: [\n            {\n                number: 1,\n                difficulty: \"beginner\",\n                question: \"What's the difference between a class and an object in Apex?\",\n                answer: \"A class is a blueprint/template, an object is an instance created from that class\",\n                explanation: \"A class defines the structure (variables and methods) but doesn't exist in memory. An object is a specific instance of that class that actually holds data and can execute methods.\",\n                correctCode: \"public class Account {\\n    public String name;  // Class defines structure\\n    public void display() { System.debug(name); }\\n}\\n\\n// Object creation from class\\nAccount myAccount = new Account();  // Create object instance\\nmyAccount.name = 'Acme Corp';       // Set data in object\\nmyAccount.display();                // Call method on object\",\n                keyLearning: \"Class = blueprint, Object = actual instance. You need to instantiate a class with 'new' to create an object.\",\n                examTip: \"PD1 frequently tests understanding of classes vs objects. Remember: classes define, objects execute.\"\n            },\n            {\n                number: 2,\n                difficulty: \"beginner\",\n                question: \"When should you use a constructor in Apex?\",\n                answer: \"When you need to initialize instance variables or perform setup when an object is created\",\n                explanation: \"Constructors ensure objects start in a valid state. Use them to set default values, initialize collections, or perform validation. If you don't create a constructor, Apex provides a default no-argument constructor.\",\n                correctCode: \"public class OrderProcessor {\\n    private String processorName;\\n    private List<Order> pendingOrders;\\n    private DateTime createdAt;\\n\\n    // Constructor initializes object state\\n    public OrderProcessor(String name) {\\n        this.processorName = name;\\n        this.pendingOrders = new List<Order>(); // Initialize collection\\n        this.createdAt = System.now();          // Set timestamp\\n\\n        // Validation in constructor\\n        if (String.isBlank(name)) {\\n            throw new IllegalArgumentException('Processor name cannot be blank');\\n        }\\n    }\\n\\n    // Overloaded constructor with different parameters\\n    public OrderProcessor(String name, Integer initialCapacity) {\\n        this(name); // Call other constructor\\n        this.pendingOrders = new List<Order>(initialCapacity);\\n    }\\n}\",\n                keyLearning: \"Constructors initialize object state and ensure valid starting conditions. Always initialize collections to avoid null errors.\",\n                examTip: \"Constructor questions often test initialization patterns and overloading. Remember: no return type for constructors.\"\n            },\n            {\n                number: 3,\n                difficulty: \"intermediate\",\n                question: \"What's the difference between instance and static methods? When would you use each?\",\n                answer: \"Instance methods operate on object data, static methods are utilities that don't need object state\",\n                explanation: \"Instance methods have access to instance variables and represent object behavior. Static methods can't access instance variables and are called on the class itself, not objects.\",\n                correctCode: \"public class CustomerService {\\n    private String serviceName;\\n    private Integer requestsHandled;\\n\\n    // Instance method - needs object state\\n    public void handleCustomerRequest(Case customerCase) {\\n        this.requestsHandled++;  // Uses instance variable\\n        System.debug(this.serviceName + ' handled case: ' + customerCase.Subject);\\n    }\\n\\n    // Static method - utility function, no object needed\\n    public static Boolean isHighPriorityCase(Case customerCase) {\\n        return customerCase.Priority == 'High' || customerCase.Priority == 'Critical';\\n        // No access to instance variables\\n    }\\n\\n    // Static method - helper for calculations\\n    public static Decimal calculateSLA(DateTime created, String priority) {\\n        Decimal hours = 24; // Default\\n        if (priority == 'High') hours = 4;\\n        if (priority == 'Critical') hours = 1;\\n        return hours;\\n    }\\n}\\n\\n// Usage examples\\nCustomerService service = new CustomerService();\\nservice.handleCustomerRequest(someCase); // Instance method\\n\\nBoolean isHigh = CustomerService.isHighPriorityCase(someCase); // Static method\",\n                keyLearning: \"Instance methods for object-specific operations, static methods for utilities and helper functions.\",\n                examTip: \"Static method questions test understanding of when object state is needed vs. pure functions.\"\n            },\n            {\n                number: 4,\n                difficulty: \"beginner\",\n                question: \"What is encapsulation and why use private variables?\",\n                answer: \"Encapsulation hides internal implementation details and controls access to data through public methods\",\n                explanation: \"Private variables prevent external code from directly modifying object state. This ensures data integrity and allows you to control how data is accessed or modified.\",\n                correctCode: \"public class BankAccount {\\n    // Private variables - cannot be accessed directly from outside\\n    private Decimal balance;\\n    private String accountNumber;\\n\\n    public BankAccount(String accNum, Decimal initialBalance) {\\n        this.accountNumber = accNum;\\n        this.balance = initialBalance;\\n    }\\n\\n    // Public getter - controlled read access\\n    public Decimal getBalance() {\\n        return this.balance;\\n    }\\n\\n    // Public method with validation - controlled write access\\n    public Boolean withdraw(Decimal amount) {\\n        if (amount <= 0) {\\n            System.debug('Invalid withdrawal amount');\\n            return false;\\n        }\\n\\n        if (amount > this.balance) {\\n            System.debug('Insufficient funds');\\n            return false;\\n        }\\n\\n        this.balance -= amount; // Controlled modification\\n        return true;\\n    }\\n\\n    // Direct access prevented:\\n    // account.balance = -1000; // COMPILATION ERROR - private variable\\n}\",\n                keyLearning: \"Private variables with public methods provide controlled access and maintain data integrity.\",\n                examTip: \"Encapsulation questions test understanding of access modifiers and data protection principles.\"\n            },\n            {\n                number: 5,\n                difficulty: \"advanced\",\n                question: \"Your class needs to track total records processed across all instances. How do you implement this?\",\n                answer: \"Use a static variable that's shared across all instances of the class\",\n                explanation: \"Static variables belong to the class, not individual objects. All instances share the same static variable, making it perfect for tracking global counters or shared state.\",\n                correctCode: \"public class RecordProcessor {\\n    // Static variable - shared across ALL instances\\n    private static Integer totalRecordsProcessed = 0;\\n    private static Map<String, Integer> processingStats = new Map<String, Integer>();\\n\\n    // Instance variables - unique to each object\\n    private String processorName;\\n    private Integer instanceRecordsProcessed;\\n\\n    public RecordProcessor(String name) {\\n        this.processorName = name;\\n        this.instanceRecordsProcessed = 0;\\n    }\\n\\n    public void processRecord(SObject record) {\\n        // Update instance counter\\n        this.instanceRecordsProcessed++;\\n\\n        // Update shared static counter\\n        totalRecordsProcessed++;\\n\\n        // Update shared stats\\n        String objectType = record.getSObjectType().getDescribe().getName();\\n        Integer currentCount = processingStats.get(objectType);\\n        processingStats.put(objectType, (currentCount == null ? 1 : currentCount + 1));\\n    }\\n\\n    // Static method to access shared data\\n    public static Integer getTotalRecordsProcessed() {\\n        return totalRecordsProcessed;\\n    }\\n\\n    public static Map<String, Integer> getProcessingStats() {\\n        return processingStats.clone(); // Return copy for safety\\n    }\\n}\\n\\n// Usage - all instances share static variables\\nRecordProcessor proc1 = new RecordProcessor('Processor1');\\nRecordProcessor proc2 = new RecordProcessor('Processor2');\\n\\nproc1.processRecord(someAccount);  // totalRecordsProcessed = 1\\nproc2.processRecord(someContact);  // totalRecordsProcessed = 2\\n\\nSystem.debug(RecordProcessor.getTotalRecordsProcessed()); // 2\",\n                keyLearning: \"Static variables are shared across all instances and persist for the entire transaction.\",\n                examTip: \"Static variable questions test understanding of class-level vs instance-level data sharing.\"\n            },\n            {\n                number: 6,\n                difficulty: \"intermediate\",\n                question: \"You have a class with both a parameterized constructor and need a default constructor. How do you implement this?\",\n                answer: \"Create multiple constructors with different parameter lists (constructor overloading)\",\n                explanation: \"You can have multiple constructors as long as they have different parameter signatures. This allows flexible object creation patterns.\",\n                correctCode: \"public class EmailService {\\n    private String serviceName;\\n    private String defaultTemplate;\\n    private Boolean debugMode;\\n\\n    // Default constructor\\n    public EmailService() {\\n        this('Default Email Service', 'standard_template', false);\\n    }\\n\\n    // Constructor with service name only\\n    public EmailService(String name) {\\n        this(name, 'standard_template', false);\\n    }\\n\\n    // Constructor with name and template\\n    public EmailService(String name, String template) {\\n        this(name, template, false);\\n    }\\n\\n    // Full constructor - all others call this one\\n    public EmailService(String name, String template, Boolean debug) {\\n        this.serviceName = name;\\n        this.defaultTemplate = template;\\n        this.debugMode = debug;\\n\\n        // Common initialization logic in one place\\n        validateInputs();\\n    }\\n\\n    private void validateInputs() {\\n        if (String.isBlank(this.serviceName)) {\\n            this.serviceName = 'Unnamed Service';\\n        }\\n        if (String.isBlank(this.defaultTemplate)) {\\n            this.defaultTemplate = 'basic_template';\\n        }\\n    }\\n}\\n\\n// Flexible object creation\\nEmailService service1 = new EmailService();\\nEmailService service2 = new EmailService('Marketing Service');\\nEmailService service3 = new EmailService('Sales Service', 'sales_template');\\nEmailService service4 = new EmailService('Debug Service', 'debug_template', true);\",\n                keyLearning: \"Constructor overloading provides flexible object creation. Use constructor chaining with this() to avoid code duplication.\",\n                examTip: \"Constructor overloading questions test understanding of parameter signatures and initialization patterns.\"\n            },\n            {\n                number: 7,\n                difficulty: \"beginner\",\n                question: \"What happens if you don't define a constructor in your Apex class?\",\n                answer: \"Apex automatically provides a default no-argument constructor\",\n                explanation: \"If you don't write any constructors, Apex creates a default constructor that takes no parameters and does nothing. However, if you create any constructor, the default one is no longer provided.\",\n                correctCode: \"// Class without explicit constructor\\npublic class SimpleClass {\\n    public String name;\\n    public Integer value;\\n\\n    // Apex automatically provides:\\n    // public SimpleClass() { }\\n}\\n\\n// Usage works fine\\nSimpleClass obj1 = new SimpleClass(); // Uses default constructor\\nobj1.name = 'Test';\\n\\n// Class with explicit constructor\\npublic class ExplicitConstructorClass {\\n    public String name;\\n\\n    public ExplicitConstructorClass(String n) {\\n        this.name = n;\\n    }\\n\\n    // Default constructor NO LONGER PROVIDED\\n}\\n\\n// This would cause compilation error:\\n// ExplicitConstructorClass obj2 = new ExplicitConstructorClass(); // ERROR\\n\\n// This works:\\nExplicitConstructorClass obj3 = new ExplicitConstructorClass('Valid');\",\n                keyLearning: \"Default constructor is provided only if you don't write any constructors. Writing one constructor removes the default.\",\n                examTip: \"Constructor questions often test this rule: explicit constructor = no more default constructor.\"\n            },\n            {\n                number: 8,\n                difficulty: \"intermediate\",\n                question: \"How do you properly handle null checks when working with objects in methods?\",\n                answer: \"Use null safety patterns and validation at method entry points\",\n                explanation: \"Always validate object parameters and use safe navigation or explicit null checks to prevent NullPointerExceptions.\",\n                correctCode: \"public class ContactService {\\n\\n    public String getContactDisplayName(Contact con) {\\n        // Guard clause - early return for null\\n        if (con == null) {\\n            return 'Unknown Contact';\\n        }\\n\\n        // Safe string operations\\n        String firstName = String.isBlank(con.FirstName) ? '' : con.FirstName;\\n        String lastName = String.isBlank(con.LastName) ? 'Unknown' : con.LastName;\\n\\n        return firstName + ' ' + lastName;\\n    }\\n\\n    public Boolean isHighValueContact(Contact con) {\\n        // Multiple validations\\n        if (con?.Account == null) {\\n            return false;\\n        }\\n\\n        // Safe navigation with null coalescing\\n        Decimal revenue = con.Account.AnnualRevenue ?? 0;\\n        return revenue > 1000000;\\n    }\\n\\n    public void updateContactPreferences(Contact con, Map<String, Object> prefs) {\\n        // Validate both parameters\\n        if (con == null || prefs == null || prefs.isEmpty()) {\\n            System.debug('Invalid parameters provided');\\n            return;\\n        }\\n\\n        // Safe map access\\n        if (prefs.containsKey('Email_Opt_Out__c')) {\\n            con.Email_Opt_Out__c = Boolean.valueOf(prefs.get('Email_Opt_Out__c'));\\n        }\\n\\n        // Validate before DML\\n        if (con.Id != null) {\\n            update con;\\n        }\\n    }\\n}\",\n                keyLearning: \"Use guard clauses, safe navigation (?.), and null coalescing (??) for robust null handling.\",\n                examTip: \"Null safety questions test defensive programming practices. Always validate inputs early.\"\n            },\n            {\n                number: 9,\n                difficulty: \"advanced\",\n                question: \"You need a utility class with only static methods. What's the best practice for this?\",\n                answer: \"Make the constructor private to prevent instantiation and mark the class as final\",\n                explanation: \"Utility classes shouldn't be instantiated since they only contain static methods. A private constructor prevents object creation.\",\n                correctCode: \"public final class MathUtils {\\n\\n    // Private constructor prevents instantiation\\n    private MathUtils() {\\n        throw new UnsupportedOperationException('Utility class cannot be instantiated');\\n    }\\n\\n    // All methods are static\\n    public static Decimal calculateTax(Decimal amount, Decimal rate) {\\n        if (amount == null || rate == null || amount < 0 || rate < 0) {\\n            throw new IllegalArgumentException('Invalid tax calculation parameters');\\n        }\\n        return amount * (rate / 100);\\n    }\\n\\n    public static Decimal calculateDiscount(Decimal originalPrice, Decimal discountPercent) {\\n        if (originalPrice == null || discountPercent == null) {\\n            return originalPrice;\\n        }\\n\\n        Decimal discount = originalPrice * (discountPercent / 100);\\n        return originalPrice - discount;\\n    }\\n\\n    public static Boolean isWithinRange(Decimal value, Decimal min, Decimal max) {\\n        if (value == null) return false;\\n        return value >= min && value <= max;\\n    }\\n}\\n\\n// Usage - only static method calls\\nDecimal tax = MathUtils.calculateTax(100.00, 8.5);\\nDecimal discounted = MathUtils.calculateDiscount(100.00, 10);\\n\\n// This would cause error:\\n// MathUtils util = new MathUtils(); // COMPILATION ERROR\",\n                keyLearning: \"Utility classes use private constructors and static methods only. Mark as final for clarity.\",\n                examTip: \"Utility class questions test understanding of static-only design patterns and instantiation prevention.\"\n            },\n            {\n                number: 10,\n                difficulty: \"intermediate\",\n                question: \"How do you implement a class that needs to maintain a count of all instances created?\",\n                answer: \"Use a static variable incremented in the constructor\",\n                explanation: \"Static variables are shared across all instances and persist throughout the transaction. Incrementing in the constructor tracks every object creation.\",\n                correctCode: \"public class SessionManager {\\n    // Static counter shared by all instances\\n    private static Integer instanceCount = 0;\\n\\n    // Instance variables\\n    private String sessionId;\\n    private DateTime createdAt;\\n\\n    public SessionManager() {\\n        // Increment counter for every instance created\\n        instanceCount++;\\n\\n        this.sessionId = 'SESSION_' + instanceCount + '_' + System.currentTimeMillis();\\n        this.createdAt = System.now();\\n\\n        System.debug('Created session #' + instanceCount + ': ' + this.sessionId);\\n    }\\n\\n    // Parameterized constructor also increments\\n    public SessionManager(String customId) {\\n        this(); // Call default constructor to increment counter\\n        this.sessionId = customId + '_' + instanceCount;\\n    }\\n\\n    // Static method to access count\\n    public static Integer getTotalInstancesCreated() {\\n        return instanceCount;\\n    }\\n\\n    // Instance method to get this object's number\\n    public String getSessionInfo() {\\n        return 'Session: ' + this.sessionId + ' (Created: ' + this.createdAt + ')';\\n    }\\n}\\n\\n// Demonstration\\nSystem.debug('Initial count: ' + SessionManager.getTotalInstancesCreated()); // 0\\n\\nSessionManager session1 = new SessionManager();\\nSystem.debug('After session1: ' + SessionManager.getTotalInstancesCreated()); // 1\\n\\nSessionManager session2 = new SessionManager('CUSTOM');\\nSystem.debug('After session2: ' + SessionManager.getTotalInstancesCreated()); // 2\\n\\nList<SessionManager> sessions = new List<SessionManager>();\\nfor (Integer i = 0; i < 3; i++) {\\n    sessions.add(new SessionManager());\\n}\\nSystem.debug('Final count: ' + SessionManager.getTotalInstancesCreated()); // 5\",\n                keyLearning: \"Static variables in constructors track global instance counts across all object creation.\",\n                examTip: \"Instance counting questions test understanding of static variable lifecycle and constructor execution.\"\n            },\n            {\n                number: 11,\n                difficulty: \"beginner\",\n                question: \"What's the difference between public, private, and global access modifiers in Apex?\",\n                answer: \"public = accessible within namespace, private = within class only, global = accessible everywhere\",\n                explanation: \"Access modifiers control visibility. Private is most restrictive (class only), public allows access within the same namespace, global allows access from anywhere including managed packages.\",\n                correctCode: \"public class AccessModifierDemo {\\n\\n    // Private - only this class can access\\n    private String internalData = 'secret';\\n\\n    // Public - accessible within same namespace\\n    public String publicData = 'shared';\\n\\n    // Global - accessible from anywhere (use sparingly)\\n    global String globalData = 'universal';\\n\\n    // Private method - internal use only\\n    private void internalProcess() {\\n        System.debug('Internal processing: ' + this.internalData);\\n    }\\n\\n    // Public method - namespace access\\n    public void processData() {\\n        internalProcess(); // Can call private method\\n        System.debug('Processing: ' + this.publicData);\\n    }\\n\\n    // Global method - universal access\\n    global void globalProcess() {\\n        System.debug('Global processing: ' + this.globalData);\\n    }\\n}\\n\\n// In same namespace:\\nAccessModifierDemo demo = new AccessModifierDemo();\\nSystem.debug(demo.publicData);  // Works\\ndemo.processData();             // Works\\n// System.debug(demo.internalData); // COMPILATION ERROR - private\\n\\n// From managed package or other namespace:\\n// Only global members would be accessible\",\n                keyLearning: \"Use private for internal implementation, public for namespace sharing, global only when necessary for external access.\",\n                examTip: \"Access modifier questions test understanding of visibility scope. Global should be used sparingly.\"\n            },\n            {\n                number: 12,\n                difficulty: \"advanced\",\n                question: \"How do you implement a singleton pattern in Apex to ensure only one instance exists?\",\n                answer: \"Use a private constructor, static variable to hold the instance, and static method to get it\",\n                explanation: \"Singleton pattern ensures only one instance exists throughout the transaction. Use static variable to store the single instance and control access through a static method.\",\n                correctCode: \"public class ConfigurationManager {\\n    // Static variable to hold the single instance\\n    private static ConfigurationManager instance;\\n\\n    // Instance variables\\n    private Map<String, String> settings;\\n    private DateTime lastUpdated;\\n\\n    // Private constructor prevents external instantiation\\n    private ConfigurationManager() {\\n        this.settings = new Map<String, String>();\\n        this.lastUpdated = System.now();\\n        loadDefaultSettings();\\n    }\\n\\n    // Static method to get the single instance\\n    public static ConfigurationManager getInstance() {\\n        if (instance == null) {\\n            instance = new ConfigurationManager();\\n        }\\n        return instance;\\n    }\\n\\n    // Business methods\\n    public String getSetting(String key) {\\n        return this.settings.get(key);\\n    }\\n\\n    public void setSetting(String key, String value) {\\n        this.settings.put(key, value);\\n        this.lastUpdated = System.now();\\n    }\\n\\n    private void loadDefaultSettings() {\\n        this.settings.put('debug_mode', 'false');\\n        this.settings.put('timeout_seconds', '30');\\n        this.settings.put('max_records', '200');\\n    }\\n\\n    public Integer getSettingsCount() {\\n        return this.settings.size();\\n    }\\n}\\n\\n// Usage - always returns same instance\\nConfigurationManager config1 = ConfigurationManager.getInstance();\\nConfigurationManager config2 = ConfigurationManager.getInstance();\\n\\nconfig1.setSetting('debug_mode', 'true');\\nSystem.debug(config2.getSetting('debug_mode')); // 'true' - same instance\\n\\nSystem.debug(config1 === config2); // true - exact same object\\n\\n// This would cause error:\\n// ConfigurationManager config3 = new ConfigurationManager(); // ERROR\",\n                keyLearning: \"Singleton pattern uses private constructor and static getInstance() method to ensure single instance per transaction.\",\n                examTip: \"Singleton questions test understanding of instance control and static variable usage for shared state.\"\n            },\n            {\n                number: 13,\n                difficulty: \"intermediate\",\n                question: \"Your class needs to work with different types of Salesforce objects. How do you make it generic?\",\n                answer: \"Use SObject as parameter type and getSObjectType() for type-specific operations\",\n                explanation: \"SObject is the base class for all Salesforce objects. Using SObject parameters makes your class work with any standard or custom object.\",\n                correctCode: \"public class GenericRecordProcessor {\\n\\n    public void processRecords(List<SObject> records) {\\n        if (records == null || records.isEmpty()) {\\n            return;\\n        }\\n\\n        // Get object type for type-specific logic\\n        String objectType = records[0].getSObjectType().getDescribe().getName();\\n        System.debug('Processing ' + records.size() + ' ' + objectType + ' records');\\n\\n        for (SObject record : records) {\\n            processIndividualRecord(record);\\n        }\\n    }\\n\\n    private void processIndividualRecord(SObject record) {\\n        String objectName = record.getSObjectType().getDescribe().getName();\\n\\n        // Type-specific processing\\n        if (objectName == 'Account') {\\n            processAccount((Account)record);\\n        } else if (objectName == 'Contact') {\\n            processContact((Contact)record);\\n        } else if (objectName == 'Opportunity') {\\n            processOpportunity((Opportunity)record);\\n        } else {\\n            processGenericRecord(record);\\n        }\\n    }\\n\\n    private void processAccount(Account acc) {\\n        System.debug('Processing Account: ' + acc.Name);\\n        // Account-specific logic\\n    }\\n\\n    private void processContact(Contact con) {\\n        System.debug('Processing Contact: ' + con.Name);\\n        // Contact-specific logic\\n    }\\n\\n    private void processOpportunity(Opportunity opp) {\\n        System.debug('Processing Opportunity: ' + opp.Name);\\n        // Opportunity-specific logic\\n    }\\n\\n    private void processGenericRecord(SObject record) {\\n        System.debug('Processing generic record: ' + record.Id);\\n        // Generic processing for any object type\\n    }\\n}\\n\\n// Usage with different object types\\nGenericRecordProcessor processor = new GenericRecordProcessor();\\n\\nList<Account> accounts = [SELECT Id, Name FROM Account LIMIT 5];\\nprocessor.processRecords(accounts);\\n\\nList<Contact> contacts = [SELECT Id, Name FROM Contact LIMIT 5];\\nprocessor.processRecords(contacts);\",\n                keyLearning: \"Use SObject for generic programming. Use getSObjectType() and casting for type-specific operations.\",\n                examTip: \"Generic programming questions test understanding of SObject hierarchy and type checking patterns.\"\n            },\n            {\n                number: 14,\n                difficulty: \"advanced\",\n                question: \"How do you implement a factory pattern to create different types of objects based on input?\",\n                answer: \"Use a static factory method that returns different implementations based on parameters\",\n                explanation: \"Factory pattern centralizes object creation logic. Use a static method that takes parameters and returns the appropriate object type, often using inheritance or interfaces.\",\n                correctCode: \"// Base interface for all notification types\\npublic interface NotificationService {\\n    void sendNotification(String message, String recipient);\\n    Boolean isAvailable();\\n}\\n\\n// Email implementation\\npublic class EmailNotificationService implements NotificationService {\\n    public void sendNotification(String message, String recipient) {\\n        System.debug('Sending email to ' + recipient + ': ' + message);\\n        // Email-specific logic\\n    }\\n\\n    public Boolean isAvailable() {\\n        return true; // Email always available\\n    }\\n}\\n\\n// SMS implementation\\npublic class SMSNotificationService implements NotificationService {\\n    public void sendNotification(String message, String recipient) {\\n        System.debug('Sending SMS to ' + recipient + ': ' + message);\\n        // SMS-specific logic\\n    }\\n\\n    public Boolean isAvailable() {\\n        // Check SMS service availability\\n        return System.now().hour() >= 8 && System.now().hour() <= 22;\\n    }\\n}\\n\\n// Slack implementation\\npublic class SlackNotificationService implements NotificationService {\\n    public void sendNotification(String message, String recipient) {\\n        System.debug('Sending Slack message to ' + recipient + ': ' + message);\\n        // Slack-specific logic\\n    }\\n\\n    public Boolean isAvailable() {\\n        return true; // Slack always available\\n    }\\n}\\n\\n// Factory class\\npublic class NotificationFactory {\\n\\n    // Factory method - creates appropriate notification service\\n    public static NotificationService createNotificationService(String type) {\\n        if (String.isBlank(type)) {\\n            throw new IllegalArgumentException('Notification type cannot be blank');\\n        }\\n\\n        switch on type.toLowerCase() {\\n            when 'email' {\\n                return new EmailNotificationService();\\n            }\\n            when 'sms' {\\n                return new SMSNotificationService();\\n            }\\n            when 'slack' {\\n                return new SlackNotificationService();\\n            }\\n            when else {\\n                throw new UnsupportedOperationException('Unknown notification type: ' + type);\\n            }\\n        }\\n    }\\n\\n    // Convenience method with fallback logic\\n    public static NotificationService createAvailableService(String preferredType) {\\n        try {\\n            NotificationService service = createNotificationService(preferredType);\\n            if (service.isAvailable()) {\\n                return service;\\n            }\\n        } catch (Exception e) {\\n            System.debug('Preferred service unavailable: ' + e.getMessage());\\n        }\\n\\n        // Fallback to email\\n        return new EmailNotificationService();\\n    }\\n}\\n\\n// Usage\\nNotificationService emailService = NotificationFactory.createNotificationService('email');\\nemailService.sendNotification('Welcome!', 'user@example.com');\\n\\nNotificationService smsService = NotificationFactory.createNotificationService('sms');\\nif (smsService.isAvailable()) {\\n    smsService.sendNotification('Alert!', '+1234567890');\\n}\\n\\n// With automatic fallback\\nNotificationService service = NotificationFactory.createAvailableService('sms');\\nservice.sendNotification('Important message', 'recipient');\",\n                keyLearning: \"Factory pattern centralizes object creation. Use interfaces for consistent behavior across different implementations.\",\n                examTip: \"Factory pattern questions test understanding of object creation strategies and polymorphism.\"\n            },\n            {\n                number: 15,\n                difficulty: \"beginner\",\n                question: \"What's the purpose of the 'this' keyword in Apex?\",\n                answer: \"Refers to the current instance of the class, used to differentiate between instance variables and parameters\",\n                explanation: \"'this' explicitly refers to the current object. It's useful when parameter names match instance variable names or when you want to be explicit about accessing instance members.\",\n                correctCode: \"public class Employee {\\n    private String name;\\n    private String department;\\n    private Integer salary;\\n\\n    // Constructor with parameter names matching instance variables\\n    public Employee(String name, String department, Integer salary) {\\n        // Without 'this', you'd assign parameter to itself\\n        this.name = name;           // this.name = instance variable\\n        this.department = department; // name = parameter\\n        this.salary = salary;\\n    }\\n\\n    // Method showing different uses of 'this'\\n    public void updateEmployee(String name, String department) {\\n        // Explicit reference to instance variables\\n        this.name = name;\\n        this.department = department;\\n\\n        // Calling another method on this object\\n        this.validateEmployee();\\n\\n        // Pass current object to another method\\n        EmployeeValidator.validate(this);\\n    }\\n\\n    private void validateEmployee() {\\n        // 'this' is optional when no naming conflicts\\n        if (String.isBlank(name)) { // Could write this.name\\n            throw new IllegalArgumentException('Employee name cannot be blank');\\n        }\\n    }\\n\\n    // Return current object for method chaining\\n    public Employee setSalary(Integer newSalary) {\\n        this.salary = newSalary;\\n        return this; // Return current object\\n    }\\n\\n    public Employee setDepartment(String newDepartment) {\\n        this.department = newDepartment;\\n        return this;\\n    }\\n}\\n\\n// Method chaining example\\nEmployee emp = new Employee('John Doe', 'Sales', 50000);\\nemp.setSalary(55000).setDepartment('Marketing');\",\n                keyLearning: \"Use 'this' to resolve naming conflicts and for explicit instance member access. Also enables method chaining.\",\n                examTip: \"'this' keyword questions test understanding of object reference and parameter vs instance variable disambiguation.\"\n            },\n            {\n                number: 16,\n                difficulty: \"intermediate\",\n                question: \"How do you properly implement a class that handles exceptions and error logging?\",\n                answer: \"Use try-catch blocks, custom exceptions, and proper logging patterns with different error levels\",\n                explanation: \"Good error handling includes specific exception types, proper logging, and graceful failure modes. Always log enough information for debugging without exposing sensitive data.\",\n                correctCode: \"public class CustomerDataService {\\n\\n    // Custom exception for business logic errors\\n    public class CustomerDataException extends Exception {}\\n\\n    public Boolean processCustomerData(List<Customer__c> customers) {\\n        if (customers == null || customers.isEmpty()) {\\n            System.debug(LoggingLevel.WARN, 'No customers provided for processing');\\n            return false;\\n        }\\n\\n        Integer successCount = 0;\\n        Integer errorCount = 0;\\n\\n        for (Customer__c customer : customers) {\\n            try {\\n                validateCustomer(customer);\\n                processIndividualCustomer(customer);\\n                successCount++;\\n\\n            } catch (CustomerDataException e) {\\n                errorCount++;\\n                System.debug(LoggingLevel.ERROR, 'Business logic error for customer ' +\\n                    customer.Id + ': ' + e.getMessage());\\n\\n            } catch (DmlException e) {\\n                errorCount++;\\n                System.debug(LoggingLevel.ERROR, 'Database error for customer ' +\\n                    customer.Id + ': ' + e.getDmlMessage(0));\\n\\n            } catch (Exception e) {\\n                errorCount++;\\n                System.debug(LoggingLevel.ERROR, 'Unexpected error for customer ' +\\n                    customer.Id + ': ' + e.getMessage() + ' at line ' + e.getLineNumber());\\n            }\\n        }\\n\\n        System.debug(LoggingLevel.INFO, 'Processing complete. Success: ' +\\n            successCount + ', Errors: ' + errorCount);\\n\\n        return errorCount == 0;\\n    }\\n\\n    private void validateCustomer(Customer__c customer) {\\n        if (customer == null) {\\n            throw new CustomerDataException('Customer record is null');\\n        }\\n\\n        if (String.isBlank(customer.Name)) {\\n            throw new CustomerDataException('Customer name is required');\\n        }\\n\\n        if (String.isBlank(customer.Email__c) || !customer.Email__c.contains('@')) {\\n            throw new CustomerDataException('Valid email is required');\\n        }\\n    }\\n\\n    private void processIndividualCustomer(Customer__c customer) {\\n        try {\\n            // Simulate processing\\n            customer.Last_Processed__c = System.now();\\n            customer.Status__c = 'Processed';\\n\\n            update customer;\\n\\n        } catch (DmlException e) {\\n            System.debug(LoggingLevel.ERROR, 'Failed to update customer: ' + e.getMessage());\\n            throw e; // Re-throw for caller to handle\\n        }\\n    }\\n\\n    // Safe method that never throws exceptions\\n    public CustomerProcessingResult safePprocessCustomers(List<Customer__c> customers) {\\n        CustomerProcessingResult result = new CustomerProcessingResult();\\n\\n        try {\\n            Boolean success = processCustomerData(customers);\\n            result.success = success;\\n            result.message = success ? 'All customers processed' : 'Some errors occurred';\\n\\n        } catch (Exception e) {\\n            result.success = false;\\n            result.message = 'Processing failed: ' + e.getMessage();\\n            result.errorDetails = e.getStackTraceString();\\n        }\\n\\n        return result;\\n    }\\n\\n    // Result wrapper class\\n    public class CustomerProcessingResult {\\n        public Boolean success;\\n        public String message;\\n        public String errorDetails;\\n    }\\n}\",\n                keyLearning: \"Use specific exception types, proper logging levels, and safe wrapper methods for robust error handling.\",\n                examTip: \"Exception handling questions test understanding of try-catch patterns, custom exceptions, and error recovery strategies.\"\n            },\n            {\n                number: 17,\n                difficulty: \"advanced\",\n                question: \"How do you implement a class that can be used in both synchronous and asynchronous contexts?\",\n                answer: \"Design with context awareness and use appropriate patterns for governor limits and state management\",\n                explanation: \"Classes used in async contexts need to handle different governor limits, potential serialization requirements, and state management differently than synchronous contexts.\",\n                correctCode: \"public class DataProcessor {\\n\\n    // Context-aware processing\\n    public enum ProcessingContext {\\n        SYNCHRONOUS,\\n        FUTURE,\\n        BATCH,\\n        QUEUEABLE\\n    }\\n\\n    private ProcessingContext context;\\n    private Integer batchSize;\\n\\n    // Constructor that determines context\\n    public DataProcessor() {\\n        this.context = determineContext();\\n        this.batchSize = getBatchSizeForContext();\\n    }\\n\\n    public DataProcessor(ProcessingContext explicitContext) {\\n        this.context = explicitContext;\\n        this.batchSize = getBatchSizeForContext();\\n    }\\n\\n    // Main processing method - context aware\\n    public ProcessingResult processRecords(List<SObject> records) {\\n        ProcessingResult result = new ProcessingResult();\\n        result.context = this.context;\\n        result.startTime = System.now();\\n\\n        try {\\n            switch on this.context {\\n                when SYNCHRONOUS {\\n                    result = processSynchronously(records);\\n                }\\n                when FUTURE {\\n                    result = processForFuture(records);\\n                }\\n                when BATCH {\\n                    result = processForBatch(records);\\n                }\\n                when QUEUEABLE {\\n                    result = processForQueueable(records);\\n                }\\n            }\\n\\n        } catch (Exception e) {\\n            result.success = false;\\n            result.errorMessage = e.getMessage();\\n        }\\n\\n        result.endTime = System.now();\\n        return result;\\n    }\\n\\n    // Synchronous processing - stricter limits\\n    private ProcessingResult processSynchronously(List<SObject> records) {\\n        ProcessingResult result = new ProcessingResult();\\n\\n        // Limit records to avoid timeouts\\n        List<SObject> limitedRecords = records.size() > 100 ?\\n            new List<SObject>(records).subList(0, 100) : records;\\n\\n        result.recordsProcessed = processRecordsBatch(limitedRecords);\\n        result.success = true;\\n\\n        return result;\\n    }\\n\\n    // Future method processing - higher limits\\n    private ProcessingResult processForFuture(List<SObject> records) {\\n        ProcessingResult result = new ProcessingResult();\\n\\n        // Can handle more records\\n        result.recordsProcessed = processRecordsBatch(records);\\n        result.success = true;\\n\\n        return result;\\n    }\\n\\n    // Batch processing - highest limits\\n    private ProcessingResult processForBatch(List<SObject> records) {\\n        ProcessingResult result = new ProcessingResult();\\n\\n        // Process in optimal batch sizes\\n        Integer processed = 0;\\n        for (Integer i = 0; i < records.size(); i += this.batchSize) {\\n            Integer endIndex = Math.min(i + this.batchSize, records.size());\\n            List<SObject> batch = records.subList(i, endIndex);\\n            processed += processRecordsBatch(batch);\\n        }\\n\\n        result.recordsProcessed = processed;\\n        result.success = true;\\n\\n        return result;\\n    }\\n\\n    // Queueable processing - chainable\\n    private ProcessingResult processForQueueable(List<SObject> records) {\\n        ProcessingResult result = new ProcessingResult();\\n\\n        result.recordsProcessed = processRecordsBatch(records);\\n        result.success = true;\\n        result.canChain = records.size() > 1000; // Indicate if chaining needed\\n\\n        return result;\\n    }\\n\\n    // Core processing logic\\n    private Integer processRecordsBatch(List<SObject> records) {\\n        // Actual processing logic here\\n        for (SObject record : records) {\\n            // Process individual record\\n        }\\n        return records.size();\\n    }\\n\\n    // Context detection\\n    private ProcessingContext determineContext() {\\n        if (System.isFuture()) {\\n            return ProcessingContext.FUTURE;\\n        } else if (System.isBatch()) {\\n            return ProcessingContext.BATCH;\\n        } else if (System.isQueueable()) {\\n            return ProcessingContext.QUEUEABLE;\\n        } else {\\n            return ProcessingContext.SYNCHRONOUS;\\n        }\\n    }\\n\\n    // Context-appropriate batch sizes\\n    private Integer getBatchSizeForContext() {\\n        switch on this.context {\\n            when SYNCHRONOUS { return 50; }\\n            when FUTURE { return 100; }\\n            when BATCH { return 200; }\\n            when QUEUEABLE { return 150; }\\n            when else { return 50; }\\n        }\\n    }\\n\\n    // Result class\\n    public class ProcessingResult {\\n        public Boolean success;\\n        public String errorMessage;\\n        public Integer recordsProcessed;\\n        public ProcessingContext context;\\n        public DateTime startTime;\\n        public DateTime endTime;\\n        public Boolean canChain;\\n    }\\n}\\n\\n// Usage in different contexts\\nDataProcessor processor = new DataProcessor(); // Auto-detects context\\nProcessingResult result = processor.processRecords(myRecords);\",\n                keyLearning: \"Context-aware classes adapt behavior based on execution environment. Use different strategies for different governor limit contexts.\",\n                examTip: \"Async-aware design questions test understanding of governor limit differences and context detection patterns.\"\n            },\n            {\n                number: 18,\n                difficulty: \"intermediate\",\n                question: \"How do you implement proper equality and comparison for custom objects?\",\n                answer: \"Override equals() and hashCode() methods, implement Comparable interface for sorting\",\n                explanation: \"Custom equality allows objects to be properly compared and used in Sets/Maps. Proper hashCode ensures correct behavior in collections.\",\n                correctCode: \"public class Product implements Comparable {\\n    public String name;\\n    public String sku;\\n    public Decimal price;\\n    public String category;\\n\\n    public Product(String name, String sku, Decimal price, String category) {\\n        this.name = name;\\n        this.sku = sku;\\n        this.price = price;\\n        this.category = category;\\n    }\\n\\n    // Override equals for proper object comparison\\n    public Boolean equals(Object obj) {\\n        if (this === obj) return true; // Same reference\\n        if (obj == null) return false;\\n        if (!(obj instanceof Product)) return false;\\n\\n        Product other = (Product) obj;\\n\\n        // Products are equal if SKU matches (business rule)\\n        return this.sku != null && this.sku.equals(other.sku);\\n    }\\n\\n    // Must override hashCode when overriding equals\\n    public Integer hashCode() {\\n        return this.sku != null ? this.sku.hashCode() : 0;\\n    }\\n\\n    // Implement Comparable for sorting\\n    public Integer compareTo(Object obj) {\\n        if (!(obj instanceof Product)) {\\n            throw new ClassCastException('Cannot compare Product to ' + obj);\\n        }\\n\\n        Product other = (Product) obj;\\n\\n        // Primary sort: category\\n        Integer categoryComparison = compareStrings(this.category, other.category);\\n        if (categoryComparison != 0) {\\n            return categoryComparison;\\n        }\\n\\n        // Secondary sort: price (descending)\\n        if (this.price != other.price) {\\n            return this.price > other.price ? -1 : 1;\\n        }\\n\\n        // Tertiary sort: name\\n        return compareStrings(this.name, other.name);\\n    }\\n\\n    // Helper method for string comparison\\n    private Integer compareStrings(String str1, String str2) {\\n        if (str1 == null && str2 == null) return 0;\\n        if (str1 == null) return 1;\\n        if (str2 == null) return -1;\\n        return str1.compareTo(str2);\\n    }\\n\\n    // toString for debugging\\n    public override String toString() {\\n        return 'Product{name=' + name + ', sku=' + sku + ', price=' + price + '}';\\n    }\\n}\\n\\n// Usage examples\\nProduct product1 = new Product('Widget A', 'WGT-001', 19.99, 'Electronics');\\nProduct product2 = new Product('Widget A Deluxe', 'WGT-001', 29.99, 'Electronics');\\nProduct product3 = new Product('Gadget B', 'GDT-002', 15.50, 'Electronics');\\n\\n// Equality testing\\nSystem.debug(product1.equals(product2)); // true - same SKU\\nSystem.debug(product1.equals(product3)); // false - different SKU\\n\\n// Set usage - duplicates removed based on equals/hashCode\\nSet<Product> productSet = new Set<Product>{product1, product2, product3};\\nSystem.debug('Set size: ' + productSet.size()); // 2 (product1 and product2 are equal)\\n\\n// List sorting\\nList<Product> products = new List<Product>{product3, product1, product2};\\nproducts.sort(); // Uses compareTo method\\nfor (Product p : products) {\\n    System.debug(p.toString());\\n}\",\n                keyLearning: \"Override equals() and hashCode() together. Implement Comparable for custom sorting. Use business logic for equality.\",\n                examTip: \"Object comparison questions test understanding of equals/hashCode contract and sorting implementation.\"\n            },\n            {\n                number: 19,\n                difficulty: \"advanced\",\n                question: \"Design a class that implements the observer pattern for real-time notifications.\",\n                answer: \"Use interfaces for observers, maintain a list of observers, and notify them when events occur\",\n                explanation: \"Observer pattern allows objects to be notified of changes without tight coupling. Use interfaces for flexibility and lists to manage multiple observers.\",\n                correctCode: \"// Observer interface\\npublic interface InventoryObserver {\\n    void onInventoryChanged(String productSku, Integer oldQuantity, Integer newQuantity);\\n    void onLowStock(String productSku, Integer currentQuantity, Integer threshold);\\n    void onOutOfStock(String productSku);\\n}\\n\\n// Concrete observer implementations\\npublic class EmailNotificationObserver implements InventoryObserver {\\n    private String emailAddress;\\n\\n    public EmailNotificationObserver(String email) {\\n        this.emailAddress = email;\\n    }\\n\\n    public void onInventoryChanged(String productSku, Integer oldQuantity, Integer newQuantity) {\\n        System.debug('Email: Inventory changed for ' + productSku +\\n            ' from ' + oldQuantity + ' to ' + newQuantity);\\n    }\\n\\n    public void onLowStock(String productSku, Integer currentQuantity, Integer threshold) {\\n        System.debug('Email Alert: Low stock for ' + productSku +\\n            ' (' + currentQuantity + ' remaining, threshold: ' + threshold + ')');\\n    }\\n\\n    public void onOutOfStock(String productSku) {\\n        System.debug('URGENT Email: ' + productSku + ' is out of stock!');\\n    }\\n}\\n\\npublic class SlackNotificationObserver implements InventoryObserver {\\n    private String channel;\\n\\n    public SlackNotificationObserver(String slackChannel) {\\n        this.channel = slackChannel;\\n    }\\n\\n    public void onInventoryChanged(String productSku, Integer oldQuantity, Integer newQuantity) {\\n        // Only notify on significant changes\\n        if (Math.abs(newQuantity - oldQuantity) >= 10) {\\n            System.debug('Slack ' + channel + ': Significant inventory change for ' + productSku);\\n        }\\n    }\\n\\n    public void onLowStock(String productSku, Integer currentQuantity, Integer threshold) {\\n        System.debug('Slack ' + channel + ': ⚠️ Low stock alert for ' + productSku);\\n    }\\n\\n    public void onOutOfStock(String productSku) {\\n        System.debug('Slack ' + channel + ': \\uD83D\\uDEA8 OUT OF STOCK: ' + productSku);\\n    }\\n}\\n\\n// Subject class that manages observers\\npublic class InventoryManager {\\n    private Map<String, Integer> inventory;\\n    private Map<String, Integer> lowStockThresholds;\\n    private List<InventoryObserver> observers;\\n\\n    public InventoryManager() {\\n        this.inventory = new Map<String, Integer>();\\n        this.lowStockThresholds = new Map<String, Integer>();\\n        this.observers = new List<InventoryObserver>();\\n    }\\n\\n    // Observer management\\n    public void addObserver(InventoryObserver observer) {\\n        if (observer != null && !this.observers.contains(observer)) {\\n            this.observers.add(observer);\\n        }\\n    }\\n\\n    public void removeObserver(InventoryObserver observer) {\\n        this.observers.remove(this.observers.indexOf(observer));\\n    }\\n\\n    // Business methods that trigger notifications\\n    public void updateInventory(String productSku, Integer newQuantity) {\\n        Integer oldQuantity = this.inventory.get(productSku);\\n        if (oldQuantity == null) oldQuantity = 0;\\n\\n        this.inventory.put(productSku, newQuantity);\\n\\n        // Notify all observers\\n        notifyInventoryChanged(productSku, oldQuantity, newQuantity);\\n\\n        // Check for stock levels\\n        checkStockLevels(productSku, newQuantity);\\n    }\\n\\n    public void setLowStockThreshold(String productSku, Integer threshold) {\\n        this.lowStockThresholds.put(productSku, threshold);\\n    }\\n\\n    // Notification methods\\n    private void notifyInventoryChanged(String productSku, Integer oldQuantity, Integer newQuantity) {\\n        for (InventoryObserver observer : this.observers) {\\n            try {\\n                observer.onInventoryChanged(productSku, oldQuantity, newQuantity);\\n            } catch (Exception e) {\\n                System.debug('Error notifying observer: ' + e.getMessage());\\n            }\\n        }\\n    }\\n\\n    private void checkStockLevels(String productSku, Integer currentQuantity) {\\n        if (currentQuantity == 0) {\\n            notifyOutOfStock(productSku);\\n        } else {\\n            Integer threshold = this.lowStockThresholds.get(productSku);\\n            if (threshold != null && currentQuantity <= threshold) {\\n                notifyLowStock(productSku, currentQuantity, threshold);\\n            }\\n        }\\n    }\\n\\n    private void notifyLowStock(String productSku, Integer currentQuantity, Integer threshold) {\\n        for (InventoryObserver observer : this.observers) {\\n            try {\\n                observer.onLowStock(productSku, currentQuantity, threshold);\\n            } catch (Exception e) {\\n                System.debug('Error notifying observer: ' + e.getMessage());\\n            }\\n        }\\n    }\\n\\n    private void notifyOutOfStock(String productSku) {\\n        for (InventoryObserver observer : this.observers) {\\n            try {\\n                observer.onOutOfStock(productSku);\\n            } catch (Exception e) {\\n                System.debug('Error notifying observer: ' + e.getMessage());\\n            }\\n        }\\n    }\\n\\n    // Utility methods\\n    public Integer getCurrentInventory(String productSku) {\\n        return this.inventory.get(productSku);\\n    }\\n}\\n\\n// Usage example\\nInventoryManager inventory = new InventoryManager();\\n\\n// Add observers\\ninventory.addObserver(new EmailNotificationObserver('manager@company.com'));\\ninventory.addObserver(new SlackNotificationObserver('#inventory-alerts'));\\n\\n// Set thresholds and update inventory\\ninventory.setLowStockThreshold('WIDGET-001', 10);\\ninventory.updateInventory('WIDGET-001', 100); // Normal stock\\ninventory.updateInventory('WIDGET-001', 8);   // Low stock alert\\ninventory.updateInventory('WIDGET-001', 0);   // Out of stock alert\",\n                keyLearning: \"Observer pattern uses interfaces for loose coupling and list management for multiple observers. Handle observer exceptions gracefully.\",\n                examTip: \"Observer pattern questions test understanding of design patterns, interfaces, and event-driven programming.\"\n            },\n            {\n                number: 20,\n                difficulty: \"expert\",\n                question: \"Design a comprehensive class hierarchy for a Salesforce integration that handles multiple data sources with different authentication and processing requirements.\",\n                answer: \"Use abstract base class with template method pattern, interfaces for contracts, and strategy pattern for authentication\",\n                explanation: \"Complex integration scenarios require flexible architecture using multiple design patterns. Abstract classes provide common structure while interfaces ensure contracts are met.\",\n                correctCode: \"// Base interface for all data sources\\npublic interface DataSource {\\n    Boolean isConnected();\\n    List<SObject> fetchData(Map<String, Object> parameters);\\n    void disconnect();\\n}\\n\\n// Authentication strategy interface\\npublic interface AuthenticationStrategy {\\n    Boolean authenticate(Map<String, String> credentials);\\n    String getAuthToken();\\n    Boolean isTokenValid();\\n}\\n\\n// OAuth implementation\\npublic class OAuthStrategy implements AuthenticationStrategy {\\n    private String accessToken;\\n    private DateTime tokenExpiry;\\n\\n    public Boolean authenticate(Map<String, String> credentials) {\\n        // OAuth flow implementation\\n        this.accessToken = 'oauth_token_' + System.currentTimeMillis();\\n        this.tokenExpiry = System.now().addHours(1);\\n        return true;\\n    }\\n\\n    public String getAuthToken() {\\n        return this.accessToken;\\n    }\\n\\n    public Boolean isTokenValid() {\\n        return this.accessToken != null && System.now() < this.tokenExpiry;\\n    }\\n}\\n\\n// API Key implementation\\npublic class ApiKeyStrategy implements AuthenticationStrategy {\\n    private String apiKey;\\n\\n    public Boolean authenticate(Map<String, String> credentials) {\\n        this.apiKey = credentials.get('api_key');\\n        return String.isNotBlank(this.apiKey);\\n    }\\n\\n    public String getAuthToken() {\\n        return this.apiKey;\\n    }\\n\\n    public Boolean isTokenValid() {\\n        return String.isNotBlank(this.apiKey);\\n    }\\n}\\n\\n// Abstract base class - Template Method Pattern\\npublic abstract class AbstractDataSource implements DataSource {\\n    protected AuthenticationStrategy authStrategy;\\n    protected String sourceName;\\n    protected Boolean connected = false;\\n    protected Map<String, String> configuration;\\n\\n    public AbstractDataSource(String name, AuthenticationStrategy auth) {\\n        this.sourceName = name;\\n        this.authStrategy = auth;\\n        this.configuration = new Map<String, String>();\\n    }\\n\\n    // Template method - defines the algorithm structure\\n    public final List<SObject> fetchData(Map<String, Object> parameters) {\\n        List<SObject> results = new List<SObject>();\\n\\n        try {\\n            // Step 1: Validate connection\\n            if (!isConnected()) {\\n                connect();\\n            }\\n\\n            // Step 2: Validate authentication\\n            if (!this.authStrategy.isTokenValid()) {\\n                reAuthenticate();\\n            }\\n\\n            // Step 3: Validate parameters\\n            validateParameters(parameters);\\n\\n            // Step 4: Transform parameters (hook method)\\n            Map<String, Object> transformedParams = transformParameters(parameters);\\n\\n            // Step 5: Fetch data (abstract method - subclasses implement)\\n            results = doFetchData(transformedParams);\\n\\n            // Step 6: Transform results (hook method)\\n            results = transformResults(results);\\n\\n            // Step 7: Log success\\n            logOperation('SUCCESS', results.size() + ' records fetched');\\n\\n        } catch (Exception e) {\\n            logOperation('ERROR', 'Fetch failed: ' + e.getMessage());\\n            handleError(e);\\n            throw e;\\n        }\\n\\n        return results;\\n    }\\n\\n    // Abstract methods - subclasses must implement\\n    protected abstract List<SObject> doFetchData(Map<String, Object> parameters);\\n    protected abstract void validateParameters(Map<String, Object> parameters);\\n\\n    // Hook methods - subclasses can override\\n    protected virtual Map<String, Object> transformParameters(Map<String, Object> parameters) {\\n        return parameters; // Default: no transformation\\n    }\\n\\n    protected virtual List<SObject> transformResults(List<SObject> results) {\\n        return results; // Default: no transformation\\n    }\\n\\n    protected virtual void handleError(Exception e) {\\n        System.debug(LoggingLevel.ERROR, 'Error in ' + this.sourceName + ': ' + e.getMessage());\\n    }\\n\\n    // Common methods\\n    public Boolean isConnected() {\\n        return this.connected;\\n    }\\n\\n    private void connect() {\\n        this.connected = true;\\n        logOperation('INFO', 'Connected to ' + this.sourceName);\\n    }\\n\\n    public void disconnect() {\\n        this.connected = false;\\n        logOperation('INFO', 'Disconnected from ' + this.sourceName);\\n    }\\n\\n    private void reAuthenticate() {\\n        Map<String, String> credentials = getStoredCredentials();\\n        if (!this.authStrategy.authenticate(credentials)) {\\n            throw new AuthenticationException('Re-authentication failed for ' + this.sourceName);\\n        }\\n    }\\n\\n    protected virtual Map<String, String> getStoredCredentials() {\\n        // Default implementation - override in subclasses\\n        return new Map<String, String>();\\n    }\\n\\n    private void logOperation(String level, String message) {\\n        System.debug('[' + this.sourceName + '] ' + level + ': ' + message);\\n    }\\n\\n    // Custom exception\\n    public class AuthenticationException extends Exception {}\\n}\\n\\n// Concrete implementation for REST API\\npublic class RestApiDataSource extends AbstractDataSource {\\n    private String endpoint;\\n\\n    public RestApiDataSource(String name, String apiEndpoint, AuthenticationStrategy auth) {\\n        super(name, auth);\\n        this.endpoint = apiEndpoint;\\n    }\\n\\n    protected override List<SObject> doFetchData(Map<String, Object> parameters) {\\n        // REST API specific implementation\\n        HttpRequest req = new HttpRequest();\\n        req.setEndpoint(this.endpoint);\\n        req.setMethod('GET');\\n        req.setHeader('Authorization', 'Bearer ' + this.authStrategy.getAuthToken());\\n\\n        // Add query parameters\\n        String queryParams = buildQueryString(parameters);\\n        if (String.isNotBlank(queryParams)) {\\n            req.setEndpoint(this.endpoint + '?' + queryParams);\\n        }\\n\\n        Http http = new Http();\\n        HttpResponse response = http.send(req);\\n\\n        if (response.getStatusCode() == 200) {\\n            return parseJsonResponse(response.getBody());\\n        } else {\\n            throw new CalloutException('API call failed: ' + response.getStatus());\\n        }\\n    }\\n\\n    protected override void validateParameters(Map<String, Object> parameters) {\\n        if (parameters == null || parameters.isEmpty()) {\\n            throw new IllegalArgumentException('Parameters cannot be null or empty');\\n        }\\n\\n        // REST API specific validations\\n        if (!parameters.containsKey('limit')) {\\n            parameters.put('limit', 100); // Default limit\\n        }\\n    }\\n\\n    protected override Map<String, Object> transformParameters(Map<String, Object> parameters) {\\n        Map<String, Object> transformed = new Map<String, Object>(parameters);\\n\\n        // Convert Salesforce field names to API field names\\n        if (transformed.containsKey('LastModifiedDate')) {\\n            transformed.put('updated_after', transformed.remove('LastModifiedDate'));\\n        }\\n\\n        return transformed;\\n    }\\n\\n    private String buildQueryString(Map<String, Object> parameters) {\\n        List<String> parts = new List<String>();\\n        for (String key : parameters.keySet()) {\\n            parts.add(key + '=' + String.valueOf(parameters.get(key)));\\n        }\\n        return String.join(parts, '&');\\n    }\\n\\n    private List<SObject> parseJsonResponse(String jsonBody) {\\n        // JSON parsing logic here\\n        List<SObject> results = new List<SObject>();\\n        // ... parsing implementation\\n        return results;\\n    }\\n}\\n\\n// Concrete implementation for Database\\npublic class DatabaseDataSource extends AbstractDataSource {\\n    private String connectionString;\\n\\n    public DatabaseDataSource(String name, String connString, AuthenticationStrategy auth) {\\n        super(name, auth);\\n        this.connectionString = connString;\\n    }\\n\\n    protected override List<SObject> doFetchData(Map<String, Object> parameters) {\\n        // Database specific implementation\\n        String query = buildSqlQuery(parameters);\\n\\n        // Execute query (pseudo-code - actual implementation would vary)\\n        List<SObject> results = executeQuery(query);\\n\\n        return results;\\n    }\\n\\n    protected override void validateParameters(Map<String, Object> parameters) {\\n        // Database specific validations\\n        if (!parameters.containsKey('table_name')) {\\n            throw new IllegalArgumentException('Table name is required');\\n        }\\n    }\\n\\n    private String buildSqlQuery(Map<String, Object> parameters) {\\n        String tableName = String.valueOf(parameters.get('table_name'));\\n        String whereClause = String.valueOf(parameters.get('where_clause'));\\n\\n        String query = 'SELECT * FROM ' + tableName;\\n        if (String.isNotBlank(whereClause)) {\\n            query += ' WHERE ' + whereClause;\\n        }\\n\\n        return query;\\n    }\\n\\n    private List<SObject> executeQuery(String query) {\\n        // Database execution logic\\n        return new List<SObject>();\\n    }\\n}\\n\\n// Usage example\\npublic class IntegrationService {\\n    private Map<String, DataSource> dataSources;\\n\\n    public IntegrationService() {\\n        this.dataSources = new Map<String, DataSource>();\\n        initializeDataSources();\\n    }\\n\\n    private void initializeDataSources() {\\n        // Create different data sources with appropriate authentication\\n        AuthenticationStrategy oauthStrategy = new OAuthStrategy();\\n        AuthenticationStrategy apiKeyStrategy = new ApiKeyStrategy();\\n\\n        RestApiDataSource restApi = new RestApiDataSource(\\n            'External API',\\n            'https://api.external.com/v1/data',\\n            oauthStrategy\\n        );\\n\\n        DatabaseDataSource database = new DatabaseDataSource(\\n            'Legacy Database',\\n            'jdbc:mysql://localhost:3306/legacy',\\n            apiKeyStrategy\\n        );\\n\\n        this.dataSources.put('api', restApi);\\n        this.dataSources.put('database', database);\\n    }\\n\\n    public List<SObject> fetchFromSource(String sourceName, Map<String, Object> parameters) {\\n        DataSource source = this.dataSources.get(sourceName);\\n        if (source == null) {\\n            throw new IllegalArgumentException('Unknown data source: ' + sourceName);\\n        }\\n\\n        return source.fetchData(parameters);\\n    }\\n}\",\n                keyLearning: \"Complex architectures use multiple patterns: Template Method for structure, Strategy for authentication, Abstract classes for shared behavior.\",\n                examTip: \"Architecture questions test understanding of design patterns, inheritance, interfaces, and separation of concerns.\"\n            }\n        ]\n    },\n    \"soql-and-dml\": {\n        title: \"SOQL and DML\",\n        overview: \"Master Salesforce Object Query Language and database operations. SOQL retrieves records from Salesforce, DML operations modify them.\",\n        codeExamples: [\n            {\n                title: \"Basic SOQL Queries\",\n                code: \"public class QueryDemo {\\n    public void basicQueries() {\\n        // ✅ WHAT: Basic SELECT with specific fields\\n        List<Account> accounts = [\\n            SELECT Id, Name, Type, Industry\\n            FROM Account\\n            WHERE Type = 'Customer'\\n            LIMIT 100\\n        ];\\n\\n        // ✅ WHAT: Query with relationships (lookup)\\n        List<Contact> contacts = [\\n            SELECT Id, Name, Email,\\n                   Account.Name, Account.Industry\\n            FROM Contact\\n            WHERE Account.Type = 'Customer'\\n        ];\\n\\n        // ✅ WHAT: Query with child relationships\\n        List<Account> accountsWithContacts = [\\n            SELECT Id, Name,\\n                   (SELECT Id, Name, Email FROM Contacts)\\n            FROM Account\\n            WHERE Id IN :accountIds\\n        ];\\n    }\\n}\",\n                explanation: \"SOQL syntax is similar to SQL but with Salesforce-specific features like relationship queries. Always specify needed fields explicitly and use LIMIT to prevent governor limit issues.\"\n            }\n        ],\n        practiceQuestions: []\n    },\n    \"triggers-and-automation\": {\n        title: \"Triggers and Automation\",\n        overview: \"Master Apex triggers and automation patterns. Triggers execute automatically when records are inserted, updated, or deleted.\",\n        codeExamples: [\n            {\n                title: \"Trigger Structure\",\n                code: \"trigger AccountTrigger on Account (before insert, before update, after insert, after update) {\\n    // ✅ WHAT: Single trigger handles multiple events\\n    // ✅ WHY: Better organization and predictable execution order\\n\\n    if (Trigger.isBefore) {\\n        if (Trigger.isInsert || Trigger.isUpdate) {\\n            AccountTriggerHandler.validateAccounts(Trigger.new);\\n        }\\n    }\\n\\n    if (Trigger.isAfter) {\\n        if (Trigger.isInsert) {\\n            AccountTriggerHandler.createDefaultContacts(Trigger.new);\\n        }\\n\\n        if (Trigger.isUpdate) {\\n            AccountTriggerHandler.updateRelatedOpportunities(\\n                Trigger.new,\\n                Trigger.oldMap\\n            );\\n        }\\n    }\\n}\",\n                explanation: \"Use a single trigger per object with multiple events. Delegate logic to handler classes for better organization and testability.\"\n            }\n        ],\n        practiceQuestions: []\n    },\n    \"asynchronous-apex\": {\n        title: \"Asynchronous Apex\",\n        overview: \"Master asynchronous processing with Future, Batch, Queueable, and Schedulable Apex for handling large data volumes.\",\n        codeExamples: [\n            {\n                title: \"Future Methods\",\n                code: \"public class AsyncDemo {\\n    // ✅ WHAT: Future method for async processing\\n    @future\\n    public static void processAccountsAsync(Set<Id> accountIds) {\\n        // ✅ WHAT: Query records in the async method\\n        List<Account> accounts = [\\n            SELECT Id, Name, Industry\\n            FROM Account\\n            WHERE Id IN :accountIds\\n        ];\\n\\n        for (Account acc : accounts) {\\n            // Long-running processing\\n            acc.Description = 'Processed async on ' + System.now();\\n        }\\n\\n        update accounts;\\n    }\\n}\",\n                explanation: \"Future methods run asynchronously and must be static. They can only accept primitive types and collections of primitives as parameters.\"\n            }\n        ],\n        practiceQuestions: []\n    },\n    \"testing-and-debugging\": {\n        title: \"Testing and Debugging\",\n        overview: \"Master unit testing, test data creation, and test automation in Apex. Proper testing ensures code quality and prevents regressions.\",\n        codeExamples: [\n            {\n                title: \"Basic Test Structure\",\n                code: \"@IsTest\\npublic class AccountProcessorTest {\\n\\n    @TestSetup\\n    static void createTestData() {\\n        // ✅ WHAT: Test data created once for all test methods\\n        List<Account> testAccounts = new List<Account>();\\n        for (Integer i = 0; i < 10; i++) {\\n            testAccounts.add(new Account(\\n                Name = 'Test Account ' + i,\\n                Type = 'Customer',\\n                Industry = 'Technology'\\n            ));\\n        }\\n        insert testAccounts;\\n    }\\n\\n    @IsTest\\n    static void testAccountProcessing() {\\n        // ✅ WHAT: Query test data\\n        List<Account> accounts = [SELECT Id, Name FROM Account];\\n\\n        Test.startTest();\\n        // ✅ WHAT: Execute code under test\\n        AccountProcessor processor = new AccountProcessor('Test Processor', 20);\\n        processor.processAccounts(accounts);\\n        Test.stopTest();\\n\\n        // ✅ WHAT: Verify results\\n        List<Account> processedAccounts = [\\n            SELECT Id, Last_Processed_Date__c\\n            FROM Account\\n        ];\\n\\n        for (Account acc : processedAccounts) {\\n            System.assertNotEquals(null, acc.Last_Processed_Date__c,\\n                'Account should have processing date');\\n        }\\n    }\\n}\",\n                explanation: \"Use @TestSetup for common test data, Test.startTest()/stopTest() to reset governor limits, and System.assert methods to verify results.\"\n            }\n        ],\n        practiceQuestions: []\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kYXRhL3RvcGljQ29udGVudC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBeUJPLE1BQU1BLGVBQTZDO0lBQ3hELDRCQUE0QjtRQUMxQkMsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkFvQlBDLGFBQWE7WUFDZjtZQUNBO2dCQUNFSixPQUFPO2dCQUNQRyxNQUFPO2dCQWtCUEMsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VKLE9BQU87Z0JBQ1BHLE1BQU87Z0JBcUJQQyxhQUFhO1lBQ2Y7U0FDRDtRQUNEQyxtQkFBbUI7WUFDakI7Z0JBQ0VDLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZMLE1BQU87Z0JBRVBNLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBRWRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQUVkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFNZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBQ2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQUdkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFHZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBU2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQU9kQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFRZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBUWRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQVlkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFvQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQWVkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFjZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBeUJkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFrQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXNCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBaUJkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkEwQ2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXdDZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1NBQ0Q7SUFDSDtJQUVBLHlCQUF5QjtRQUN2QlosT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkE4QlBDLGFBQWE7WUFDZjtZQUNBO2dCQUNFSixPQUFPO2dCQUNQRyxNQUFPO2dCQW1CUEMsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VKLE9BQU87Z0JBQ1BHLE1BQU87Z0JBcUJQQyxhQUFhO1lBQ2Y7U0FDRDtRQUNEQyxtQkFBbUI7WUFDakI7Z0JBQ0VDLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBRWRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQU1kQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkwsTUFBTztnQkFJUE0sUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFLZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBU2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQWVkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFvQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXdCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBeUJkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkF1QmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXlCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1NBQ0Q7SUFDSDtJQUVBLDBCQUEwQjtRQUN4QlosT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkE2Q1BDLGFBQWE7WUFDZjtZQUNBO2dCQUNFSixPQUFPO2dCQUNQRyxNQUFPO2dCQTZDUEMsYUFBYTtZQUNmO1NBQ0Q7UUFDREMsbUJBQW1CO1lBQ2pCO2dCQUNFQyxRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXNCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBb0JkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkF3QmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXNCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBc0JkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFtQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQStCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBc0JkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkEyQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQStDZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1NBQ0Q7SUFDSDtJQUVBLHVCQUF1QjtRQUNyQlosT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkFnR1BDLGFBQWE7WUFDZjtTQUNEO1FBQ0RDLG1CQUFtQjtZQUNqQjtnQkFDRUMsUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFTZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBdUJkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkE4QmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQWtDZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBNkNkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkE2Q2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQTZCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBNENkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFvQ2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQWlEZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBb0NkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkF1RGRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQTREZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBZ0dkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFnRGRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQWdHZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBNkpkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFzRmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQTBKZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBc1RkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7U0FDRDtJQUNIO0lBRUEsZ0JBQWdCO1FBQ2RaLE9BQU87UUFDUEMsVUFBVTtRQUNWQyxjQUFjO1lBQ1o7Z0JBQ0VGLE9BQU87Z0JBQ1BHLE1BQU87Z0JBMkJQQyxhQUFhO1lBQ2Y7U0FDRDtRQUNEQyxtQkFBbUIsRUFFbEI7SUFDSDtJQUVBLDJCQUEyQjtRQUN6QkwsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkF1QlBDLGFBQWE7WUFDZjtTQUNEO1FBQ0RDLG1CQUFtQixFQUVsQjtJQUNIO0lBRUEscUJBQXFCO1FBQ25CTCxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsY0FBYztZQUNaO2dCQUNFRixPQUFPO2dCQUNQRyxNQUFPO2dCQW1CUEMsYUFBYTtZQUNmO1NBQ0Q7UUFDREMsbUJBQW1CLEVBRWxCO0lBQ0g7SUFFQSx5QkFBeUI7UUFDdkJMLE9BQU87UUFDUEMsVUFBVTtRQUNWQyxjQUFjO1lBQ1o7Z0JBQ0VGLE9BQU87Z0JBQ1BHLE1BQU87Z0JBd0NQQyxhQUFhO1lBQ2Y7U0FDRDtRQUNEQyxtQkFBbUIsRUFFbEI7SUFDSDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2RhdGEvdG9waWNDb250ZW50LnRzPzA5OWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBDb2RlRXhhbXBsZSB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGNvZGU6IHN0cmluZztcbiAgZXhwbGFuYXRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmFjdGljZVF1ZXN0aW9uIHtcbiAgbnVtYmVyOiBudW1iZXI7XG4gIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicgfCAnaW50ZXJtZWRpYXRlJyB8ICdhZHZhbmNlZCc7XG4gIHF1ZXN0aW9uOiBzdHJpbmc7XG4gIGNvZGU/OiBzdHJpbmc7XG4gIGFuc3dlcjogc3RyaW5nO1xuICBleHBsYW5hdGlvbjogc3RyaW5nO1xuICBjb3JyZWN0Q29kZT86IHN0cmluZztcbiAga2V5TGVhcm5pbmc6IHN0cmluZztcbiAgZXhhbVRpcDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvcGljQ29udGVudCB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIG92ZXJ2aWV3OiBzdHJpbmc7XG4gIGNvZGVFeGFtcGxlczogQ29kZUV4YW1wbGVbXTtcbiAgcHJhY3RpY2VRdWVzdGlvbnM6IFByYWN0aWNlUXVlc3Rpb25bXTtcbn1cblxuZXhwb3J0IGNvbnN0IHRvcGljQ29udGVudDogUmVjb3JkPHN0cmluZywgVG9waWNDb250ZW50PiA9IHtcbiAgJ3ZhcmlhYmxlcy1hbmQtZGF0YS10eXBlcyc6IHtcbiAgICB0aXRsZTogJ1ZhcmlhYmxlcyBhbmQgRGF0YSBUeXBlcycsXG4gICAgb3ZlcnZpZXc6ICdNYXN0ZXIgQXBleCB2YXJpYWJsZXMsIHByaW1pdGl2ZSBkYXRhIHR5cGVzLCBhbmQgdHlwZSBjb252ZXJzaW9uLiBWYXJpYWJsZXMgYXJlIHRoZSBmb3VuZGF0aW9uIG9mIGV2ZXJ5IEFwZXggcHJvZ3JhbSAtIHRoZXkgc3RvcmUgaW5mb3JtYXRpb24geW91ciBjb2RlIG5lZWRzLiBVbmRlcnN0YW5kaW5nIHZhcmlhYmxlcyBpcyBjcnVjaWFsIGJlY2F1c2UgRVZFUllUSElORyBpbiBTYWxlc2ZvcmNlIGRldmVsb3BtZW50IGJ1aWxkcyBvbiB0aGlzOiBmcm9tIHNpbXBsZSBmaWVsZCB1cGRhdGVzIHRvIGNvbXBsZXggYnVzaW5lc3MgbG9naWMuIFRoaXMgdG9waWMgc2V0cyB0aGUgc3RhZ2UgZm9yIENvbGxlY3Rpb25zIChtdWx0aXBsZSB2YWx1ZXMpLCBDb250cm9sIEZsb3cgKGRlY2lzaW9ucyBhYm91dCB2YWx1ZXMpLCBhbmQgYmV5b25kLicsXG4gICAgY29kZUV4YW1wbGVzOiBbXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnQmFzaWMgVmFyaWFibGUgRGVjbGFyYXRpb24nLFxuICAgICAgICBjb2RlOiBgcHVibGljIGNsYXNzIFZhcmlhYmxlRXhhbXBsZSB7XG4gICAgLy8g4pyFIFdIQVQ6IENsYXNzIGRlY2xhcmF0aW9uIHdpdGggcHVibGljIGFjY2Vzc1xuICAgIC8vIPCfkoAgRVhBTSBUUkFQOiBDbGFzcyBuYW1lIG11c3QgbWF0Y2ggZmlsZW5hbWUgZXhhY3RseVxuXG4gICAgcHJpdmF0ZSBTdHJpbmcgY3VzdG9tZXJOYW1lO1xuICAgIC8vIOKchSBXSEFUOiBJbnN0YW5jZSB2YXJpYWJsZSBmb3Igc3RvcmluZyB0ZXh0XG4gICAgLy8g4pyFIFdIWTogcHJpdmF0ZSA9IGNvbnRyb2xsZWQgYWNjZXNzIChlbmNhcHN1bGF0aW9uKVxuICAgIC8vIPCfkoAgQ09NTU9OIE1JU1RBS0U6IFZhcmlhYmxlcyBkZWZhdWx0IHRvIG51bGwgKG5vdCBlbXB0eSlcblxuICAgIHByaXZhdGUgSW50ZWdlciBhZ2UgPSAwO1xuICAgIC8vIOKchSBXSEFUOiBXaG9sZSBudW1iZXIgd2l0aCBzYWZlIGluaXRpYWxpemF0aW9uXG4gICAgLy8g4pyFIFdIWTogUHJldmVudHMgbnVsbCBwb2ludGVyIGV4Y2VwdGlvbnNcbiAgICAvLyDwn5KAIEVYQU0gVFJBUDogVXNlIEludGVnZXIgKG5vdCBpbnQpIGluIEFwZXhcblxuICAgIHB1YmxpYyBWYXJpYWJsZUV4YW1wbGUoU3RyaW5nIG5hbWUpIHtcbiAgICAgICAgdGhpcy5jdXN0b21lck5hbWUgPSBuYW1lO1xuICAgICAgICAvLyDinIUgV0hBVDogdGhpcyA9IGN1cnJlbnQgb2JqZWN0IHJlZmVyZW5jZVxuICAgICAgICAvLyDinIUgV0hZOiBEaXN0aW5ndWlzaGVzIHBhcmFtZXRlciBmcm9tIGZpZWxkXG4gICAgfVxufWAsXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnQXBleCB1c2VzIHdyYXBwZXIgdHlwZXMgKEludGVnZXIsIEJvb2xlYW4sIFN0cmluZykgaW5zdGVhZCBvZiBKYXZhIHByaW1pdGl2ZXMuIEFsbCB2YXJpYWJsZXMgY2FuIGJlIG51bGwgYW5kIGhhdmUgbWV0aG9kcy4gQWx3YXlzIGluaXRpYWxpemUgdmFyaWFibGVzIG9yIGNoZWNrIGZvciBudWxsIGJlZm9yZSB1c2luZyB0aGVtLidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnU3RyaW5nIE9wZXJhdGlvbnMnLFxuICAgICAgICBjb2RlOiBgcHVibGljIGNsYXNzIFN0cmluZ0RlbW8ge1xuICAgIHB1YmxpYyB2b2lkIHByb2Nlc3NOYW1lcygpIHtcbiAgICAgICAgU3RyaW5nIGZpcnN0TmFtZSA9ICdKb2huJztcbiAgICAgICAgLy8g8J+SgCBFWEFNIFRSQVA6IFNpbmdsZSBxdW90ZXMgKG5vdCBkb3VibGUpIGluIEFwZXhcblxuICAgICAgICBTdHJpbmcgbGFzdE5hbWUgPSAnRG9lJztcbiAgICAgICAgU3RyaW5nIGZ1bGxOYW1lID0gZmlyc3ROYW1lICsgJyAnICsgbGFzdE5hbWU7XG4gICAgICAgIC8vIOKchSBSRVNVTFQ6ICdKb2huIERvZSdcblxuICAgICAgICBCb29sZWFuIGhhc0NvbnRlbnQgPSBTdHJpbmcuaXNOb3RCbGFuayhmdWxsTmFtZSk7XG4gICAgICAgIC8vIOKchSBTQUZFOiBDaGVja3MgbnVsbCBBTkQgZW1wdHkgQU5EIHdoaXRlc3BhY2VcbiAgICAgICAgLy8g4pyFIEJFVFRFUiBUSEFOOiBmdWxsTmFtZSAhPSBudWxsICYmIGZ1bGxOYW1lLmxlbmd0aCgpID4gMFxuXG4gICAgICAgIGlmIChoYXNDb250ZW50KSB7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ05hbWU6ICcgKyBmdWxsTmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ1N0cmluZyBvcGVyYXRpb25zIGluIEFwZXggYXJlIG51bGwtc2FmZSB3aGVuIHVzaW5nIGJ1aWx0LWluIG1ldGhvZHMgbGlrZSBpc05vdEJsYW5rKCkuIEFsd2F5cyB1c2UgdGhlc2UgaW5zdGVhZCBvZiBtYW51YWwgbnVsbCBjaGVja3MgZm9yIHJvYnVzdCBjb2RlLidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnVHlwZSBDb252ZXJzaW9uJyxcbiAgICAgICAgY29kZTogYHB1YmxpYyBjbGFzcyBDb252ZXJzaW9uRGVtbyB7XG4gICAgcHVibGljIHZvaWQgc2FmZUNvbnZlcnNpb24oKSB7XG4gICAgICAgIFN0cmluZyBudW1iZXJTdHIgPSAnMTIzJztcbiAgICAgICAgSW50ZWdlciByZXN1bHQ7XG5cbiAgICAgICAgLy8g4pyFIFNBRkU6IENoZWNrIGJlZm9yZSBjb252ZXJ0aW5nXG4gICAgICAgIGlmIChudW1iZXJTdHIuaXNOdW1lcmljKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEludGVnZXIudmFsdWVPZihudW1iZXJTdHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDsgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g4pyFIFNBRkU6IFRyeS1jYXRjaCBmb3IgY29tcGxleCBjb252ZXJzaW9uc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgRGVjaW1hbCBwcmljZSA9IERlY2ltYWwudmFsdWVPZignMTkuOTknKTtcbiAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnUHJpY2U6ICcgKyBwcmljZSk7XG4gICAgICAgIH0gY2F0Y2ggKFR5cGVFeGNlcHRpb24gZSkge1xuICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdJbnZhbGlkIG51bWJlciBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0Fsd2F5cyB2YWxpZGF0ZSBpbnB1dCBiZWZvcmUgdHlwZSBjb252ZXJzaW9uLiBVc2UgaXNOdW1lcmljKCkgZm9yIGJhc2ljIGNoZWNrcyBhbmQgdHJ5LWNhdGNoIGZvciBjb21wbGV4IHNjZW5hcmlvcy4gVHlwZUV4Y2VwdGlvbiBpcyB0aHJvd24gZm9yIGludmFsaWQgY29udmVyc2lvbnMuJ1xuICAgICAgfVxuICAgIF0sXG4gICAgcHJhY3RpY2VRdWVzdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGF0IGlzIHdyb25nIHdpdGggdGhpcyBjb2RlP1wiLFxuICAgICAgICBjb2RlOiBgU3RyaW5nIG5hbWU7XG5JbnRlZ2VyIGxlbmd0aCA9IG5hbWUubGVuZ3RoKCk7YCxcbiAgICAgICAgYW5zd2VyOiBcIk51bGxQb2ludGVyRXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB2YXJpYWJsZSAnbmFtZScgaXMgZGVjbGFyZWQgYnV0IG5vdCBpbml0aWFsaXplZCwgc28gaXQgZGVmYXVsdHMgdG8gbnVsbC4gQ2FsbGluZyAubGVuZ3RoKCkgb24gYSBudWxsIFN0cmluZyB0aHJvd3MgYSBOdWxsUG9pbnRlckV4Y2VwdGlvbiBhdCBydW50aW1lLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYFN0cmluZyBuYW1lID0gJ0pvaG4nOyAgLy8gSW5pdGlhbGl6ZSB0aGUgdmFyaWFibGVcbkludGVnZXIgbGVuZ3RoID0gbmFtZS5sZW5ndGgoKTsgIC8vIE5vdyBzYWZlIHRvIGNhbGxgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJBbHdheXMgaW5pdGlhbGl6ZSB2YXJpYWJsZXMgb3IgY2hlY2sgZm9yIG51bGwgYmVmb3JlIHVzaW5nIHRoZW0uIFVuaW5pdGlhbGl6ZWQgcmVmZXJlbmNlIHZhcmlhYmxlcyBkZWZhdWx0IHRvIG51bGwuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiVGhpcyBpcyBhIHZlcnkgY29tbW9uIFBEMSBjZXJ0aWZpY2F0aW9uIHF1ZXN0aW9uIHBhdHRlcm4uIEFsd2F5cyBsb29rIGZvciB1bmluaXRpYWxpemVkIHZhcmlhYmxlcyBpbiBjb2RlIHNhbXBsZXMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMixcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hpY2ggZGF0YSB0eXBlIHNob3VsZCB5b3UgdXNlIGZvciBzdG9yaW5nIGN1cnJlbmN5IHZhbHVlcyBpbiBTYWxlc2ZvcmNlP1wiLFxuICAgICAgICBhbnN3ZXI6IFwiRGVjaW1hbFwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJEZWNpbWFsIGlzIHRoZSBiZXN0IGNob2ljZSBmb3IgY3VycmVuY3kgYmVjYXVzZSBpdCBwcm92aWRlcyBleGFjdCBwcmVjaXNpb24gd2l0aG91dCBmbG9hdGluZy1wb2ludCByb3VuZGluZyBlcnJvcnMuIERvdWJsZS9GbG9hdCBjYW4gaW50cm9kdWNlIHJvdW5kaW5nIGVycm9ycyB0aGF0IGFyZSB1bmFjY2VwdGFibGUgZm9yIGZpbmFuY2lhbCBjYWxjdWxhdGlvbnMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgRGVjaW1hbCBwcmljZSA9IDE5Ljk5O1xuRGVjaW1hbCB0b3RhbCA9IHByaWNlICogMS4wODsgIC8vIEV4YWN0IGNhbGN1bGF0aW9uYCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiVXNlIERlY2ltYWwgZm9yIGZpbmFuY2lhbCBjYWxjdWxhdGlvbnMgdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgcHJlY2lzaW9uIGlzc3Vlcy4gQ3VycmVuY3kgZmllbGRzIGluIFNhbGVzZm9yY2UgYXJlIGFsc28gc3RvcmVkIGFzIERlY2ltYWwuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiU2FsZXNmb3JjZSBzdHJvbmdseSByZWNvbW1lbmRzIERlY2ltYWwgZm9yIGN1cnJlbmN5LiBUaGlzIGFwcGVhcnMgaW4gUEQxIHF1ZXN0aW9ucyBhYm91dCBkYXRhIHR5cGUgc2VsZWN0aW9uLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDMsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoYXQgaGFwcGVucyB3aGVuIHlvdSBkZWNsYXJlICdJbnRlZ2VyIGNvdW50Oycgd2l0aG91dCBpbml0aWFsaXphdGlvbj9cIixcbiAgICAgICAgYW5zd2VyOiBcImNvdW50IGRlZmF1bHRzIHRvIG51bGxcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiSW4gQXBleCwgdW5pbml0aWFsaXplZCBwcmltaXRpdmUgd3JhcHBlciB0eXBlcyAoSW50ZWdlciwgRG91YmxlLCBCb29sZWFuLCBldGMuKSBkZWZhdWx0IHRvIG51bGwsIG5vdCB6ZXJvLiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIEphdmEgd2hlcmUgcHJpbWl0aXZlcyBoYXZlIGRlZmF1bHQgdmFsdWVzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYEludGVnZXIgY291bnQgPSAwOyAgLy8gRXhwbGljaXRseSBpbml0aWFsaXplXG4vLyBPUlxuSW50ZWdlciBjb3VudDtcbmlmIChjb3VudCA9PSBudWxsKSB7XG4gICAgY291bnQgPSAwOyAgLy8gSGFuZGxlIG51bGwgY2FzZVxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkFwZXggcHJpbWl0aXZlIHdyYXBwZXJzIGRlZmF1bHQgdG8gbnVsbCwgbm90IHplcm8uIEFsd2F5cyBpbml0aWFsaXplIG9yIG51bGwtY2hlY2sgYmVmb3JlIHVzaW5nLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlBEMSBleGFtIHRlc3RzIHVuZGVyc3RhbmRpbmcgb2YgbnVsbCB2cyB6ZXJvLiBSZW1lbWJlciBBcGV4IHVzZXMgd3JhcHBlciB0eXBlcyAoSW50ZWdlcikgbm90IHByaW1pdGl2ZXMgKGludCkuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiRml4IHRoaXMgY29kZTogJ2Jvb2xlYW4gaXNBY3RpdmUgPSB0cnVlOydcIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBCb29sZWFuIChjYXBpdGFsIEIpIGluc3RlYWQgb2YgYm9vbGVhblwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJBcGV4IHVzZXMgd3JhcHBlciB0eXBlcywgbm90IEphdmEgcHJpbWl0aXZlcy4gJ2Jvb2xlYW4nIChsb3dlcmNhc2UpIGRvZXNuJ3QgZXhpc3QgaW4gQXBleCAtIHVzZSAnQm9vbGVhbicgKGNhcGl0YWwgQikuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgQm9vbGVhbiBpc0FjdGl2ZSA9IHRydWU7ICAvLyBDb3JyZWN0IHdyYXBwZXIgdHlwZWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkFwZXggb25seSBoYXMgd3JhcHBlciB0eXBlcyAoQm9vbGVhbiwgSW50ZWdlciwgRG91YmxlKSwgbm90IEphdmEgcHJpbWl0aXZlcyAoYm9vbGVhbiwgaW50LCBkb3VibGUpLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkNhc2Ugc2Vuc2l0aXZpdHkgaXMgdGVzdGVkIG9uIFBEMS4gQWx3YXlzIHVzZSBjYXBpdGFsIGxldHRlcnMgZm9yIEFwZXggZGF0YSB0eXBlcy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA1LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCdzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJ0ludGVnZXInIGFuZCAnaW50JyBpbiBBcGV4P1wiLFxuICAgICAgICBhbnN3ZXI6IFwiJ2ludCcgZG9lc24ndCBleGlzdCBpbiBBcGV4IC0gb25seSAnSW50ZWdlcicgaXMgdmFsaWRcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiVW5saWtlIEphdmEsIEFwZXggb25seSBoYXMgd3JhcHBlciB0eXBlcy4gVGhlcmUgYXJlIG5vIHByaW1pdGl2ZSB0eXBlcyBsaWtlICdpbnQnLCAnYm9vbGVhbicsIG9yICdkb3VibGUnIGluIEFwZXguIEFsbCBkYXRhIHR5cGVzIGFyZSBvYmplY3RzIHRoYXQgY2FuIGJlIG51bGwuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgSW50ZWdlciBjb3VudCA9IDEwOyAgICAgLy8gQ29ycmVjdFxuQm9vbGVhbiBmbGFnID0gdHJ1ZTsgICAgLy8gQ29ycmVjdFxuRG91YmxlIHJhdGUgPSAyLjU7ICAgICAgLy8gQ29ycmVjdGAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkFwZXggc2ltcGxpZmllcyBKYXZhIGJ5IG9ubHkgaGF2aW5nIHdyYXBwZXIgdHlwZXMuIFRoaXMgbWVhbnMgYWxsIHZhcmlhYmxlcyBjYW4gYmUgbnVsbCBhbmQgaGF2ZSBtZXRob2RzLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlRoaXMgZnVuZGFtZW50YWwgZGlmZmVyZW5jZSBmcm9tIEphdmEgaXMgZnJlcXVlbnRseSB0ZXN0ZWQuIFJlbWVtYmVyOiBBcGV4ID0gd3JhcHBlciB0eXBlcyBvbmx5LlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDYsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGF0IGhhcHBlbnMgd2l0aCB0aGlzIGNvZGU6IERlY2ltYWwgZDEgPSBudWxsOyBEZWNpbWFsIGQyID0gMTA7IERlY2ltYWwgcmVzdWx0ID0gZDEgKyBkMjtcIixcbiAgICAgICAgYW5zd2VyOiBcIk51bGxQb2ludGVyRXhjZXB0aW9uIGlzIHRocm93blwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJXaGVuIHBlcmZvcm1pbmcgYXJpdGhtZXRpYyBvcGVyYXRpb25zIHdpdGggRGVjaW1hbCB2YXJpYWJsZXMsIGlmIGFueSBvcGVyYW5kIGlzIG51bGwsIHRoZSBvcGVyYXRpb24gdGhyb3dzIGEgTnVsbFBvaW50ZXJFeGNlcHRpb24uIFVubGlrZSBzb21lIGxhbmd1YWdlcyB0aGF0IG1pZ2h0IHRyZWF0IG51bGwgYXMgemVybywgQXBleCByZXF1aXJlcyBleHBsaWNpdCBudWxsIGNoZWNraW5nLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYERlY2ltYWwgZDEgPSBudWxsO1xuRGVjaW1hbCBkMiA9IDEwO1xuRGVjaW1hbCByZXN1bHQgPSAoZDEgIT0gbnVsbCA/IGQxIDogMCkgKyBkMjsgIC8vIFNhZmUgYWRkaXRpb25gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJBbHdheXMgbnVsbC1jaGVjayBEZWNpbWFsIHZhcmlhYmxlcyBiZWZvcmUgYXJpdGhtZXRpYyBvcGVyYXRpb25zLiBBcGV4IGRvZXNuJ3QgYXV0by1jb252ZXJ0IG51bGwgdG8gemVyby5cIixcbiAgICAgICAgZXhhbVRpcDogXCJOdWxsIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBhcmUgZnJlcXVlbnRseSB0ZXN0ZWQgc2NlbmFyaW9zIG9uIGNlcnRpZmljYXRpb24gZXhhbXMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiWW91J3JlIHJldmlld2luZyBjb2RlIGFuZCBzZWUgJ1N0cmluZyBuYW1lOyBTeXN0ZW0uZGVidWcobmFtZS50b1VwcGVyQ2FzZSgpKTsnIC0gd2hhdCB3aWxsIGhhcHBlbiBhbmQgaG93IGRvIHlvdSBmaXggaXQ/XCIsXG4gICAgICAgIGFuc3dlcjogXCJOdWxsUG9pbnRlckV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBiZWNhdXNlICduYW1lJyBpcyB1bmluaXRpYWxpemVkIChudWxsKVwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJJbiBBcGV4LCBkZWNsYXJpbmcgYSB2YXJpYWJsZSB3aXRob3V0IGluaXRpYWxpemF0aW9uIHNldHMgaXQgdG8gbnVsbC4gQ2FsbGluZyBtZXRob2RzIG9uIG51bGwgb2JqZWN0cyB0aHJvd3MgTnVsbFBvaW50ZXJFeGNlcHRpb24gYXQgcnVudGltZS4gVGhpcyBpcyBhIGNvbW1vbiBtaXN0YWtlIGZvciBkZXZlbG9wZXJzIGNvbWluZyBmcm9tIGxhbmd1YWdlcyB3aGVyZSBwcmltaXRpdmVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gT3B0aW9uIDE6IEluaXRpYWxpemUgd2l0aCBhIHZhbHVlXG5TdHJpbmcgbmFtZSA9ICdKb2huJztcblN5c3RlbS5kZWJ1ZyhuYW1lLnRvVXBwZXJDYXNlKCkpOyAvLyBTYWZlXG5cbi8vIE9wdGlvbiAyOiBOdWxsLWNoZWNrIGJlZm9yZSB1c2VcblN0cmluZyBuYW1lO1xuaWYgKFN0cmluZy5pc05vdEJsYW5rKG5hbWUpKSB7XG4gICAgU3lzdGVtLmRlYnVnKG5hbWUudG9VcHBlckNhc2UoKSk7XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQWx3YXlzIGluaXRpYWxpemUgdmFyaWFibGVzIG9yIG51bGwtY2hlY2sgYmVmb3JlIGNhbGxpbmcgbWV0aG9kcy4gVW5pbml0aWFsaXplZCByZWZlcmVuY2UgdmFyaWFibGVzIGRlZmF1bHQgdG8gbnVsbCBpbiBBcGV4LlwiLFxuICAgICAgICBleGFtVGlwOiBcIlRoaXMgZXhhY3QgcGF0dGVybiBhcHBlYXJzIGZyZXF1ZW50bHkgb24gY2VydGlmaWNhdGlvbiBleGFtcy4gQWx3YXlzIGxvb2sgZm9yIHVuaW5pdGlhbGl6ZWQgdmFyaWFibGVzIGluIGNvZGUgc2FtcGxlcy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA4LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiQSBqdW5pb3IgZGV2ZWxvcGVyIGFza3Mgd2h5ICdpbnQgY291bnQgPSAwOycgZG9lc24ndCB3b3JrIGluIEFwZXguIEhvdyBkbyB5b3UgZXhwbGFpbiBpdD9cIixcbiAgICAgICAgYW5zd2VyOiBcIkFwZXggb25seSBoYXMgd3JhcHBlciB0eXBlcyBsaWtlICdJbnRlZ2VyJywgbm90IHByaW1pdGl2ZXMgbGlrZSAnaW50J1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJVbmxpa2UgSmF2YSwgQXBleCBzaW1wbGlmaWVkIHRoZSB0eXBlIHN5c3RlbSBieSBvbmx5IHByb3ZpZGluZyB3cmFwcGVyIHR5cGVzIChJbnRlZ2VyLCBCb29sZWFuLCBEb3VibGUsIGV0Yy4pLiBUaGVyZSBhcmUgbm8gcHJpbWl0aXZlIHR5cGVzIChpbnQsIGJvb2xlYW4sIGRvdWJsZSkgaW4gQXBleC4gVGhpcyBtZWFucyBhbGwgdmFyaWFibGVzIGNhbiBiZSBudWxsIGFuZCBoYXZlIG1ldGhvZHMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgSW50ZWdlciBjb3VudCA9IDA7ICAgICAgICAvLyBDb3JyZWN0IC0gd3JhcHBlciB0eXBlXG5Cb29sZWFuIGlzQWN0aXZlID0gdHJ1ZTsgIC8vIENvcnJlY3QgLSB3cmFwcGVyIHR5cGVcbkRvdWJsZSByYXRlID0gMi41OyAgICAgICAgLy8gQ29ycmVjdCAtIHdyYXBwZXIgdHlwZVxuXG4vLyBUaGVzZSBkb24ndCBleGlzdCBpbiBBcGV4OlxuLy8gaW50IGNvdW50ID0gMDsgICAgICAgIC8vIENvbXBpbGF0aW9uIGVycm9yXG4vLyBib29sZWFuIGZsYWcgPSB0cnVlOyAgLy8gQ29tcGlsYXRpb24gZXJyb3JgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJBcGV4ID0gd3JhcHBlciB0eXBlcyBvbmx5LiBUaGlzIHNpbXBsaWZpZXMgdGhlIGxhbmd1YWdlIGJ1dCBtZWFucyBhbGwgdmFyaWFibGVzIGNhbiBiZSBudWxsLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlR5cGUgc3lzdGVtIHF1ZXN0aW9ucyBhcmUgY29tbW9uLiBSZW1lbWJlcjogQXBleCB3cmFwcGVyIHR5cGVzIChJbnRlZ2VyKSB2cyBKYXZhIHByaW1pdGl2ZXMgKGludCkgLSBvbmx5IHdyYXBwZXJzIGV4aXN0IGluIEFwZXguXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogOSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSBuZWVkIHRvIHN0b3JlIG1vbmV0YXJ5IHZhbHVlcyB3aXRoIHByZWNpc2lvbi4gV2hhdCBkYXRhIHR5cGUgZG8geW91IGNob29zZSBhbmQgd2h5P1wiLFxuICAgICAgICBhbnN3ZXI6IFwiRGVjaW1hbCAtIGl0IHByb3ZpZGVzIGV4YWN0IHByZWNpc2lvbiB3aXRob3V0IGZsb2F0aW5nLXBvaW50IHJvdW5kaW5nIGVycm9yc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJGb3IgZmluYW5jaWFsIGNhbGN1bGF0aW9ucywgRGVjaW1hbCBpcyB0aGUgb25seSBzYWZlIGNob2ljZSBiZWNhdXNlIGl0IGF2b2lkcyBmbG9hdGluZy1wb2ludCBhcml0aG1ldGljIGVycm9ycyB0aGF0IGNhbiBvY2N1ciB3aXRoIERvdWJsZS4gQ3VycmVuY3kgZmllbGRzIGluIFNhbGVzZm9yY2UgYXJlIHN0b3JlZCBhcyBEZWNpbWFsLCBtYWtpbmcgdGhpcyB0aGUgbmF0dXJhbCBjaG9pY2UgZm9yIG1vbmV0YXJ5IGNhbGN1bGF0aW9ucy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBDb3JyZWN0IGZvciBjdXJyZW5jeVxuRGVjaW1hbCBwcmljZSA9IDE5Ljk5O1xuRGVjaW1hbCB0YXggPSBwcmljZSAqIDAuMDg7XG5EZWNpbWFsIHRvdGFsID0gcHJpY2UgKyB0YXg7ICAvLyBFeGFjdCBjYWxjdWxhdGlvblxuXG4vLyBXcm9uZyBmb3IgY3VycmVuY3kgLSBjYW4gaGF2ZSByb3VuZGluZyBlcnJvcnNcbkRvdWJsZSBwcmljZSA9IDE5Ljk5O1xuRG91YmxlIHRheCA9IHByaWNlICogMC4wODsgICAgLy8gUG90ZW50aWFsIHByZWNpc2lvbiBsb3NzYCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiVXNlIERlY2ltYWwgZm9yIGFsbCBmaW5hbmNpYWwgY2FsY3VsYXRpb25zIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IHByZWNpc2lvbiBpc3N1ZXMuIEN1cnJlbmN5IGZpZWxkcyBpbiBTYWxlc2ZvcmNlIHVzZSBEZWNpbWFsLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkN1cnJlbmN5IGRhdGEgdHlwZSBxdWVzdGlvbnMgYXBwZWFyIGZyZXF1ZW50bHkuIFJlbWVtYmVyOiBEZWNpbWFsIGZvciBtb25leSwgRG91YmxlL0Zsb2F0IGZvciBzY2llbnRpZmljIGNhbGN1bGF0aW9ucy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxMCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiQ29kZSByZXZpZXc6ICdCb29sZWFuIGlzQWN0aXZlOycgLSB3aGF0J3MgdGhlIHBvdGVudGlhbCBpc3N1ZSBhbmQgaG93IGRvIHlvdSBpbXByb3ZlIGl0P1wiLFxuICAgICAgICBhbnN3ZXI6IFwiVW5pbml0aWFsaXplZCBCb29sZWFuIGRlZmF1bHRzIHRvIG51bGwsIG5vdCBmYWxzZSwgd2hpY2ggY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3JcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiSW4gQXBleCwgQm9vbGVhbiB2YXJpYWJsZXMgZGVmYXVsdCB0byBudWxsIHdoZW4gdW5pbml0aWFsaXplZCwgbm90IGZhbHNlLiBUaGlzIGNhbiBjYXVzZSBpc3N1ZXMgaW4gY29uZGl0aW9uYWwgbG9naWMgd2hlcmUgeW91IG1pZ2h0IGV4cGVjdCBmYWxzZSBiZWhhdmlvci4gRXhwbGljaXQgaW5pdGlhbGl6YXRpb24gcHJldmVudHMgY29uZnVzaW9uIGFuZCBwb3RlbnRpYWwgTlBFcy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBCZXR0ZXI6IEV4cGxpY2l0IGluaXRpYWxpemF0aW9uXG5Cb29sZWFuIGlzQWN0aXZlID0gZmFsc2U7ICAvLyBDbGVhciBpbnRlbnQsIG5vIG51bGwgaXNzdWVzXG5cbi8vIE9yIGhhbmRsZSBudWxsIGV4cGxpY2l0bHlcbkJvb2xlYW4gaXNBY3RpdmU7XG5pZiAoaXNBY3RpdmUgPT0gdHJ1ZSkgeyAgICAvLyBFeHBsaWNpdCBudWxsLXNhZmUgY29tcGFyaXNvblxuICAgIFN5c3RlbS5kZWJ1ZygnQWN0aXZlJyk7XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQm9vbGVhbiB2YXJpYWJsZXMgZGVmYXVsdCB0byBudWxsLCBub3QgZmFsc2UuIEFsd2F5cyBpbml0aWFsaXplIG9yIHVzZSBleHBsaWNpdCBudWxsLXNhZmUgY29tcGFyaXNvbnMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiQm9vbGVhbiBudWxsIGJlaGF2aW9yIGlzIHRlc3RlZCBmcmVxdWVudGx5LiBSZW1lbWJlcjogbnVsbCAhPSBmYWxzZSBpbiBBcGV4IEJvb2xlYW4gbG9naWMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTEsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJBIG1ldGhvZCByZWNlaXZlcyBhIFN0cmluZyBwYXJhbWV0ZXIgdGhhdCBtaWdodCBiZSBudWxsLCBlbXB0eSwgb3Igd2hpdGVzcGFjZS4gV3JpdGUgdGhlIHNhZmVzdCB2YWxpZGF0aW9uLlwiLFxuICAgICAgICBhbnN3ZXI6IFwiVXNlIFN0cmluZy5pc05vdEJsYW5rKCkgZm9yIGNvbXByZWhlbnNpdmUgdmFsaWRhdGlvblwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJTdHJpbmcuaXNOb3RCbGFuaygpIGlzIHRoZSBtb3N0IGNvbXByZWhlbnNpdmUgY2hlY2sgYXMgaXQgdmFsaWRhdGVzIGFnYWluc3QgbnVsbCwgZW1wdHkgc3RyaW5nLCBhbmQgc3RyaW5ncyBjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLiBUaGlzIGlzIHNhZmVyIHRoYW4gbWFudWFsIG51bGwgY2hlY2tzIG9yIGlzRW1wdHkoKS5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgdm9pZCBwcm9jZXNzTmFtZShTdHJpbmcgbmFtZSkge1xuICAgIC8vIEJlc3Q6IEhhbmRsZXMgbnVsbCwgZW1wdHksIGFuZCB3aGl0ZXNwYWNlXG4gICAgaWYgKFN0cmluZy5pc05vdEJsYW5rKG5hbWUpKSB7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnVmFsaWQgbmFtZTogJyArIG5hbWUudHJpbSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ0ludmFsaWQgbmFtZSBwcm92aWRlZCcpO1xuICAgIH1cbn1cblxuLy8gQWx0ZXJuYXRpdmUgZm9yIHNwZWNpZmljIGNhc2VzOlxuaWYgKFN0cmluZy5pc05vdEVtcHR5KG5hbWUpKSB7IH0gLy8gbnVsbCBhbmQgZW1wdHkgb25seVxuaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lLmxlbmd0aCgpID4gMCkgeyB9IC8vIE1hbnVhbCwgbW9yZSB2ZXJib3NlYCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiU3RyaW5nLmlzTm90QmxhbmsoKSBpcyB5b3VyIGJlc3QgZnJpZW5kIGZvciBzdHJpbmcgdmFsaWRhdGlvbi4gSXQgaGFuZGxlcyBhbGwgZWRnZSBjYXNlcyBpbiBvbmUgY2FsbC5cIixcbiAgICAgICAgZXhhbVRpcDogXCJTdHJpbmcgdmFsaWRhdGlvbiBxdWVzdGlvbnMgYXJlIGNvbW1vbi4gS25vdyB0aGUgZGlmZmVyZW5jZTogaXNOb3RCbGFuayAobnVsbC9lbXB0eS93aGl0ZXNwYWNlKSwgaXNOb3RFbXB0eSAobnVsbC9lbXB0eSBvbmx5KS5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxMixcbiAgICAgICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcbiAgICAgICAgcXVlc3Rpb246IFwiRXhwbGFpbiB3aGVuIHlvdSdkIHVzZSAnZmluYWwnIGtleXdvcmQgd2l0aCB2YXJpYWJsZXMgYW5kIGdpdmUgYSBwcmFjdGljYWwgZXhhbXBsZS5cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSAnZmluYWwnIGZvciBjb25zdGFudHMgYW5kIHZhcmlhYmxlcyB0aGF0IHNob3VsZG4ndCBiZSByZWFzc2lnbmVkIGFmdGVyIGluaXRpYWxpemF0aW9uXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIlRoZSAnZmluYWwnIGtleXdvcmQgcHJldmVudHMgdmFyaWFibGUgcmVhc3NpZ25tZW50IGFmdGVyIGluaXRpYWxpemF0aW9uLCBtYWtpbmcgY29kZSBtb3JlIHByZWRpY3RhYmxlIGFuZCBjYXRjaGluZyBhY2NpZGVudGFsIG1vZGlmaWNhdGlvbnMuIEl0J3MgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGNvbnN0YW50cywgY29uZmlndXJhdGlvbiB2YWx1ZXMsIGFuZCBwcm90ZWN0aW5nIGltcG9ydGFudCByZWZlcmVuY2VzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBjbGFzcyBDb25maWd1cmF0aW9uTWFuYWdlciB7XG4gICAgLy8gQ2xhc3MgY29uc3RhbnQgLSBjb21waWxlLXRpbWUgY29uc3RhbnRcbiAgICBwcml2YXRlIHN0YXRpYyBmaW5hbCBJbnRlZ2VyIE1BWF9SRVRSSUVTID0gMztcblxuICAgIC8vIEluc3RhbmNlIGNvbnN0YW50IC0gcnVudGltZSBjb25zdGFudFxuICAgIHByaXZhdGUgZmluYWwgU3RyaW5nIG9yZ2FuaXphdGlvbklkO1xuXG4gICAgcHVibGljIENvbmZpZ3VyYXRpb25NYW5hZ2VyKCkge1xuICAgICAgICAvLyBDYW4gb25seSBiZSBzZXQgb25jZSBkdXJpbmcgY29uc3RydWN0aW9uXG4gICAgICAgIHRoaXMub3JnYW5pemF0aW9uSWQgPSBVc2VySW5mby5nZXRPcmdhbml6YXRpb25JZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyB2b2lkIHByb2Nlc3NEYXRhKExpc3Q8QWNjb3VudD4gYWNjb3VudHMpIHtcbiAgICAgICAgLy8gTWV0aG9kLWxldmVsIGNvbnN0YW50XG4gICAgICAgIGZpbmFsIEludGVnZXIgQkFUQ0hfU0laRSA9IDIwMDtcblxuICAgICAgICAvLyBvcmdhbml6YXRpb25JZCA9ICduZXctaWQnOyAgLy8gQ29tcGlsYXRpb24gZXJyb3JcbiAgICAgICAgLy8gQkFUQ0hfU0laRSA9IDMwMDsgICAgICAgICAgIC8vIENvbXBpbGF0aW9uIGVycm9yXG4gICAgfVxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIidmaW5hbCcgcHJldmVudHMgcmVhc3NpZ25tZW50IGFuZCBkb2N1bWVudHMgaW50ZW50LiBVc2UgZm9yIGNvbnN0YW50cywgY29uZmlndXJhdGlvbiwgYW5kIHByb3RlY3RpbmcgaW1wb3J0YW50IHJlZmVyZW5jZXMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiRmluYWwga2V5d29yZCBxdWVzdGlvbnMgdGVzdCB1bmRlcnN0YW5kaW5nIG9mIGltbXV0YWJpbGl0eS4gUmVtZW1iZXI6IHByZXZlbnRzIHJlYXNzaWdubWVudCwgbm90IG9iamVjdCBtb2RpZmljYXRpb24uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTMsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJZb3Ugc2VlICdPYmplY3QgZGF0YSA9IHNvbWVNZXRob2QoKTsnIC0gd2hhdCBhcmUgdGhlIHJpc2tzIGFuZCBob3cgZG8geW91IGhhbmRsZSB0aGVtIHNhZmVseT9cIixcbiAgICAgICAgYW5zd2VyOiBcIlJpc2sgb2YgQ2xhc3NDYXN0RXhjZXB0aW9uIGFuZCBsb3NzIG9mIHR5cGUgc2FmZXR5LiBVc2UgaW5zdGFuY2VvZiBjaGVja3MgYW5kIGV4cGxpY2l0IGNhc3RpbmdcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiT2JqZWN0IGlzIHRoZSBtb3N0IGdlbmVyaWMgdHlwZSBpbiBBcGV4LiBVc2luZyBpdCBsb3NlcyBjb21waWxlLXRpbWUgdHlwZSBjaGVja2luZyBhbmQgcmVxdWlyZXMgcnVudGltZSB0eXBlIHZlcmlmaWNhdGlvbi4gVGhpcyBjYW4gbGVhZCB0byBDbGFzc0Nhc3RFeGNlcHRpb24gaWYgeW91IGNhc3QgdG8gdGhlIHdyb25nIHR5cGUuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgT2JqZWN0IGRhdGEgPSBzb21lTWV0aG9kKCk7XG5cbi8vIFNhZmUgYXBwcm9hY2ggd2l0aCBpbnN0YW5jZW9mXG5pZiAoZGF0YSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIFN0cmluZyBzdHJpbmdEYXRhID0gKFN0cmluZykgZGF0YTtcbiAgICBTeXN0ZW0uZGVidWcoJ1N0cmluZyB2YWx1ZTogJyArIHN0cmluZ0RhdGEpO1xufSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgSW50ZWdlcikge1xuICAgIEludGVnZXIgaW50RGF0YSA9IChJbnRlZ2VyKSBkYXRhO1xuICAgIFN5c3RlbS5kZWJ1ZygnSW50ZWdlciB2YWx1ZTogJyArIGludERhdGEpO1xufSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdDxPYmplY3Q+KSB7XG4gICAgTGlzdDxPYmplY3Q+IGxpc3REYXRhID0gKExpc3Q8T2JqZWN0PikgZGF0YTtcbiAgICBTeXN0ZW0uZGVidWcoJ0xpc3Qgc2l6ZTogJyArIGxpc3REYXRhLnNpemUoKSk7XG59IGVsc2Uge1xuICAgIFN5c3RlbS5kZWJ1ZygnVW5rbm93biBkYXRhIHR5cGU6ICcgKyAoZGF0YSAhPSBudWxsID8gZGF0YS5nZXRDbGFzcygpIDogJ251bGwnKSk7XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiT2JqZWN0IHR5cGUgbG9zZXMgdHlwZSBzYWZldHkuIEFsd2F5cyB1c2UgaW5zdGFuY2VvZiBiZWZvcmUgY2FzdGluZyB0byBwcmV2ZW50IENsYXNzQ2FzdEV4Y2VwdGlvbi5cIixcbiAgICAgICAgZXhhbVRpcDogXCJPYmplY3QgY2FzdGluZyBxdWVzdGlvbnMgdGVzdCB0eXBlIHNhZmV0eSB1bmRlcnN0YW5kaW5nLiBSZW1lbWJlcjogaW5zdGFuY2VvZiBiZWZvcmUgY2FzdGluZywgaGFuZGxlIG51bGwgY2FzZS5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxNCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiQSBkZXZlbG9wZXIgdXNlcyAnRG91YmxlJyBmb3IgY3VycmVuY3kgY2FsY3VsYXRpb25zLiBXaGF0IHByb2JsZW1zIGNvdWxkIHRoaXMgY2F1c2U/XCIsXG4gICAgICAgIGFuc3dlcjogXCJGbG9hdGluZy1wb2ludCBwcmVjaXNpb24gZXJyb3JzIHRoYXQgY2FuIGNhdXNlIGluY29ycmVjdCBtb25ldGFyeSBjYWxjdWxhdGlvbnNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiRG91YmxlIHVzZXMgZmxvYXRpbmctcG9pbnQgYXJpdGhtZXRpYyB3aGljaCBjYW4ndCBleGFjdGx5IHJlcHJlc2VudCBtYW55IGRlY2ltYWwgbnVtYmVycywgbGVhZGluZyB0byByb3VuZGluZyBlcnJvcnMuIEZvciBmaW5hbmNpYWwgY2FsY3VsYXRpb25zLCBldmVuIHRpbnkgZXJyb3JzIGNvbXBvdW5kIGFuZCBjYW4gY2F1c2Ugc2lnbmlmaWNhbnQgaXNzdWVzIGluIGFjY291bnRpbmcgYW5kIHJlcG9ydGluZy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBXcm9uZyAtIHBvdGVudGlhbCBwcmVjaXNpb24gZXJyb3JzXG5Eb3VibGUgcHJpY2UgPSAwLjE7XG5Eb3VibGUgdGF4ID0gMC4yO1xuRG91YmxlIHRvdGFsID0gcHJpY2UgKyB0YXg7ICAvLyBNaWdodCBub3QgZXF1YWwgZXhhY3RseSAwLjNcblxuLy8gQ29ycmVjdCAtIGV4YWN0IGRlY2ltYWwgYXJpdGhtZXRpY1xuRGVjaW1hbCBwcmljZSA9IDAuMTtcbkRlY2ltYWwgdGF4ID0gMC4yO1xuRGVjaW1hbCB0b3RhbCA9IHByaWNlICsgdGF4OyAgLy8gRXhhY3RseSAwLjNcblxuLy8gUmVhbCBleGFtcGxlXG5EZWNpbWFsIGl0ZW1QcmljZSA9IDE5Ljk5O1xuRGVjaW1hbCB0YXhSYXRlID0gMC4wODI1OyAgICAvLyA4LjI1JVxuRGVjaW1hbCB0b3RhbFByaWNlID0gaXRlbVByaWNlICogKDEgKyB0YXhSYXRlKTtgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJOZXZlciB1c2UgRG91YmxlIGZvciBjdXJyZW5jeS4gRGVjaW1hbCBwcm92aWRlcyBleGFjdCBwcmVjaXNpb24gZm9yIGZpbmFuY2lhbCBjYWxjdWxhdGlvbnMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiQ3VycmVuY3kgcHJlY2lzaW9uIHF1ZXN0aW9ucyBhcmUgZnJlcXVlbnQuIFJlbWVtYmVyOiBEZWNpbWFsIGZvciBtb25leSwgRG91YmxlIGZvciBzY2llbnRpZmljIG1lYXN1cmVtZW50cy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxNSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldyaXRlIGNvZGUgdG8gc2FmZWx5IGNvbnZlcnQgdXNlciBpbnB1dCBmcm9tIFN0cmluZyB0byBJbnRlZ2VyIHdpdGggcHJvcGVyIGVycm9yIGhhbmRsaW5nLlwiLFxuICAgICAgICBhbnN3ZXI6IFwiVXNlIHRyeS1jYXRjaCB3aXRoIEludGVnZXIudmFsdWVPZigpIGFuZCB2YWxpZGF0ZSBpbnB1dCBmaXJzdFwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJTdHJpbmcgdG8gSW50ZWdlciBjb252ZXJzaW9uIGNhbiBmYWlsIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgbm9uLW51bWVyaWMgY2hhcmFjdGVycy4gQWx3YXlzIHZhbGlkYXRlIGlucHV0IGFuZCBoYW5kbGUgVHlwZUV4Y2VwdGlvbiB0byBwcm92aWRlIG1lYW5pbmdmdWwgZXJyb3IgbWVzc2FnZXMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIEludGVnZXIgc2FmZVN0cmluZ1RvSW50ZWdlcihTdHJpbmcgaW5wdXQsIEludGVnZXIgZGVmYXVsdFZhbHVlKSB7XG4gICAgLy8gRWFybHkgdmFsaWRhdGlvblxuICAgIGlmIChTdHJpbmcuaXNCbGFuayhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZVxuICAgIGlucHV0ID0gaW5wdXQudHJpbSgpO1xuXG4gICAgLy8gQ2hlY2sgaWYgcHVyZWx5IG51bWVyaWMgKG9wdGlvbmFsIG9wdGltaXphdGlvbilcbiAgICBpZiAoIWlucHV0LmlzTnVtZXJpYygpKSB7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnTm9uLW51bWVyaWMgaW5wdXQ6ICcgKyBpbnB1dCk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIudmFsdWVPZihpbnB1dCk7XG4gICAgfSBjYXRjaCAoVHlwZUV4Y2VwdGlvbiBlKSB7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnQ29udmVyc2lvbiBlcnJvciBmb3IgaW5wdXQgXCInICsgaW5wdXQgKyAnXCI6ICcgKyBlLmdldE1lc3NhZ2UoKSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxufVxuXG4vLyBVc2FnZSBleGFtcGxlXG5JbnRlZ2VyIHVzZXJBZ2UgPSBzYWZlU3RyaW5nVG9JbnRlZ2VyKHVzZXJJbnB1dCwgMCk7YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQWx3YXlzIHZhbGlkYXRlIHN0cmluZyBpbnB1dCBiZWZvcmUgdHlwZSBjb252ZXJzaW9uLiBVc2UgdHJ5LWNhdGNoIGZvciBUeXBlRXhjZXB0aW9uIGFuZCBwcm92aWRlIG1lYW5pbmdmdWwgZGVmYXVsdHMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiVHlwZSBjb252ZXJzaW9uIHF1ZXN0aW9ucyB0ZXN0IGVycm9yIGhhbmRsaW5nIHNraWxscy4gUmVtZW1iZXI6IHZhbGlkYXRlLCB0cnktY2F0Y2gsIHByb3ZpZGUgZGVmYXVsdHMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTYsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSBuZWVkIHRvIGNvbXBhcmUgdHdvIFN0cmluZyB2YXJpYWJsZXMgZm9yIGVxdWFsaXR5LiBXaGF0IGFyZSB0aGUgZGlmZmVyZW50IGFwcHJvYWNoZXMgYW5kIHRoZWlyIGltcGxpY2F0aW9ucz9cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSAuZXF1YWxzKCkgbWV0aG9kIGZvciBjb250ZW50IGNvbXBhcmlzb24sIG5ldmVyID09IG9wZXJhdG9yXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkluIEFwZXggKGxpa2UgSmF2YSksIHRoZSA9PSBvcGVyYXRvciBjb21wYXJlcyBvYmplY3QgcmVmZXJlbmNlcywgbm90IGNvbnRlbnQuIEZvciBzdHJpbmcgY29udGVudCBjb21wYXJpc29uLCBhbHdheXMgdXNlIC5lcXVhbHMoKSBtZXRob2QuIFRoaXMgaXMgYSBjb21tb24gc291cmNlIG9mIGJ1Z3MgZm9yIGRldmVsb3BlcnMgbmV3IHRvIEFwZXguXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgU3RyaW5nIG5hbWUxID0gJ0pvaG4nO1xuU3RyaW5nIG5hbWUyID0gZ2V0TmFtZSgpOyAvLyBSZXR1cm5zICdKb2huJ1xuXG4vLyBXcm9uZyAtIGNvbXBhcmVzIHJlZmVyZW5jZXMgKG1pZ2h0IGJlIGZhbHNlIGV2ZW4gd2l0aCBzYW1lIGNvbnRlbnQpXG5pZiAobmFtZTEgPT0gbmFtZTIpIHsgfVxuXG4vLyBDb3JyZWN0IC0gY29tcGFyZXMgY29udGVudFxuaWYgKG5hbWUxLmVxdWFscyhuYW1lMikpIHsgfVxuXG4vLyBCZXR0ZXIgLSBudWxsLXNhZmUgY29tcGFyaXNvblxuaWYgKG5hbWUxPy5lcXVhbHMobmFtZTIpID09IHRydWUpIHsgfVxuXG4vLyBCZXN0IC0gdXNpbmcgU3RyaW5nIHV0aWxpdHkgKGhhbmRsZXMgbnVsbHMpXG5pZiAoU3RyaW5nLmlzRW1wdHkobmFtZTEpICYmIFN0cmluZy5pc0VtcHR5KG5hbWUyKSkge1xuICAgIC8vIEJvdGggZW1wdHkvbnVsbFxufSBlbHNlIGlmIChuYW1lMT8uZXF1YWxzKG5hbWUyKSA9PSB0cnVlKSB7XG4gICAgLy8gQ29udGVudCBtYXRjaGVzXG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiU3RyaW5nIGNvbXBhcmlzb246ID09IGNvbXBhcmVzIHJlZmVyZW5jZXMsIC5lcXVhbHMoKSBjb21wYXJlcyBjb250ZW50LiBBbHdheXMgdXNlIC5lcXVhbHMoKSBmb3Igc3RyaW5nIGNvbXBhcmlzb24uXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiU3RyaW5nIGNvbXBhcmlzb24gaXMgaGVhdmlseSB0ZXN0ZWQuIFJlbWVtYmVyOiA9PSBmb3IgcHJpbWl0aXZlcy9yZWZlcmVuY2VzLCAuZXF1YWxzKCkgZm9yIGNvbnRlbnQgY29tcGFyaXNvbi5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxNyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkEgZmllbGQgbWlnaHQgY29udGFpbiBudWxsIG9yIGFjdHVhbCBkYXRhLiBXcml0ZSBkZWZlbnNpdmUgY29kZSB0byBoYW5kbGUgYm90aCBjYXNlcy5cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBudWxsLWNvYWxlc2Npbmcgb3BlcmF0b3JzIGFuZCBzYWZlIG5hdmlnYXRpb24gZm9yIHJvYnVzdCBoYW5kbGluZ1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJBcGV4IHByb3ZpZGVzIHNldmVyYWwgbWVjaGFuaXNtcyBmb3Igc2FmZSBudWxsIGhhbmRsaW5nOiBudWxsLWNvYWxlc2NpbmcgKD86KSwgc2FmZSBuYXZpZ2F0aW9uICg/LiksIGFuZCB0cmFkaXRpb25hbCBudWxsIGNoZWNrcy4gQ29tYmluaW5nIHRoZXNlIGNyZWF0ZXMgcm9idXN0LCByZWFkYWJsZSBjb2RlLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyB2b2lkIHByb2Nlc3NBY2NvdW50RGF0YShBY2NvdW50IGFjYykge1xuICAgIC8vIE51bGwtY29hbGVzY2luZyAtIHByb3ZpZGUgZGVmYXVsdCBpZiBudWxsXG4gICAgU3RyaW5nIGFjY291bnROYW1lID0gYWNjLk5hbWUgPz8gJ1Vua25vd24gQWNjb3VudCc7XG5cbiAgICAvLyBTYWZlIG5hdmlnYXRpb24gLSBvbmx5IGNhbGwgaWYgbm90IG51bGxcbiAgICBJbnRlZ2VyIG5hbWVMZW5ndGggPSBhY2MuTmFtZT8ubGVuZ3RoKCk7XG5cbiAgICAvLyBUcmFkaXRpb25hbCBudWxsIGNoZWNrIGZvciBjb21wbGV4IGxvZ2ljXG4gICAgaWYgKGFjYy5Bbm51YWxSZXZlbnVlICE9IG51bGwpIHtcbiAgICAgICAgRGVjaW1hbCBtb250aGx5UmV2ZW51ZSA9IGFjYy5Bbm51YWxSZXZlbnVlIC8gMTI7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnTW9udGhseSByZXZlbnVlOiAnICsgbW9udGhseVJldmVudWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnQW5udWFsIHJldmVudWUgbm90IHNldCcpO1xuICAgIH1cblxuICAgIC8vIENvbWJpbmluZyBhcHByb2FjaGVzXG4gICAgU3RyaW5nIGRpc3BsYXlUZXh0ID0gYWNjLkRlc2NyaXB0aW9uPy5hYmJyZXZpYXRlKDUwKSA/PyAnTm8gZGVzY3JpcHRpb24gYXZhaWxhYmxlJztcblxuICAgIC8vIFNhZmUgZmllbGQgYWNjZXNzIHdpdGggZGVmYXVsdFxuICAgIFN0cmluZyBpbmR1c3RyeSA9IGFjYy5JbmR1c3RyeSA/PyAnTm90IFNwZWNpZmllZCc7XG4gICAgU3RyaW5nIHR5cGUgPSBhY2MuVHlwZSA/PyAnU3RhbmRhcmQnO1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlVzZSBudWxsLWNvYWxlc2NpbmcgKD8/KSBmb3IgZGVmYXVsdHMsIHNhZmUgbmF2aWdhdGlvbiAoPy4pIGZvciBtZXRob2QgY2FsbHMsIGV4cGxpY2l0IGNoZWNrcyBmb3IgY29tcGxleCBsb2dpYy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJOdWxsIGhhbmRsaW5nIGlzIGNyaXRpY2FsIGZvciByb2J1c3QgY29kZS4gS25vdyBhbGwgdGhyZWUgYXBwcm9hY2hlczogPz8sID8uLCBhbmQgZXhwbGljaXQgbnVsbCBjaGVja3MuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTgsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkV4cGxhaW4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAnU3RyaW5nIHMgPSBudWxsOycgYW5kICdTdHJpbmcgcyA9IFxcXCJcXFwiOycgYW5kIHdoZW4gZWFjaCBtYXR0ZXJzLlwiLFxuICAgICAgICBhbnN3ZXI6IFwibnVsbCBtZWFucyBubyBvYmplY3QgZXhpc3RzLCBlbXB0eSBzdHJpbmcgbWVhbnMgb2JqZWN0IGV4aXN0cyBidXQgY29udGFpbnMgbm8gY2hhcmFjdGVyc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJUaGlzIGRpc3RpbmN0aW9uIGlzIGNydWNpYWwgZm9yIHZhbGlkYXRpb24gYW5kIGJ1c2luZXNzIGxvZ2ljLiBudWxsIHR5cGljYWxseSBtZWFucyAnbm8gdmFsdWUgcHJvdmlkZWQnIHdoaWxlIGVtcHR5IHN0cmluZyBtZWFucyAndmFsdWUgcHJvdmlkZWQgYnV0IGVtcHR5Jy4gRGlmZmVyZW50IHZhbGlkYXRpb24gbWV0aG9kcyBoYW5kbGUgdGhlc2UgY2FzZXMgZGlmZmVyZW50bHkuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgU3RyaW5nIG51bGxTdHJpbmcgPSBudWxsOyAgICAgIC8vIE5vIG9iamVjdFxuU3RyaW5nIGVtcHR5U3RyaW5nID0gJyc7ICAgICAgIC8vIE9iamVjdCBleGlzdHMsIG5vIGNvbnRlbnRcblN0cmluZyBibGFua1N0cmluZyA9ICcgICAnOyAgICAvLyBPYmplY3QgZXhpc3RzLCB3aGl0ZXNwYWNlIG9ubHlcblxuLy8gRGlmZmVyZW50IHZhbGlkYXRpb24gcmVzdWx0czpcblN5c3RlbS5kZWJ1ZyhTdHJpbmcuaXNFbXB0eShudWxsU3RyaW5nKSk7ICAgICAvLyB0cnVlXG5TeXN0ZW0uZGVidWcoU3RyaW5nLmlzRW1wdHkoZW1wdHlTdHJpbmcpKTsgICAgLy8gdHJ1ZVxuU3lzdGVtLmRlYnVnKFN0cmluZy5pc0VtcHR5KGJsYW5rU3RyaW5nKSk7ICAgIC8vIGZhbHNlXG5cblN5c3RlbS5kZWJ1ZyhTdHJpbmcuaXNCbGFuayhudWxsU3RyaW5nKSk7ICAgICAvLyB0cnVlXG5TeXN0ZW0uZGVidWcoU3RyaW5nLmlzQmxhbmsoZW1wdHlTdHJpbmcpKTsgICAgLy8gdHJ1ZVxuU3lzdGVtLmRlYnVnKFN0cmluZy5pc0JsYW5rKGJsYW5rU3RyaW5nKSk7ICAgIC8vIHRydWVcblxuLy8gTnVsbC1zYWZlIG9wZXJhdGlvbnM6XG5TeXN0ZW0uZGVidWcobnVsbFN0cmluZz8ubGVuZ3RoKCkpOyAgICAgICAgICAgLy8gbnVsbFxuU3lzdGVtLmRlYnVnKGVtcHR5U3RyaW5nPy5sZW5ndGgoKSk7ICAgICAgICAgIC8vIDBcblN5c3RlbS5kZWJ1ZyhibGFua1N0cmluZz8ubGVuZ3RoKCkpOyAgICAgICAgICAvLyAzYCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwibnVsbCA9IG5vIG9iamVjdCwgZW1wdHkgPSBvYmplY3Qgd2l0aCBubyBjb250ZW50LiBVc2UgYXBwcm9wcmlhdGUgdmFsaWRhdGlvbiBtZXRob2QgYmFzZWQgb24gYnVzaW5lc3MgbmVlZHMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiU3RyaW5nIHN0YXRlIHF1ZXN0aW9ucyBhcmUgY29tbW9uLiBLbm93OiBudWxsIChubyBvYmplY3QpLCBlbXB0eSAobm8gY29udGVudCksIGJsYW5rIChubyBtZWFuaW5nZnVsIGNvbnRlbnQpLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDE5LFxuICAgICAgICBkaWZmaWN1bHR5OiAnYWR2YW5jZWQnLFxuICAgICAgICBxdWVzdGlvbjogXCJZb3UncmUgcHJvY2Vzc2luZyBmb3JtIGRhdGEgd2hlcmUgbnVtYmVycyBjb21lIGFzIHN0cmluZ3MuIFNob3cgdGhlIGNvbXBsZXRlIHNhZmUgY29udmVyc2lvbiBwYXR0ZXJuLlwiLFxuICAgICAgICBhbnN3ZXI6IFwiQ29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uIHdpdGggbXVsdGlwbGUgZmFsbGJhY2sgc3RyYXRlZ2llc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJSZWFsLXdvcmxkIGZvcm0gcHJvY2Vzc2luZyByZXF1aXJlcyBoYW5kbGluZyB2YXJpb3VzIGVkZ2UgY2FzZXM6IG51bGwgdmFsdWVzLCBlbXB0eSBzdHJpbmdzLCBub24tbnVtZXJpYyBjb250ZW50LCBkZWNpbWFsIHZzIGludGVnZXIsIG5lZ2F0aXZlIHZhbHVlcywgYW5kIHJhbmdlIHZhbGlkYXRpb24uXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIGNsYXNzIEZvcm1EYXRhUHJvY2Vzc29yIHtcbiAgICBwdWJsaWMgc3RhdGljIERlY2ltYWwgcGFyc2VEZWNpbWFsRmllbGQoU3RyaW5nIGlucHV0LCBTdHJpbmcgZmllbGROYW1lLCBEZWNpbWFsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAvLyBTdGVwIDE6IEhhbmRsZSBudWxsL2VtcHR5XG4gICAgICAgIGlmIChTdHJpbmcuaXNCbGFuayhpbnB1dCkpIHtcbiAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZyhmaWVsZE5hbWUgKyAnIGlzIGJsYW5rLCB1c2luZyBkZWZhdWx0OiAnICsgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGVwIDI6IENsZWFuIHRoZSBpbnB1dFxuICAgICAgICBTdHJpbmcgY2xlYW5lZCA9IGlucHV0LnRyaW0oKS5yZXBsYWNlKCcsJywgJycpOyAvLyBSZW1vdmUgY29tbWFzXG5cbiAgICAgICAgLy8gU3RlcCAzOiBCYXNpYyBudW1lcmljIHZhbGlkYXRpb25cbiAgICAgICAgU3RyaW5nIG51bWVyaWNQYXR0ZXJuID0gJ14tP1xcXFxkKlxcXFwuP1xcXFxkKyQnO1xuICAgICAgICBpZiAoIVBhdHRlcm4ubWF0Y2hlcyhudW1lcmljUGF0dGVybiwgY2xlYW5lZCkpIHtcbiAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnSW52YWxpZCBudW1lcmljIGZvcm1hdCBmb3IgJyArIGZpZWxkTmFtZSArICc6ICcgKyBpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RlcCA0OiBTYWZlIGNvbnZlcnNpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIERlY2ltYWwgcmVzdWx0ID0gRGVjaW1hbC52YWx1ZU9mKGNsZWFuZWQpO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDU6IFJhbmdlIHZhbGlkYXRpb24gKGV4YW1wbGUpXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lLmNvbnRhaW5zKCdQcmljZScpICYmIHJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ05lZ2F0aXZlIHByaWNlIG5vdCBhbGxvd2VkOiAnICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoVHlwZUV4Y2VwdGlvbiBlKSB7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ0NvbnZlcnNpb24gZmFpbGVkIGZvciAnICsgZmllbGROYW1lICsgJzogJyArIGUuZ2V0TWVzc2FnZSgpKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVc2FnZSBleGFtcGxlXG4gICAgcHVibGljIHN0YXRpYyB2b2lkIHByb2Nlc3NPcmRlckZvcm0oTWFwPFN0cmluZywgU3RyaW5nPiBmb3JtRGF0YSkge1xuICAgICAgICBEZWNpbWFsIHByaWNlID0gcGFyc2VEZWNpbWFsRmllbGQoZm9ybURhdGEuZ2V0KCdwcmljZScpLCAnUHJpY2UnLCAwLjAwKTtcbiAgICAgICAgRGVjaW1hbCBxdWFudGl0eSA9IHBhcnNlRGVjaW1hbEZpZWxkKGZvcm1EYXRhLmdldCgncXR5JyksICdRdWFudGl0eScsIDEuMDApO1xuICAgICAgICBEZWNpbWFsIHRvdGFsID0gcHJpY2UgKiBxdWFudGl0eTtcbiAgICB9XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiUHJvZHVjdGlvbiBmb3JtIHByb2Nlc3NpbmcgbmVlZHMgY29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uOiBudWxsIGhhbmRsaW5nLCBjbGVhbmluZywgZm9ybWF0IGNoZWNraW5nLCB0eXBlIGNvbnZlcnNpb24sIGFuZCBidXNpbmVzcyBydWxlcy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJDb21wbGV4IHZhbGlkYXRpb24gc2NlbmFyaW9zIHRlc3QgcmVhbC13b3JsZCBza2lsbHMuIFRoaW5rOiB2YWxpZGF0ZSDihpIgY2xlYW4g4oaSIGNvbnZlcnQg4oaSIGJ1c2luZXNzIHJ1bGVzLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDIwLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYWR2YW5jZWQnLFxuICAgICAgICBxdWVzdGlvbjogXCJZb3UncmUgbWVudG9yaW5nIHNvbWVvbmUgb24gdmFyaWFibGUgbmFtaW5nLiBXaGF0IGFyZSB0aGUga2V5IHByaW5jaXBsZXMgd2l0aCBleGFtcGxlcz9cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBkZXNjcmlwdGl2ZSBuYW1lcywgY29uc2lzdGVudCBjb252ZW50aW9ucywgYW5kIGNvbnRleHQtYXBwcm9wcmlhdGUgc2NvcGUgaW5kaWNhdG9yc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJHb29kIHZhcmlhYmxlIG5hbWluZyBpbXByb3ZlcyBjb2RlIHJlYWRhYmlsaXR5IGFuZCBtYWludGFpbmFiaWxpdHkuIEZvbGxvdyBjb252ZW50aW9ucyB0aGF0IG1ha2UgaW50ZW50IGNsZWFyLCBzY29wZSBvYnZpb3VzLCBhbmQgcHVycG9zZSBleHBsaWNpdC5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgY2xhc3MgVmFyaWFibGVOYW1pbmdCZXN0UHJhY3RpY2VzIHtcbiAgICAvLyBDb25zdGFudHM6IFNDUkVBTUlOR19TTkFLRV9DQVNFXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluYWwgSW50ZWdlciBNQVhfUkVUUllfQVRURU1QVFMgPSAzO1xuICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIFN0cmluZyBERUZBVUxUX0NPVU5UUllfQ09ERSA9ICdVUyc7XG5cbiAgICAvLyBJbnN0YW5jZSB2YXJpYWJsZXM6IGNhbWVsQ2FzZSB3aXRoIGRlc2NyaXB0aXZlIG5hbWVzXG4gICAgcHJpdmF0ZSBTdHJpbmcgY3VzdG9tZXJFbWFpbEFkZHJlc3M7XG4gICAgcHJpdmF0ZSBEZWNpbWFsIG1vbnRobHlSZWN1cnJpbmdSZXZlbnVlO1xuICAgIHByaXZhdGUgRGF0ZSBsYXN0TG9naW5UaW1lc3RhbXA7XG5cbiAgICAvLyBNZXRob2QgcGFyYW1ldGVyczogY2FtZWxDYXNlLCBjb250ZXh0LWNsZWFyXG4gICAgcHVibGljIHZvaWQgdXBkYXRlQ3VzdG9tZXJQcm9maWxlKFN0cmluZyBuZXdFbWFpbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuIGlzRW1haWxWZXJpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERhdGUgcHJvZmlsZUxhc3RNb2RpZmllZCkge1xuXG4gICAgICAgIC8vIExvY2FsIHZhcmlhYmxlczogZGVzY3JpcHRpdmUgd2l0aGluIHNjb3BlXG4gICAgICAgIFN0cmluZyBub3JtYWxpemVkRW1haWwgPSBuZXdFbWFpbEFkZHJlc3MudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIEJvb2xlYW4gaXNWYWxpZEVtYWlsRm9ybWF0ID0gdmFsaWRhdGVFbWFpbEZvcm1hdChub3JtYWxpemVkRW1haWwpO1xuXG4gICAgICAgIC8vIExvb3AgdmFyaWFibGVzOiBzaG9ydCBuYW1lcyBPSyBmb3Igc2hvcnQgc2NvcGVzXG4gICAgICAgIGZvciAoSW50ZWdlciBpID0gMDsgaSA8IE1BWF9SRVRSWV9BVFRFTVBUUzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHdpdGggY2xlYXIgaW50ZW50XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xsZWN0aW9uIHZhcmlhYmxlczogcGx1cmFsIG5vdW5zXG4gICAgICAgIExpc3Q8Q29udGFjdD4gY3VzdG9tZXJDb250YWN0cyA9IG5ldyBMaXN0PENvbnRhY3Q+KCk7XG4gICAgICAgIE1hcDxJZCwgQWNjb3VudD4gYWNjb3VudHNCeUlkID0gbmV3IE1hcDxJZCwgQWNjb3VudD4oKTtcblxuICAgICAgICAvLyBCb29sZWFuIHZhcmlhYmxlczogaXMvaGFzL2Nhbi9zaG91bGQgcHJlZml4ZXNcbiAgICAgICAgQm9vbGVhbiBoYXNWYWxpZExpY2Vuc2UgPSBjaGVja0xpY2Vuc2VTdGF0dXMoKTtcbiAgICAgICAgQm9vbGVhbiBjYW5Qcm9jZXNzUGF5bWVudCA9IHZhbGlkYXRlUGF5bWVudE1ldGhvZCgpO1xuICAgICAgICBCb29sZWFuIHNob3VsZFNlbmROb3RpZmljYXRpb24gPSBkZXRlcm1pbmVOb3RpZmljYXRpb25QcmVmZXJlbmNlKCk7XG4gICAgfVxufVxuXG4vLyBCYWQgZXhhbXBsZXMgdG8gYXZvaWQ6XG4vLyBTdHJpbmcgcywgc3RyLCB0ZW1wLCBkYXRhICAgICAgICAgIC8vIFRvbyBnZW5lcmljXG4vLyBJbnRlZ2VyIG51bTEsIG51bTIgICAgICAgICAgICAgICAgIC8vIFVuY2xlYXIgcHVycG9zZVxuLy8gQm9vbGVhbiBmbGFnLCBjaGVjayAgICAgICAgICAgICAgICAvLyBXaGF0IGtpbmQgb2YgZmxhZy9jaGVjaz9cbi8vIExpc3Q8T2JqZWN0PiBsaXN0ICAgICAgICAgICAgICAgICAgLy8gV2hhdCBkb2VzIGl0IGNvbnRhaW4/YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiR29vZCBuYW1lcyBhcmUgc2VsZi1kb2N1bWVudGluZy4gVXNlOiBkZXNjcmlwdGl2ZSBub3VucywgYWN0aW9uIHZlcmJzLCBjb25zaXN0ZW50IGNvbnZlbnRpb25zLCBhcHByb3ByaWF0ZSBzY29wZSBsZW5ndGguXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiQ29kZSBxdWFsaXR5IHF1ZXN0aW9ucyBpbmNsdWRlIG5hbWluZyBjb252ZW50aW9ucy4gUmVtZW1iZXI6IGNvbnN0YW50cyAoQ0FQUyksIHZhcmlhYmxlcyAoY2FtZWxDYXNlKSwgYm9vbGVhbnMgKGlzL2hhcy9jYW4pLlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuXG4gICdjb2xsZWN0aW9ucy1kZWVwLWRpdmUnOiB7XG4gICAgdGl0bGU6ICdDb2xsZWN0aW9ucyBEZWVwIERpdmUnLFxuICAgIG92ZXJ2aWV3OiAnTWFzdGVyIExpc3RzLCBTZXRzLCBNYXBzIGFuZCBidWxraWZpY2F0aW9uIHBhdHRlcm5zLiBOb3cgdGhhdCB5b3UgdW5kZXJzdGFuZCBzaW5nbGUgdmFsdWVzIChWYXJpYWJsZXMpLCBsZWFybiB0byBoYW5kbGUgTVVMVElQTEUgdmFsdWVzIGVmZmljaWVudGx5LiBDb2xsZWN0aW9ucyBhcmUgZXNzZW50aWFsIGZvciBTYWxlc2ZvcmNlIGJ1bGsgcHJvY2Vzc2luZyBhbmQgcHJldmVudCBnb3Zlcm5vciBsaW1pdCB2aW9sYXRpb25zLiBUaGlzIGtub3dsZWRnZSBkaXJlY3RseSBlbmFibGVzIENvbnRyb2wgRmxvdyAocHJvY2Vzc2luZyBjb2xsZWN0aW9ucykgYW5kIHRyaWdnZXJzIChoYW5kbGluZyBidWxrIGRhdGEgY2hhbmdlcykuJyxcbiAgICBjb2RlRXhhbXBsZXM6IFtcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdMaXN0IEZ1bmRhbWVudGFscycsXG4gICAgICAgIGNvZGU6IGBwdWJsaWMgY2xhc3MgTGlzdERlbW8ge1xuICAgIHB1YmxpYyB2b2lkIHByb2Nlc3NMaXN0KCkge1xuICAgICAgICAvLyDinIUgQlVJTERJTkcgT046IFZhcmlhYmxlcyBob2xkIE9ORSB2YWx1ZSAoU3RyaW5nIG5hbWUgPSAnSm9obicpXG4gICAgICAgIC8vIOKchSBORVcgQ09OQ0VQVDogTGlzdHMgaG9sZCBNVUxUSVBMRSB2YWx1ZXMgb2Ygc2FtZSB0eXBlXG4gICAgICAgIExpc3Q8U3RyaW5nPiBuYW1lcyA9IG5ldyBMaXN0PFN0cmluZz4oKTtcbiAgICAgICAgLy8g4pyFIENPTk5FQ1RJT046IFNhbWUgU3RyaW5nIHR5cGUgZnJvbSBWYXJpYWJsZXMgdG9waWMsIGJ1dCBub3cgYSBjb250YWluZXJcbiAgICAgICAgLy8g4pyFIFdIWTogUHJvY2Vzc2luZyBtdWx0aXBsZSByZWNvcmRzIHJlcXVpcmVzIGNvbGxlY3Rpb25zXG4gICAgICAgIC8vIPCfkqEgTkVYVCBUT1BJQzogWW91J2xsIHVzZSBsb29wcyAoQ29udHJvbCBGbG93KSB0byBwcm9jZXNzIHRoZXNlIGVmZmljaWVudGx5XG5cbiAgICAgICAgbmFtZXMuYWRkKCdKb2huJyk7XG4gICAgICAgIG5hbWVzLmFkZCgnSmFuZScpO1xuICAgICAgICBuYW1lcy5hZGQoJ0pvaG4nKTsgLy8g4pyFIExpc3RzIGFsbG93IGR1cGxpY2F0ZXMgKHVubGlrZSBTZXRzKVxuXG4gICAgICAgIC8vIOKchSBCVUlMRElORyBGT1JXQVJEOiBUaGlzIHZhbGlkYXRpb24gcGF0dGVybiBjcnVjaWFsIGluIFRyaWdnZXJzXG4gICAgICAgIGlmICghbmFtZXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBTdHJpbmcgZmlyc3QgPSBuYW1lcy5nZXQoMCk7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ0ZpcnN0IG5hbWU6ICcgKyBmaXJzdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDinIUgRU5IQU5DRUQgRk9SIExPT1A6IFByb2Nlc3MgZWFjaCBpdGVtXG4gICAgICAgIC8vIPCfkqEgTkVYVCBUT1BJQzogVGhpcyBsb29wIHN5bnRheCBjb21lcyBmcm9tIENvbnRyb2wgRmxvd1xuICAgICAgICBmb3IgKFN0cmluZyBuYW1lIDogbmFtZXMpIHtcbiAgICAgICAgICAgIC8vIOKchSBDT05ORUNUSU9OOiBTdHJpbmcgdmFsaWRhdGlvbiBmcm9tIFZhcmlhYmxlcyB0b3BpY1xuICAgICAgICAgICAgaWYgKFN0cmluZy5pc05vdEJsYW5rKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdQcm9jZXNzaW5nIHZhbGlkIG5hbWU6ICcgKyBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyDwn5KhIEJVSUxESU5HIEZPUldBUkQ6IFRoaXMgcGF0dGVybiBzY2FsZXMgdG8gcHJvY2VzcyAyMDAgcmVjb3JkcyBpbiBUcmlnZ2Vyc1xuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0xpc3RzIGFyZSBvcmRlcmVkIGNvbGxlY3Rpb25zIHRoYXQgYWxsb3cgZHVwbGljYXRlcy4gQWx3YXlzIGNoZWNrIGlzRW1wdHkoKSBiZWZvcmUgYWNjZXNzaW5nIGVsZW1lbnRzIHRvIGF2b2lkIExpc3RFeGNlcHRpb24uIFVzZSBlbmhhbmNlZCBmb3IgbG9vcHMgZm9yIGNsZWFuZXIgaXRlcmF0aW9uLidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnU2V0IE9wZXJhdGlvbnMnLFxuICAgICAgICBjb2RlOiBgcHVibGljIGNsYXNzIFNldERlbW8ge1xuICAgIHB1YmxpYyB2b2lkIGRlbW9uc3RyYXRlU2V0cygpIHtcbiAgICAgICAgLy8g4pyFIFdIQVQ6IENvbnRhaW5lciBmb3IgdW5pcXVlIHZhbHVlcyBvbmx5XG4gICAgICAgIFNldDxTdHJpbmc+IHVuaXF1ZUVtYWlscyA9IG5ldyBTZXQ8U3RyaW5nPigpO1xuICAgICAgICAvLyDinIUgV0hZOiBTZXRzIGF1dG9tYXRpY2FsbHkgcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgIC8vIOKchSBQRVJGT1JNQU5DRTogY29udGFpbnMoKSBpcyBPKDEpIHZzIExpc3QgTyhuKVxuXG4gICAgICAgIHVuaXF1ZUVtYWlscy5hZGQoJ2pvaG5AZXhhbXBsZS5jb20nKTtcbiAgICAgICAgdW5pcXVlRW1haWxzLmFkZCgnamFuZUBleGFtcGxlLmNvbScpO1xuICAgICAgICB1bmlxdWVFbWFpbHMuYWRkKCdqb2huQGV4YW1wbGUuY29tJyk7IC8vIElnbm9yZWQgLSBkdXBsaWNhdGVcblxuICAgICAgICBTeXN0ZW0uZGVidWcoJ1NpemU6ICcgKyB1bmlxdWVFbWFpbHMuc2l6ZSgpKTsgLy8gMiwgbm90IDNcblxuICAgICAgICAvLyDinIUgRkFTVCBMT09LVVA6IFVzZSBmb3IgZXhpc3RlbmNlIGNoZWNrc1xuICAgICAgICBpZiAodW5pcXVlRW1haWxzLmNvbnRhaW5zKCdqb2huQGV4YW1wbGUuY29tJykpIHtcbiAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnRW1haWwgZm91bmQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ1NldHMgZW5mb3JjZSB1bmlxdWVuZXNzIGFuZCBwcm92aWRlIE8oMSkgbG9va3VwIHBlcmZvcm1hbmNlLiBVc2UgU2V0cyB3aGVuIHlvdSBuZWVkIHRvIHByZXZlbnQgZHVwbGljYXRlcyBvciBwZXJmb3JtIGZhc3QgZXhpc3RlbmNlIGNoZWNrcy4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogJ01hcCBVc2FnZScsXG4gICAgICAgIGNvZGU6IGBwdWJsaWMgY2xhc3MgTWFwRGVtbyB7XG4gICAgcHVibGljIHZvaWQgcHJvY2Vzc0FjY291bnRzKCkge1xuICAgICAgICAvLyDinIUgV0hBVDogS2V5LXZhbHVlIHN0b3JhZ2UgZm9yIGZhc3QgbG9va3Vwc1xuICAgICAgICBNYXA8SWQsIEFjY291bnQ+IGFjY291bnRNYXAgPSBuZXcgTWFwPElkLCBBY2NvdW50PigpO1xuICAgICAgICAvLyDinIUgV0hZOiBHZXQgcmVjb3JkcyBieSBJRCB3aXRob3V0IGxvb3BzXG5cbiAgICAgICAgTGlzdDxBY2NvdW50PiBhY2NvdW50cyA9IFtTRUxFQ1QgSWQsIE5hbWUgRlJPTSBBY2NvdW50IExJTUlUIDEwXTtcblxuICAgICAgICAvLyDinIUgUE9QVUxBVEU6IEFkZCByZWNvcmRzIHRvIG1hcFxuICAgICAgICBmb3IgKEFjY291bnQgYWNjIDogYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGFjY291bnRNYXAucHV0KGFjYy5JZCwgYWNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOKchSBTQUZFIEFDQ0VTUzogQ2hlY2sga2V5IGV4aXN0c1xuICAgICAgICBJZCBzZWFyY2hJZCA9IGFjY291bnRzWzBdLklkO1xuICAgICAgICBpZiAoYWNjb3VudE1hcC5jb250YWluc0tleShzZWFyY2hJZCkpIHtcbiAgICAgICAgICAgIEFjY291bnQgZm91bmQgPSBhY2NvdW50TWFwLmdldChzZWFyY2hJZCk7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ0ZvdW5kOiAnICsgZm91bmQuTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59YCxcbiAgICAgICAgZXhwbGFuYXRpb246ICdNYXBzIHByb3ZpZGUga2V5LXZhbHVlIHN0b3JhZ2Ugd2l0aCBPKDEpIGxvb2t1cCBwZXJmb3JtYW5jZS4gQWx3YXlzIHVzZSBjb250YWluc0tleSgpIGJlZm9yZSBnZXQoKSB0byBhdm9pZCBudWxsIGlzc3Vlcy4gRXNzZW50aWFsIGZvciBidWxraWZpY2F0aW9uIHBhdHRlcm5zLidcbiAgICAgIH1cbiAgICBdLFxuICAgIHByYWN0aWNlUXVlc3Rpb25zOiBbXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCdzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBMaXN0IGFuZCBhIFNldCBpbiBBcGV4P1wiLFxuICAgICAgICBhbnN3ZXI6IFwiTGlzdHMgYWxsb3cgZHVwbGljYXRlcyBhbmQgbWFpbnRhaW4gb3JkZXIsIFNldHMgcHJldmVudCBkdXBsaWNhdGVzIGFuZCBkb24ndCBndWFyYW50ZWUgb3JkZXJcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiTGlzdHMgYXJlIGluZGV4ZWQgY29sbGVjdGlvbnMgdGhhdCBjYW4gY29udGFpbiBkdXBsaWNhdGUgdmFsdWVzIGFuZCBtYWludGFpbiBpbnNlcnRpb24gb3JkZXIuIFNldHMgYXV0b21hdGljYWxseSBlbmZvcmNlIHVuaXF1ZW5lc3MgLSBhdHRlbXB0aW5nIHRvIGFkZCBhIGR1cGxpY2F0ZSB2YWx1ZSBpcyBpZ25vcmVkLCBhbmQgZWxlbWVudHMgYXJlIG5vdCBzdG9yZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXIuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgTGlzdDxTdHJpbmc+IG5hbWVzID0gbmV3IExpc3Q8U3RyaW5nPnsnSm9obicsICdKYW5lJywgJ0pvaG4nfTsgIC8vIDMgaXRlbXNcblNldDxTdHJpbmc+IHVuaXF1ZU5hbWVzID0gbmV3IFNldDxTdHJpbmc+eydKb2huJywgJ0phbmUnLCAnSm9obid9OyAgLy8gMiBpdGVtc2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkNob29zZSBMaXN0cyB3aGVuIG9yZGVyIG1hdHRlcnMgYW5kIGR1cGxpY2F0ZXMgYXJlIGFsbG93ZWQuIENob29zZSBTZXRzIHdoZW4geW91IG5lZWQgdG8gZW5zdXJlIHVuaXF1ZW5lc3MgYW5kIGZhc3QgbG9va3Vwcy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJQRDEgZnJlcXVlbnRseSB0ZXN0cyBMaXN0IHZzIFNldCBkaWZmZXJlbmNlcy4gUmVtZW1iZXI6IExpc3RzID0gb3JkZXIgKyBkdXBsaWNhdGVzLCBTZXRzID0gdW5pcXVlbmVzcyArIGZhc3QgY29udGFpbnMoKS5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAyLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJIb3cgZG8geW91IHNhZmVseSBhY2Nlc3MgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYSBMaXN0P1wiLFxuICAgICAgICBhbnN3ZXI6IFwiQ2hlY2sgaWYgdGhlIGxpc3QgaXMgbm90IGVtcHR5IGZpcnN0OiBpZiAoIW15TGlzdC5pc0VtcHR5KCkpIHsgZmlyc3RFbGVtZW50ID0gbXlMaXN0LmdldCgwKTsgfVwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJBbHdheXMgY2hlY2sgaWYgYSBMaXN0IGhhcyBlbGVtZW50cyBiZWZvcmUgYWNjZXNzaW5nIGJ5IGluZGV4IHRvIGF2b2lkIFN5c3RlbS5MaXN0RXhjZXB0aW9uLiBVc2luZyBpc0VtcHR5KCkgaXMgbW9yZSByZWFkYWJsZSB0aGFuIGNoZWNraW5nIHNpemUoKSA+IDAuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgTGlzdDxTdHJpbmc+IG5hbWVzID0gbmV3IExpc3Q8U3RyaW5nPigpO1xuaWYgKCFuYW1lcy5pc0VtcHR5KCkpIHtcbiAgICBTdHJpbmcgZmlyc3QgPSBuYW1lcy5nZXQoMCk7ICAvLyBTYWZlIGFjY2Vzc1xufSBlbHNlIHtcbiAgICBTeXN0ZW0uZGVidWcoJ0xpc3QgaXMgZW1wdHknKTtcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJOZXZlciBhc3N1bWUgYSBMaXN0IGhhcyBlbGVtZW50cy4gQWx3YXlzIGNoZWNrIGlzRW1wdHkoKSBvciBzaXplKCkgYmVmb3JlIHVzaW5nIGdldChpbmRleCkuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiSW5kZXggb3V0IG9mIGJvdW5kcyBleGNlcHRpb25zIGFyZSBjb21tb24gZXhhbSBzY2VuYXJpb3MuIEFsd2F5cyB2YWxpZGF0ZSBiZWZvcmUgYWNjZXNzaW5nLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDMsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGF0J3Mgd3Jvbmcgd2l0aCB0aGlzIGJ1bGtpZmljYXRpb24gcGF0dGVybj9cIixcbiAgICAgICAgY29kZTogYGZvciAoQWNjb3VudCBhY2MgOiBUcmlnZ2VyLm5ldykge1xuICAgIExpc3Q8Q29udGFjdD4gY29udGFjdHMgPSBbU0VMRUNUIElkIEZST00gQ29udGFjdCBXSEVSRSBBY2NvdW50SWQgPSA6YWNjLklkXTtcbiAgICAvLyBQcm9jZXNzIGNvbnRhY3RzXG59YCxcbiAgICAgICAgYW5zd2VyOiBcIlNPUUwgcXVlcnkgaW5zaWRlIGEgbG9vcCAtIHdpbGwgaGl0IGdvdmVybm9yIGxpbWl0c1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJQdXR0aW5nIFNPUUwgcXVlcmllcyBpbnNpZGUgbG9vcHMgaXMgdGhlIG1vc3QgY29tbW9uIGJ1bGtpZmljYXRpb24gYW50aS1wYXR0ZXJuLiBXaXRoIDIwMCBhY2NvdW50cywgdGhpcyBjcmVhdGVzIDIwMCBzZXBhcmF0ZSBxdWVyaWVzLCBxdWlja2x5IGhpdHRpbmcgdGhlIDEwMCBTT1FMIHF1ZXJ5IGxpbWl0IHBlciB0cmFuc2FjdGlvbi5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBTZXQ8SWQ+IGFjY291bnRJZHMgPSBuZXcgU2V0PElkPigpO1xuZm9yIChBY2NvdW50IGFjYyA6IFRyaWdnZXIubmV3KSB7XG4gICAgYWNjb3VudElkcy5hZGQoYWNjLklkKTtcbn1cbkxpc3Q8Q29udGFjdD4gYWxsQ29udGFjdHMgPSBbU0VMRUNUIElkLCBBY2NvdW50SWQgRlJPTSBDb250YWN0IFdIRVJFIEFjY291bnRJZCBJTiA6YWNjb3VudElkc107YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQWx3YXlzIGNvbGxlY3QgSURzIGZpcnN0LCB0aGVuIHF1ZXJ5IG9uY2Ugb3V0c2lkZSB0aGUgbG9vcC4gVGhpcyBpcyBmdW5kYW1lbnRhbCB0byB3cml0aW5nIHNjYWxhYmxlIEFwZXguXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiR292ZXJub3IgbGltaXQgdmlvbGF0aW9ucyBkdWUgdG8gcXVlcmllcyBpbiBsb29wcyBhcmUgaGVhdmlseSB0ZXN0ZWQgb24gY2VydGlmaWNhdGlvbiBleGFtcy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA0LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hlbiBzaG91bGQgeW91IHVzZSBhIE1hcCBpbnN0ZWFkIG9mIGEgTGlzdD9cIixcbiAgICAgICAgYW5zd2VyOiBcIldoZW4geW91IG5lZWQgZmFzdCBsb29rdXBzIGJ5IGtleSBvciBuZWVkIHRvIGdyb3VwIHJlbGF0ZWQgZGF0YVwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJNYXBzIHByb3ZpZGUgTygxKSBsb29rdXAgcGVyZm9ybWFuY2UgdnMgTyhuKSBmb3IgTGlzdHMuIFVzZSBNYXBzIHdoZW4geW91IGZyZXF1ZW50bHkgbmVlZCB0byBmaW5kIGl0ZW1zIGJ5IGEgdW5pcXVlIGlkZW50aWZpZXIsIG9yIHdoZW4gZ3JvdXBpbmcgcmVsYXRlZCBvYmplY3RzIHRvZ2V0aGVyLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYC8vIEdvb2Q6IE1hcCBmb3IgZmFzdCBhY2NvdW50IGxvb2t1cFxuTWFwPElkLCBBY2NvdW50PiBhY2NvdW50TWFwID0gbmV3IE1hcDxJZCwgQWNjb3VudD4oW1NFTEVDVCBJZCwgTmFtZSBGUk9NIEFjY291bnRdKTtcbkFjY291bnQgZm91bmQgPSBhY2NvdW50TWFwLmdldChzb21lSWQpOyAgLy8gTygxKSBsb29rdXBcblxuLy8gQmFkOiBMaXN0IHJlcXVpcmVzIGxvb3AgZm9yIGxvb2t1cFxuTGlzdDxBY2NvdW50PiBhY2NvdW50cyA9IFtTRUxFQ1QgSWQsIE5hbWUgRlJPTSBBY2NvdW50XTtcbmZvciAoQWNjb3VudCBhY2MgOiBhY2NvdW50cykgeyAgLy8gTyhuKSBsb29rdXBcbiAgICBpZiAoYWNjLklkID09IHNvbWVJZCkgeyBmb3VuZCA9IGFjYzsgYnJlYWs7IH1cbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJNYXBzIGV4Y2VsIGF0IGtleS1iYXNlZCBsb29rdXBzIGFuZCBncm91cGluZy4gTGlzdHMgYXJlIGJldHRlciBmb3Igb3JkZXJlZCBkYXRhIGFuZCBpdGVyYXRpb24uXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiUGVyZm9ybWFuY2UgcXVlc3Rpb25zIGFib3V0IGRhdGEgc3RydWN0dXJlcyBhcHBlYXIgZnJlcXVlbnRseSBvbiBBcGV4IGNlcnRpZmljYXRpb24gZXhhbXMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcbiAgICAgICAgcXVlc3Rpb246IFwiWW91IGhhdmUgYSBMaXN0IHdpdGggMTAwLDAwMCByZWNvcmRzIGFuZCBuZWVkIHRvIGNoZWNrIGlmIGEgc3BlY2lmaWMgSUQgZXhpc3RzLiBXaGF0J3MgdGhlIHBlcmZvcm1hbmNlIGNvbmNlcm4gYW5kIHNvbHV0aW9uP1wiLFxuICAgICAgICBhbnN3ZXI6IFwiTGluZWFyIHNlYXJjaCBPKG4pIHBlcmZvcm1hbmNlIGlzc3VlLiBDb252ZXJ0IHRvIFNldCBvciBNYXAgZm9yIE8oMSkgbG9va3Vwcy5cIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiTGlzdHMgcmVxdWlyZSBzY2FubmluZyBldmVyeSBlbGVtZW50IHRvIGZpbmQgbWF0Y2hlcywgd2hpY2ggYmVjb21lcyBleHBlbnNpdmUgd2l0aCBsYXJnZSBkYXRhc2V0cy4gU2V0cyBhbmQgTWFwcyBwcm92aWRlIGhhc2gtYmFzZWQgbG9va3VwcyB0aGF0IGFyZSBkcmFtYXRpY2FsbHkgZmFzdGVyIGZvciBleGlzdGVuY2UgY2hlY2tzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYC8vIFByb2JsZW06IE8obikgbG9va3VwIC0gc2xvdyB3aXRoIGxhcmdlIGxpc3RzXG5MaXN0PElkPiBhY2NvdW50SWRzID0gbmV3IExpc3Q8SWQ+KC8qIDEwMCwwMDAgSURzICovKTtcbkJvb2xlYW4gZXhpc3RzID0gZmFsc2U7XG5mb3IgKElkIGFjY0lkIDogYWNjb3VudElkcykge1xuICAgIGlmIChhY2NJZCA9PSB0YXJnZXRJZCkgeyBleGlzdHMgPSB0cnVlOyBicmVhazsgfSAgLy8gUG90ZW50aWFsbHkgc2NhbnMgYWxsIDEwMEtcbn1cblxuLy8gU29sdXRpb24gMTogU2V0IGZvciBleGlzdGVuY2UgY2hlY2tzIC0gTygxKVxuU2V0PElkPiBhY2NvdW50SWRTZXQgPSBuZXcgU2V0PElkPihhY2NvdW50SWRzKTtcbkJvb2xlYW4gZXhpc3RzID0gYWNjb3VudElkU2V0LmNvbnRhaW5zKHRhcmdldElkKTsgIC8vIEZhc3QgbG9va3VwXG5cbi8vIFNvbHV0aW9uIDI6IE1hcCBpZiB5b3UgbmVlZCB0aGUgZGF0YSB0b28gLSBPKDEpXG5NYXA8SWQsIEFjY291bnQ+IGFjY291bnRNYXAgPSBuZXcgTWFwPElkLCBBY2NvdW50PihbU0VMRUNUIElkLCBOYW1lIEZST00gQWNjb3VudF0pO1xuQm9vbGVhbiBleGlzdHMgPSBhY2NvdW50TWFwLmNvbnRhaW5zS2V5KHRhcmdldElkKTtcbkFjY291bnQgZm91bmRBY2NvdW50ID0gYWNjb3VudE1hcC5nZXQodGFyZ2V0SWQpO2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlBlcmZvcm1hbmNlIHNjYWxlcyB3aXRoIGNvbGxlY3Rpb24gY2hvaWNlLiBVc2UgdGhlIHJpZ2h0IGRhdGEgc3RydWN0dXJlOiBMaXN0IGZvciBvcmRlciwgU2V0IGZvciB1bmlxdWVuZXNzLCBNYXAgZm9yIGtleS12YWx1ZSByZWxhdGlvbnNoaXBzLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlBlcmZvcm1hbmNlIHNjZW5hcmlvcyB3aXRoIGxhcmdlIGRhdGFzZXRzIGFyZSBjb21tb24gaW50ZXJ2aWV3IHF1ZXN0aW9ucy4gQWx3YXlzIHRoaW5rIGFib3V0IHRpbWUgY29tcGxleGl0eS5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA2LFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJFeHBsYWluIHdoZW4geW91J2QgdXNlIExpc3QgdnMgU2V0IHZzIE1hcCB3aXRoIHJlYWwgU2FsZXNmb3JjZSBzY2VuYXJpb3MuXCIsXG4gICAgICAgIGFuc3dlcjogXCJMaXN0IGZvciBvcmRlcmVkIHByb2Nlc3NpbmcsIFNldCBmb3IgZHVwbGljYXRlIHByZXZlbnRpb24sIE1hcCBmb3Iga2V5LWJhc2VkIHJlbGF0aW9uc2hpcHNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiRWFjaCBjb2xsZWN0aW9uIHR5cGUgc2VydmVzIHNwZWNpZmljIGJ1c2luZXNzIG5lZWRzIGluIFNhbGVzZm9yY2UuIFVuZGVyc3RhbmRpbmcgd2hlbiB0byB1c2UgZWFjaCBwcmV2ZW50cyBwZXJmb3JtYW5jZSBpc3N1ZXMgYW5kIG1ha2VzIGNvZGUgbW9yZSBtYWludGFpbmFibGUuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gTGlzdDogV2hlbiBvcmRlciBtYXR0ZXJzIGFuZCBkdXBsaWNhdGVzIGFyZSBPS1xuTGlzdDxUYXNrPiB0YXNrSGlzdG9yeSA9IFtTRUxFQ1QgSWQsIFN1YmplY3QgRlJPTSBUYXNrIFdIRVJFIEFjY291bnRJZCA9IDphY2NJZCBPUkRFUiBCWSBDcmVhdGVkRGF0ZV07XG5mb3IgKFRhc2sgdCA6IHRhc2tIaXN0b3J5KSB7XG4gICAgLy8gUHJvY2VzcyBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyXG59XG5cbi8vIFNldDogV2hlbiB5b3UgbmVlZCB1bmlxdWUgdmFsdWVzIG9ubHlcblNldDxTdHJpbmc+IHVuaXF1ZUluZHVzdHJpZXMgPSBuZXcgU2V0PFN0cmluZz4oKTtcbmZvciAoQWNjb3VudCBhY2MgOiBhY2NvdW50cykge1xuICAgIHVuaXF1ZUluZHVzdHJpZXMuYWRkKGFjYy5JbmR1c3RyeSk7ICAvLyBBdXRvbWF0aWNhbGx5IHByZXZlbnRzIGR1cGxpY2F0ZXNcbn1cblxuLy8gTWFwOiBXaGVuIHlvdSBuZWVkIGZhc3QgbG9va3VwcyBvciBncm91cGluZ1xuTWFwPElkLCBMaXN0PENvbnRhY3Q+PiBjb250YWN0c0J5QWNjb3VudCA9IG5ldyBNYXA8SWQsIExpc3Q8Q29udGFjdD4+KCk7XG5mb3IgKENvbnRhY3QgY29uIDogY29udGFjdHMpIHtcbiAgICBpZiAoIWNvbnRhY3RzQnlBY2NvdW50LmNvbnRhaW5zS2V5KGNvbi5BY2NvdW50SWQpKSB7XG4gICAgICAgIGNvbnRhY3RzQnlBY2NvdW50LnB1dChjb24uQWNjb3VudElkLCBuZXcgTGlzdDxDb250YWN0PigpKTtcbiAgICB9XG4gICAgY29udGFjdHNCeUFjY291bnQuZ2V0KGNvbi5BY2NvdW50SWQpLmFkZChjb24pO1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkNvbGxlY3Rpb24gY2hvaWNlIGRyaXZlcyBwZXJmb3JtYW5jZSBhbmQgZnVuY3Rpb25hbGl0eS4gTGlzdCA9IG9yZGVyLCBTZXQgPSB1bmlxdWVuZXNzLCBNYXAgPSByZWxhdGlvbnNoaXBzLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlNjZW5hcmlvLWJhc2VkIHF1ZXN0aW9ucyB0ZXN0IHByYWN0aWNhbCB1bmRlcnN0YW5kaW5nLiBUaGluayBhYm91dCB0aGUgYnVzaW5lc3MgcmVxdWlyZW1lbnQgZmlyc3QuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcbiAgICAgICAgcXVlc3Rpb246IFwiQ29kZSByZXZpZXc6ICdmb3IoQWNjb3VudCBhIDogYWNjb3VudHMpIHsgZm9yKENvbnRhY3QgYyA6IGNvbnRhY3RzKSB7IGlmKGMuQWNjb3VudElkID09IGEuSWQpIHsuLi59IH0gfScgLSB3aGF0J3Mgd3Jvbmc/XCIsXG4gICAgICAgIGFuc3dlcjogXCJPKG7CsikgcGVyZm9ybWFuY2UgcHJvYmxlbS4gVXNlIE1hcCBmb3IgTyhuKSBzb2x1dGlvbi5cIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiTmVzdGVkIGxvb3BzIGNyZWF0ZSBxdWFkcmF0aWMgdGltZSBjb21wbGV4aXR5LiBXaXRoIDIwMCBhY2NvdW50cyBhbmQgMTAwMCBjb250YWN0cywgdGhpcyBwZXJmb3JtcyAyMDAsMDAwIGNvbXBhcmlzb25zIGluc3RlYWQgb2YgdGhlIDEsMjAwIG5lZWRlZCB3aXRoIHByb3BlciBkYXRhIHN0cnVjdHVyZXMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gV3Jvbmc6IE8obsKyKSAtIDIwMCBhY2NvdW50cyDDlyAxMDAwIGNvbnRhY3RzID0gMjAwLDAwMCBvcGVyYXRpb25zXG5mb3IgKEFjY291bnQgYSA6IGFjY291bnRzKSB7XG4gICAgZm9yIChDb250YWN0IGMgOiBjb250YWN0cykge1xuICAgICAgICBpZiAoYy5BY2NvdW50SWQgPT0gYS5JZCkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyAtIGJ1dCB0aGlzIGlzIFZFUlkgc2xvd1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBSaWdodDogTyhuKSAtIEdyb3VwIGNvbnRhY3RzIGZpcnN0LCB0aGVuIGxvb2t1cFxuTWFwPElkLCBMaXN0PENvbnRhY3Q+PiBjb250YWN0c0J5QWNjb3VudCA9IG5ldyBNYXA8SWQsIExpc3Q8Q29udGFjdD4+KCk7XG5mb3IgKENvbnRhY3QgYyA6IGNvbnRhY3RzKSB7ICAvLyBPKG4pIC0gMTAwMCBvcGVyYXRpb25zXG4gICAgaWYgKCFjb250YWN0c0J5QWNjb3VudC5jb250YWluc0tleShjLkFjY291bnRJZCkpIHtcbiAgICAgICAgY29udGFjdHNCeUFjY291bnQucHV0KGMuQWNjb3VudElkLCBuZXcgTGlzdDxDb250YWN0PigpKTtcbiAgICB9XG4gICAgY29udGFjdHNCeUFjY291bnQuZ2V0KGMuQWNjb3VudElkKS5hZGQoYyk7XG59XG5cbmZvciAoQWNjb3VudCBhIDogYWNjb3VudHMpIHsgIC8vIE8obikgLSAyMDAgb3BlcmF0aW9uc1xuICAgIExpc3Q8Q29udGFjdD4gYWNjb3VudENvbnRhY3RzID0gY29udGFjdHNCeUFjY291bnQuZ2V0KGEuSWQpO1xuICAgIGlmIChhY2NvdW50Q29udGFjdHMgIT0gbnVsbCkge1xuICAgICAgICAvLyBQcm9jZXNzIGNvbnRhY3RzIGZvciB0aGlzIGFjY291bnRcbiAgICB9XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQXZvaWQgbmVzdGVkIGxvb3BzIHdpdGggbGFyZ2UgZGF0YXNldHMuIEdyb3VwIGRhdGEgd2l0aCBNYXBzIHRvIGNvbnZlcnQgTyhuwrIpIHRvIE8obikgb3BlcmF0aW9ucy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJQZXJmb3JtYW5jZSBhbnRpLXBhdHRlcm5zIGFyZSBoZWF2aWx5IHRlc3RlZC4gTmVzdGVkIGxvb3BzID0gcmVkIGZsYWcgZm9yIG9wdGltaXphdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA4LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiWW91IG5lZWQgdG8gZ3JvdXAgQ29udGFjdHMgYnkgQWNjb3VudElkIGVmZmljaWVudGx5LiBXYWxrIG1lIHRocm91Z2ggeW91ciBhcHByb2FjaC5cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBNYXA8SWQsIExpc3Q8Q29udGFjdD4+IHRvIGdyb3VwIHJlbGF0ZWQgcmVjb3JkcyBpbiBhIHNpbmdsZSBwYXNzXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkdyb3VwaW5nIGlzIGEgY29tbW9uIHBhdHRlcm4gaW4gU2FsZXNmb3JjZS4gVGhlIGtleSBpcyB0byBpdGVyYXRlIG9uY2UgYW5kIGJ1aWxkIHRoZSBncm91cGVkIHN0cnVjdHVyZSwgYXZvaWRpbmcgbXVsdGlwbGUgbG9va3VwcyBvciBuZXN0ZWQgbG9vcHMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIE1hcDxJZCwgTGlzdDxDb250YWN0Pj4gZ3JvdXBDb250YWN0c0J5QWNjb3VudChMaXN0PENvbnRhY3Q+IGNvbnRhY3RzKSB7XG4gICAgTWFwPElkLCBMaXN0PENvbnRhY3Q+PiBjb250YWN0c0J5QWNjb3VudCA9IG5ldyBNYXA8SWQsIExpc3Q8Q29udGFjdD4+KCk7XG5cbiAgICBmb3IgKENvbnRhY3QgY29uIDogY29udGFjdHMpIHtcbiAgICAgICAgLy8gU2tpcCBjb250YWN0cyB3aXRob3V0IEFjY291bnRJZFxuICAgICAgICBpZiAoY29uLkFjY291bnRJZCA9PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIGxpc3QgaWYgZmlyc3QgY29udGFjdCBmb3IgdGhpcyBhY2NvdW50XG4gICAgICAgIGlmICghY29udGFjdHNCeUFjY291bnQuY29udGFpbnNLZXkoY29uLkFjY291bnRJZCkpIHtcbiAgICAgICAgICAgIGNvbnRhY3RzQnlBY2NvdW50LnB1dChjb24uQWNjb3VudElkLCBuZXcgTGlzdDxDb250YWN0PigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjb250YWN0IHRvIHRoZSBhY2NvdW50J3MgbGlzdFxuICAgICAgICBjb250YWN0c0J5QWNjb3VudC5nZXQoY29uLkFjY291bnRJZCkuYWRkKGNvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhY3RzQnlBY2NvdW50O1xufVxuXG4vLyBVc2FnZSBleGFtcGxlXG5NYXA8SWQsIExpc3Q8Q29udGFjdD4+IGdyb3VwZWQgPSBncm91cENvbnRhY3RzQnlBY2NvdW50KGFsbENvbnRhY3RzKTtcbmZvciAoSWQgYWNjb3VudElkIDogZ3JvdXBlZC5rZXlTZXQoKSkge1xuICAgIExpc3Q8Q29udGFjdD4gYWNjb3VudENvbnRhY3RzID0gZ3JvdXBlZC5nZXQoYWNjb3VudElkKTtcbiAgICBTeXN0ZW0uZGVidWcoJ0FjY291bnQgJyArIGFjY291bnRJZCArICcgaGFzICcgKyBhY2NvdW50Q29udGFjdHMuc2l6ZSgpICsgJyBjb250YWN0cycpO1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkdyb3VwaW5nIHBhdHRlcm46IE1hcDxLZXlUeXBlLCBMaXN0PFZhbHVlVHlwZT4+LiBJdGVyYXRlIG9uY2UsIGNoZWNrIGlmIGtleSBleGlzdHMsIGluaXRpYWxpemUgbGlzdCwgYWRkIGl0ZW0uXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiR3JvdXBpbmcgcXVlc3Rpb25zIGFyZSBjb21tb24uIE1hc3RlciB0aGlzIHBhdHRlcm46IGl0J3MgdXNlZCBldmVyeXdoZXJlIGluIFNhbGVzZm9yY2UgZGV2ZWxvcG1lbnQuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogOSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiQSBMaXN0IG1pZ2h0IGNvbnRhaW4gbnVsbHMgYW5kIGR1cGxpY2F0ZXMuIFdyaXRlIGNvZGUgdG8gY2xlYW4gaXQgdXAgc2FmZWx5LlwiLFxuICAgICAgICBhbnN3ZXI6IFwiVXNlIFNldCBmb3IgZGVkdXBsaWNhdGlvbiBhbmQgbnVsbCBjaGVja3MgZm9yIGNsZWFuaW5nXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIlJlYWwtd29ybGQgZGF0YSBvZnRlbiBjb250YWlucyBudWxscyBhbmQgZHVwbGljYXRlcy4gQ2xlYW5pbmcgY29sbGVjdGlvbnMgc2FmZWx5IHJlcXVpcmVzIGhhbmRsaW5nIGJvdGggaXNzdWVzIHdpdGhvdXQgY2F1c2luZyBleGNlcHRpb25zLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBMaXN0PFN0cmluZz4gY2xlYW5TdHJpbmdMaXN0KExpc3Q8U3RyaW5nPiBpbnB1dExpc3QpIHtcbiAgICBpZiAoaW5wdXRMaXN0ID09IG51bGwgfHwgaW5wdXRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gbmV3IExpc3Q8U3RyaW5nPigpO1xuICAgIH1cblxuICAgIFNldDxTdHJpbmc+IHVuaXF1ZVZhbHVlcyA9IG5ldyBTZXQ8U3RyaW5nPigpO1xuXG4gICAgZm9yIChTdHJpbmcgaXRlbSA6IGlucHV0TGlzdCkge1xuICAgICAgICAvLyBTa2lwIG51bGwgYW5kIGJsYW5rIHZhbHVlc1xuICAgICAgICBpZiAoU3RyaW5nLmlzTm90QmxhbmsoaXRlbSkpIHtcbiAgICAgICAgICAgIC8vIFNldCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgZHVwbGljYXRlc1xuICAgICAgICAgICAgdW5pcXVlVmFsdWVzLmFkZChpdGVtLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGJhY2sgdG8gTGlzdCBpZiBvcmRlciBtYXR0ZXJzIGZvciBjYWxsZXJcbiAgICByZXR1cm4gbmV3IExpc3Q8U3RyaW5nPih1bmlxdWVWYWx1ZXMpO1xufVxuXG4vLyBVc2FnZVxuTGlzdDxTdHJpbmc+IGRpcnR5TGlzdCA9IG5ldyBMaXN0PFN0cmluZz57J0pvaG4nLCBudWxsLCAnSmFuZScsICdKb2huJywgJyAgJywgJ0JvYid9O1xuTGlzdDxTdHJpbmc+IGNsZWFuTGlzdCA9IGNsZWFuU3RyaW5nTGlzdChkaXJ0eUxpc3QpO1xuLy8gUmVzdWx0OiBbJ0pvaG4nLCAnSmFuZScsICdCb2InXSAtIG5vIG51bGxzLCBubyBkdXBsaWNhdGVzLCB0cmltbWVkYCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQ29sbGVjdGlvbiBjbGVhbmluZzogbnVsbCBjaGVja3MgcHJldmVudCBleGNlcHRpb25zLCBTZXRzIHJlbW92ZSBkdXBsaWNhdGVzIGF1dG9tYXRpY2FsbHkuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiRGF0YSB2YWxpZGF0aW9uIHNjZW5hcmlvcyBhcmUgZnJlcXVlbnQuIEFsd2F5cyBoYW5kbGUgbnVsbCBpbnB1dCBncmFjZWZ1bGx5LlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDEwLFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiWW91J3JlIHByb2Nlc3NpbmcgT3Bwb3J0dW5pdHkgZGF0YSBhbmQgbmVlZCBmYXN0IGxvb2t1cHMgYnkgU3RhZ2UuIFdoYXQgY29sbGVjdGlvbiBzdHJhdGVneSBkbyB5b3UgdXNlP1wiLFxuICAgICAgICBhbnN3ZXI6IFwiTWFwPFN0cmluZywgTGlzdDxPcHBvcnR1bml0eT4+IHRvIGdyb3VwIGJ5IHN0YWdlIHdpdGggZmFzdCBhY2Nlc3NcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiQnVzaW5lc3MgcmVwb3J0aW5nIG9mdGVuIHJlcXVpcmVzIGdyb3VwaW5nIHJlY29yZHMgYnkgZmllbGQgdmFsdWVzLiBNYXBzIHByb3ZpZGUgYm90aCBmYXN0IGFjY2VzcyBhbmQgbG9naWNhbCBncm91cGluZyBmb3IgYW5hbHlzaXMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIE1hcDxTdHJpbmcsIExpc3Q8T3Bwb3J0dW5pdHk+PiBncm91cE9wcG9ydHVuaXRpZXNCeVN0YWdlKExpc3Q8T3Bwb3J0dW5pdHk+IG9wcHMpIHtcbiAgICBNYXA8U3RyaW5nLCBMaXN0PE9wcG9ydHVuaXR5Pj4gb3Bwc0J5U3RhZ2UgPSBuZXcgTWFwPFN0cmluZywgTGlzdDxPcHBvcnR1bml0eT4+KCk7XG5cbiAgICBmb3IgKE9wcG9ydHVuaXR5IG9wcCA6IG9wcHMpIHtcbiAgICAgICAgU3RyaW5nIHN0YWdlID0gb3BwLlN0YWdlTmFtZSA/PyAnVW5rbm93bic7ICAvLyBIYW5kbGUgbnVsbCBzdGFnZXNcblxuICAgICAgICBpZiAoIW9wcHNCeVN0YWdlLmNvbnRhaW5zS2V5KHN0YWdlKSkge1xuICAgICAgICAgICAgb3Bwc0J5U3RhZ2UucHV0KHN0YWdlLCBuZXcgTGlzdDxPcHBvcnR1bml0eT4oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHBzQnlTdGFnZS5nZXQoc3RhZ2UpLmFkZChvcHApO1xuICAgIH1cblxuICAgIHJldHVybiBvcHBzQnlTdGFnZTtcbn1cblxuLy8gQnVzaW5lc3MgbG9naWMgdXNhZ2Vcbk1hcDxTdHJpbmcsIExpc3Q8T3Bwb3J0dW5pdHk+PiBvcHBzQnlTdGFnZSA9IGdyb3VwT3Bwb3J0dW5pdGllc0J5U3RhZ2Uob3Bwb3J0dW5pdGllcyk7XG5cbi8vIEZhc3QgYW5hbHlzaXNcbkxpc3Q8T3Bwb3J0dW5pdHk+IGNsb3NlZFdvbiA9IG9wcHNCeVN0YWdlLmdldCgnQ2xvc2VkIFdvbicpO1xuTGlzdDxPcHBvcnR1bml0eT4gbmVnb3RpYXRpb24gPSBvcHBzQnlTdGFnZS5nZXQoJ05lZ290aWF0aW9uL1JldmlldycpO1xuXG5TeXN0ZW0uZGVidWcoJ0Nsb3NlZCBXb24gY291bnQ6ICcgKyAoY2xvc2VkV29uPy5zaXplKCkgPz8gMCkpO1xuU3lzdGVtLmRlYnVnKCdJbiBOZWdvdGlhdGlvbjogJyArIChuZWdvdGlhdGlvbj8uc2l6ZSgpID8/IDApKTtgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJHcm91cGluZyBlbmFibGVzIGZhc3QgYnVzaW5lc3MgYW5hbHlzaXMuIE1hcCBzdHJ1Y3R1cmUgbWlycm9ycyBidXNpbmVzcyBsb2dpYyBmb3IgaW50dWl0aXZlIGFjY2Vzcy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJCdXNpbmVzcyBzY2VuYXJpbyBxdWVzdGlvbnMgdGVzdCBwcmFjdGljYWwgYXBwbGljYXRpb24uIFRoaW5rIGFib3V0IGhvdyBidXNpbmVzcyB1c2VycyB3b3VsZCB3YW50IHRvIGFjY2VzcyB0aGUgZGF0YS5cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcblxuICAnY29udHJvbC1mbG93LWFuZC1sb29wcyc6IHtcbiAgICB0aXRsZTogJ0NvbnRyb2wgRmxvdyBhbmQgTG9vcHMnLFxuICAgIG92ZXJ2aWV3OiAnTWFzdGVyIGRlY2lzaW9uLW1ha2luZyBpbiB5b3VyIGNvZGUuIE5vdyB0aGF0IHlvdSBoYXZlIFZhcmlhYmxlcyAoc2luZ2xlIHZhbHVlcykgYW5kIENvbGxlY3Rpb25zIChtdWx0aXBsZSB2YWx1ZXMpLCBsZWFybiB0byBtYWtlIERFQ0lTSU9OUyBhYm91dCB0aGF0IGRhdGEuIENvbnRyb2wgZmxvdyBpcyB3aGVyZSBidXNpbmVzcyBsb2dpYyBsaXZlcyAtIGV2ZXJ5IFwiaWYgdGhpcyB0aGVuIHRoYXRcIiBydWxlIGluIFNhbGVzZm9yY2UuIFRoaXMgZGlyZWN0bHkgbGVhZHMgdG8gQ2xhc3NlcyAob3JnYW5pemluZyBkZWNpc2lvbiBsb2dpYykgYW5kIFRyaWdnZXJzIChhdXRvbWF0ZWQgZGVjaXNpb25zKS4nLFxuICAgIGNvZGVFeGFtcGxlczogW1xuICAgICAge1xuICAgICAgICB0aXRsZTogJ0RlY2lzaW9uIE1ha2luZyB3aXRoIEJ1c2luZXNzIExvZ2ljJyxcbiAgICAgICAgY29kZTogYHB1YmxpYyBjbGFzcyBDb250cm9sRmxvd0RlbW8ge1xuICAgIC8vIOKchSBCVUlMRElORyBPTjogQ29sbGVjdGlvbnMgZnJvbSBwcmV2aW91cyB0b3BpY1xuICAgIHB1YmxpYyB2b2lkIHByb2Nlc3NMZWFkcyhMaXN0PExlYWQ+IGxlYWRzKSB7XG4gICAgICAgIC8vIOKchSBORVcgQ09OQ0VQVDogRGVjaXNpb24gbWFraW5nIHdpdGggY29sbGVjdGVkIGRhdGFcbiAgICAgICAgTGlzdDxMZWFkPiBob3RMZWFkcyA9IG5ldyBMaXN0PExlYWQ+KCk7XG4gICAgICAgIExpc3Q8TGVhZD4gY29sZExlYWRzID0gbmV3IExpc3Q8TGVhZD4oKTtcblxuICAgICAgICAvLyDinIUgRU5IQU5DRUQgRk9SIExPT1A6IFByb2Nlc3MgZWFjaCBpdGVtIGluIGNvbGxlY3Rpb25cbiAgICAgICAgZm9yIChMZWFkIGxlYWQgOiBsZWFkcykge1xuICAgICAgICAgICAgLy8g4pyFIENPTk5FQ1RJT046IFNhbWUgZm9yIGxvb3AgcGF0dGVybiB5b3UnbGwgdXNlIGV2ZXJ5d2hlcmVcbiAgICAgICAgICAgIC8vIOKchSBXSFkgZW5oYW5jZWQgZm9yOiBTYWZlciB0aGFuIGluZGV4IGxvb3BzLCBubyBvdXQtb2YtYm91bmRzXG5cbiAgICAgICAgICAgIC8vIOKchSBDT05ESVRJT05BTCBMT0dJQzogQnVzaW5lc3MgZGVjaXNpb24gbWFraW5nXG4gICAgICAgICAgICBpZiAobGVhZC5Bbm51YWxSZXZlbnVlICE9IG51bGwgJiYgbGVhZC5Bbm51YWxSZXZlbnVlID4gMTAwMDAwMCkge1xuICAgICAgICAgICAgICAgIC8vIOKchSBOVUxMIFNBRkVUWTogQWx3YXlzIGNoZWNrIG51bGwgZmlyc3QgKGZyb20gVmFyaWFibGVzIHRvcGljKVxuICAgICAgICAgICAgICAgIC8vIOKchSBCVVNJTkVTUyBMT0dJQzogQ2F0ZWdvcml6ZSBoaWdoLXZhbHVlIHByb3NwZWN0c1xuICAgICAgICAgICAgICAgIGhvdExlYWRzLmFkZChsZWFkKTtcblxuICAgICAgICAgICAgICAgIC8vIOKchSBORVNURUQgQ09ORElUSU9OUzogTW9yZSBjb21wbGV4IGRlY2lzaW9uIHRyZWVzXG4gICAgICAgICAgICAgICAgaWYgKGxlYWQuSW5kdXN0cnkgPT0gJ1RlY2hub2xvZ3knKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQuUmF0aW5nID0gJ0hvdCc7XG4gICAgICAgICAgICAgICAgICAgIC8vIOKchSBDT05ORUNUSU9OOiBUaGlzIHBhdHRlcm4gY3J1Y2lhbCBpbiBUcmlnZ2VycyB0b3BpY1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVhZC5Bbm51YWxSZXZlbnVlICE9IG51bGwgJiYgbGVhZC5Bbm51YWxSZXZlbnVlID4gMTAwMDAwKSB7XG4gICAgICAgICAgICAgICAgLy8g4pyFIEVMU0UgSUY6IEhhbmRsZSBtdWx0aXBsZSBjb25kaXRpb25zIGVmZmljaWVudGx5XG4gICAgICAgICAgICAgICAgbGVhZC5SYXRpbmcgPSAnV2FybSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIOKchSBFTFNFOiBDYXRjaC1hbGwgZm9yIHJlbWFpbmluZyBjYXNlc1xuICAgICAgICAgICAgICAgIGNvbGRMZWFkcy5hZGQobGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDinIUgQ09ORElUSU9OQUwgUFJPQ0VTU0lORzogT25seSBhY3QgaWYgZGF0YSBleGlzdHNcbiAgICAgICAgaWYgKCFob3RMZWFkcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIC8vIPCfkqEgTkVYVCBUT1BJQzogWW91J2xsIG9yZ2FuaXplIHRoaXMgbG9naWMgaW50byBDbGFzc2VzXG4gICAgICAgICAgICBwcm9jZXNzSG90TGVhZHMoaG90TGVhZHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2b2lkIHByb2Nlc3NIb3RMZWFkcyhMaXN0PExlYWQ+IGxlYWRzKSB7XG4gICAgICAgIGZvciAoTGVhZCBsZWFkIDogbGVhZHMpIHtcbiAgICAgICAgICAgIGxlYWQuU3RhdHVzID0gJ1dvcmtpbmcgLSBDb250YWN0ZWQnO1xuICAgICAgICB9XG4gICAgfVxufWAsXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnQWx3YXlzIGNoZWNrIGZvciBudWxsIGJlZm9yZSBjb21wYXJpbmcgdmFsdWVzLiBVc2UgZXhwbGljaXQgYm9vbGVhbiBjb21wYXJpc29ucyAoPT0gdHJ1ZSkgZm9yIG51bGwtc2FmZSBsb2dpYyB3aXRoIEJvb2xlYW4gZmllbGRzIHRoYXQgY2FuIGJlIG51bGwuJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdTd2l0Y2ggU3RhdGVtZW50cyBhbmQgQWR2YW5jZWQgUGF0dGVybnMnLFxuICAgICAgICBjb2RlOiBgcHVibGljIGNsYXNzIFN3aXRjaFBhdHRlcm5zIHtcbiAgICAvLyDinIUgU1dJVENIIFNUQVRFTUVOVDogQ2xlYW4gbXVsdGlwbGUgZXhhY3QgY29tcGFyaXNvbnNcbiAgICBwdWJsaWMgU3RyaW5nIGNhdGVnb3JpemVCeVNvdXJjZShMZWFkIGxlYWQpIHtcbiAgICAgICAgLy8g4pyFIFdIRU4gVE8gVVNFOiBNdWx0aXBsZSBleGFjdCB2YWx1ZSBjb21wYXJpc29ucyAobm90IHJhbmdlcylcbiAgICAgICAgc3dpdGNoIG9uIGxlYWQuTGVhZFNvdXJjZSB7XG4gICAgICAgICAgICB3aGVuICdXZWInIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0RpZ2l0YWwgTWFya2V0aW5nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoZW4gJ1Bob25lIElucXVpcnknLCAnQ29sZCBDYWxsJyB7XG4gICAgICAgICAgICAgICAgLy8g4pyFIE1VTFRJUExFIFZBTFVFUzogQ29tbWEtc2VwYXJhdGVkIGluIHNpbmdsZSBjYXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICdEaXJlY3QgU2FsZXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hlbiAnUGFydG5lciBSZWZlcnJhbCcge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ2hhbm5lbCBQYXJ0bmVycyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGVuIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIOKchSBERUZBVUxUIENBU0U6IEhhbmRsZSB1bm1hdGNoZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgcmV0dXJuICdVbmtub3duIFNvdXJjZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g8J+SoSBORVhUIFRPUElDOiBUaGlzIGRlY2lzaW9uIGxvZ2ljIHdpbGwgYmUgcmV1c2VkIGluIENsYXNzZXNcbiAgICB9XG5cbiAgICAvLyDinIUgRUFSTFkgRVhJVCBQQVRURVJOUzogSW1wcm92ZSBwZXJmb3JtYW5jZVxuICAgIHB1YmxpYyB2b2lkIHByb2Nlc3NPcHBvcnR1bml0aWVzKExpc3Q8T3Bwb3J0dW5pdHk+IG9wcHMpIHtcbiAgICAgICAgZm9yIChPcHBvcnR1bml0eSBvcHAgOiBvcHBzKSB7XG4gICAgICAgICAgICAvLyDinIUgR1VBUkQgQ0xBVVNFOiBFYXJseSBleGl0IGZvciBpbnZhbGlkIGRhdGFcbiAgICAgICAgICAgIGlmIChvcHAuQW1vdW50ID09IG51bGwgfHwgb3BwLkFtb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g4pyFIEJVU0lORVNTIExPR0lDOiBPbmx5IHByb2Nlc3MgdmFsaWQgb3Bwb3J0dW5pdGllc1xuICAgICAgICAgICAgaWYgKG9wcC5TdGFnZU5hbWUgPT0gJ0Nsb3NlZCBXb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB3b24gb3Bwb3J0dW5pdHlcbiAgICAgICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ1Byb2Nlc3Npbmcgd29uIG9wcDogJyArIG9wcC5BbW91bnQpO1xuXG4gICAgICAgICAgICAgICAgLy8g4pyFIEJSRUFLOiBFeGl0IGxvb3AgaWYgd2UgZm91bmQgd2hhdCB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgaWYgKG9wcC5BbW91bnQgPiAxMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnRm91bmQgbGFyZ2UgZGVhbCwgc3RvcHBpbmcgc2VhcmNoJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0Nob29zZSB0aGUgcmlnaHQgbG9vcCB0eXBlOiBlbmhhbmNlZCBmb3Igd2hlbiBwcm9jZXNzaW5nIGFsbCBlbGVtZW50cywgdHJhZGl0aW9uYWwgZm9yIHdoZW4geW91IG5lZWQgaW5kZXhlcywgd2hpbGUgd2hlbiB0aGUgaXRlcmF0aW9uIGNvdW50IGRlcGVuZHMgb24gY29uZGl0aW9ucy4nXG4gICAgICB9XG4gICAgXSxcbiAgICBwcmFjdGljZVF1ZXN0aW9uczogW1xuICAgICAge1xuICAgICAgICBudW1iZXI6IDEsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhZHZhbmNlZCcsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSBzZWUgbmVzdGVkIGZvciBsb29wcyBwcm9jZXNzaW5nIDEwMDArIHJlY29yZHMgaW4gYSB0cmlnZ2VyLiBXaGF0J3MgdGhlIHBlcmZvcm1hbmNlIGlzc3VlIGFuZCBob3cgZG8geW91IGZpeCBpdD9cIixcbiAgICAgICAgYW5zd2VyOiBcIk8obsKyKSBjb21wbGV4aXR5IGNhdXNpbmcgQ1BVIHRpbWVvdXQuIFVzZSBNYXBzIHRvIGZsYXR0ZW4gdG8gTyhuKS5cIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiTmVzdGVkIGxvb3BzIGNyZWF0ZSBxdWFkcmF0aWMgdGltZSBjb21wbGV4aXR5LiBXaXRoIDEwMDAgcmVjb3JkcywgdGhpcyBtZWFucyAxLDAwMCwwMDAgb3BlcmF0aW9ucy4gVGhpcyBxdWlja2x5IGhpdHMgQ1BVIHRpbWVvdXQgbGltaXRzIGluIFNhbGVzZm9yY2UuIFRoZSBzb2x1dGlvbiBpcyB0byB1c2UgTWFwcyBmb3IgZ3JvdXBpbmcgZGF0YS5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBXcm9uZzogTyhuwrIpIC0gMTAwMCDDlyAxMDAwID0gMSwwMDAsMDAwIG9wZXJhdGlvbnNcbmZvciAoQWNjb3VudCBhY2MgOiBhY2NvdW50cykge1xuICAgIGZvciAoQ29udGFjdCBjb24gOiBjb250YWN0cykge1xuICAgICAgICBpZiAoY29uLkFjY291bnRJZCA9PSBhY2MuSWQpIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgLSBidXQgVkVSWSBzbG93XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFJpZ2h0OiBPKG4pIC0gR3JvdXAgZmlyc3QsIHRoZW4gcHJvY2Vzc1xuTWFwPElkLCBMaXN0PENvbnRhY3Q+PiBjb250YWN0c0J5QWNjb3VudCA9IG5ldyBNYXA8SWQsIExpc3Q8Q29udGFjdD4+KCk7XG5mb3IgKENvbnRhY3QgY29uIDogY29udGFjdHMpIHsgIC8vIDEwMDAgb3BlcmF0aW9uc1xuICAgIGlmICghY29udGFjdHNCeUFjY291bnQuY29udGFpbnNLZXkoY29uLkFjY291bnRJZCkpIHtcbiAgICAgICAgY29udGFjdHNCeUFjY291bnQucHV0KGNvbi5BY2NvdW50SWQsIG5ldyBMaXN0PENvbnRhY3Q+KCkpO1xuICAgIH1cbiAgICBjb250YWN0c0J5QWNjb3VudC5nZXQoY29uLkFjY291bnRJZCkuYWRkKGNvbik7XG59XG5cbmZvciAoQWNjb3VudCBhY2MgOiBhY2NvdW50cykgeyAgLy8gMTAwMCBtb3JlIG9wZXJhdGlvbnNcbiAgICBMaXN0PENvbnRhY3Q+IHJlbGF0ZWRDb250YWN0cyA9IGNvbnRhY3RzQnlBY2NvdW50LmdldChhY2MuSWQpO1xuICAgIC8vIFByb2Nlc3MgZWZmaWNpZW50bHlcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJOZXN0ZWQgbG9vcHMgYXJlIGEgcGVyZm9ybWFuY2Uga2lsbGVyLiBBbHdheXMgZmxhdHRlbiB0byBzaW5nbGUgbG9vcHMgd2l0aCBNYXBzIGZvciBncm91cGluZy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gcXVlc3Rpb25zIGFyZSBjb21tb24uIE5lc3RlZCBsb29wcyA9IGltbWVkaWF0ZSByZWQgZmxhZyBmb3IgTyhuwrIpIGNvbXBsZXhpdHkuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMixcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkEgZGV2ZWxvcGVyIHVzZXMgYGlmIChsZWFkLkNvbXBhbnkuc3RhcnRzV2l0aCgnQWNtZScpKWAgLSB3aGF0IGNvdWxkIGdvIHdyb25nIGFuZCBob3cgZG8geW91IGZpeCBpdD9cIixcbiAgICAgICAgYW5zd2VyOiBcIk51bGxQb2ludGVyRXhjZXB0aW9uIGlmIENvbXBhbnkgaXMgbnVsbC4gVXNlIG51bGwtc2FmZSBuYXZpZ2F0aW9uLlwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJGaWVsZCB2YWx1ZXMgaW4gU2FsZXNmb3JjZSBjYW4gYmUgbnVsbC4gQ2FsbGluZyBtZXRob2RzIGRpcmVjdGx5IG9uIHBvdGVudGlhbGx5IG51bGwgZmllbGRzIHRocm93cyBOdWxsUG9pbnRlckV4Y2VwdGlvbiBhdCBydW50aW1lLiBBbHdheXMgY2hlY2sgZm9yIG51bGwgZmlyc3Qgb3IgdXNlIHNhZmUgbmF2aWdhdGlvbi5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBXcm9uZyAtIHRocm93cyBOUEUgaWYgQ29tcGFueSBpcyBudWxsXG5pZiAobGVhZC5Db21wYW55LnN0YXJ0c1dpdGgoJ0FjbWUnKSkge1xuICAgIC8vIFByb2Nlc3Ncbn1cblxuLy8gT3B0aW9uIDE6IFRyYWRpdGlvbmFsIG51bGwgY2hlY2tcbmlmIChsZWFkLkNvbXBhbnkgIT0gbnVsbCAmJiBsZWFkLkNvbXBhbnkuc3RhcnRzV2l0aCgnQWNtZScpKSB7XG4gICAgLy8gUHJvY2VzcyBzYWZlbHlcbn1cblxuLy8gT3B0aW9uIDI6IFNhZmUgbmF2aWdhdGlvbiAobW9kZXJuIEFwZXgpXG5pZiAobGVhZC5Db21wYW55Py5zdGFydHNXaXRoKCdBY21lJykgPT0gdHJ1ZSkge1xuICAgIC8vIFByb2Nlc3Mgc2FmZWx5XG59XG5cbi8vIE9wdGlvbiAzOiBOdWxsLWNvYWxlc2NpbmcgZm9yIGRlZmF1bHRcblN0cmluZyBjb21wYW55ID0gbGVhZC5Db21wYW55ID8/ICcnO1xuaWYgKGNvbXBhbnkuc3RhcnRzV2l0aCgnQWNtZScpKSB7XG4gICAgLy8gUHJvY2VzcyBzYWZlbHlcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJBbHdheXMgYXNzdW1lIFNhbGVzZm9yY2UgZmllbGRzIGNhbiBiZSBudWxsLiBVc2UgbnVsbCBjaGVja3Mgb3Igc2FmZSBuYXZpZ2F0aW9uIGJlZm9yZSBjYWxsaW5nIG1ldGhvZHMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiTnVsbCBzYWZldHkgaXMgaGVhdmlseSB0ZXN0ZWQuIExvb2sgZm9yIG1ldGhvZCBjYWxscyBvbiBmaWVsZHMgd2l0aG91dCBudWxsIGNoZWNrcy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAzLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGVuIHdvdWxkIHlvdSBjaG9vc2Ugc3dpdGNoIG92ZXIgaWYvZWxzZSBzdGF0ZW1lbnRzP1wiLFxuICAgICAgICBhbnN3ZXI6IFwiU3dpdGNoIGZvciBtdWx0aXBsZSBleGFjdCB2YWx1ZSBjb21wYXJpc29ucywgaWYvZWxzZSBmb3IgcmFuZ2VzIG9yIGNvbXBsZXggY29uZGl0aW9uc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJTd2l0Y2ggc3RhdGVtZW50cyBhcmUgY2xlYW5lciBhbmQgbW9yZSBwZXJmb3JtYW50IGZvciBjb21wYXJpbmcgYSBzaW5nbGUgdmFyaWFibGUgYWdhaW5zdCBtdWx0aXBsZSBleGFjdCB2YWx1ZXMuIFVzZSBpZi9lbHNlIGZvciByYW5nZSBjb21wYXJpc29ucywgY29tcGxleCBib29sZWFuIGxvZ2ljLCBvciB3aGVuIHlvdSBuZWVkIGRpZmZlcmVudCB2YXJpYWJsZXMgaW4gZWFjaCBjb25kaXRpb24uXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gR29vZCB1c2Ugb2Ygc3dpdGNoOiBleGFjdCB2YWx1ZSBtYXRjaGluZ1xuc3dpdGNoIG9uIGxlYWQuU3RhdHVzIHtcbiAgICB3aGVuICdPcGVuIC0gTm90IENvbnRhY3RlZCcge1xuICAgICAgICBsZWFkLlByaW9yaXR5ID0gJ0hpZ2gnO1xuICAgIH1cbiAgICB3aGVuICdXb3JraW5nIC0gQ29udGFjdGVkJyB7XG4gICAgICAgIGxlYWQuUHJpb3JpdHkgPSAnTWVkaXVtJztcbiAgICB9XG4gICAgd2hlbiAnQ2xvc2VkIC0gQ29udmVydGVkJywgJ0Nsb3NlZCAtIE5vdCBDb252ZXJ0ZWQnIHtcbiAgICAgICAgbGVhZC5Qcmlvcml0eSA9ICdMb3cnO1xuICAgIH1cbiAgICB3aGVuIGVsc2Uge1xuICAgICAgICBsZWFkLlByaW9yaXR5ID0gJ1Vua25vd24nO1xuICAgIH1cbn1cblxuLy8gQmV0dGVyIHdpdGggaWYvZWxzZTogcmFuZ2UgY29tcGFyaXNvbnNcbmlmIChsZWFkLkFubnVhbFJldmVudWUgPiAxMDAwMDAwKSB7XG4gICAgbGVhZC5SYXRpbmcgPSAnSG90Jztcbn0gZWxzZSBpZiAobGVhZC5Bbm51YWxSZXZlbnVlID4gMTAwMDAwKSB7XG4gICAgbGVhZC5SYXRpbmcgPSAnV2FybSc7XG59IGVsc2Uge1xuICAgIGxlYWQuUmF0aW5nID0gJ0NvbGQnO1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlN3aXRjaCA9IGV4YWN0IHZhbHVlcywgaWYvZWxzZSA9IHJhbmdlcy9jb21wbGV4IGxvZ2ljLiBDaG9vc2UgYmFzZWQgb24gd2hhdCB5b3UncmUgY29tcGFyaW5nLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkNvbnRyb2wgc3RydWN0dXJlIGNob2ljZSBxdWVzdGlvbnMgdGVzdCB1bmRlcnN0YW5kaW5nIG9mIGFwcHJvcHJpYXRlIHVzYWdlIHBhdHRlcm5zLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDQsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJFeHBsYWluIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYGJyZWFrYCBhbmQgYGNvbnRpbnVlYCB3aXRoIGV4YW1wbGVzLlwiLFxuICAgICAgICBhbnN3ZXI6IFwiYGJyZWFrYCBleGl0cyB0aGUgZW50aXJlIGxvb3AsIGBjb250aW51ZWAgc2tpcHMgdG8gdGhlIG5leHQgaXRlcmF0aW9uXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIlRoZXNlIGNvbnRyb2wgc3RhdGVtZW50cyBjaGFuZ2UgbG9vcCBleGVjdXRpb24gZmxvdy4gYGJyZWFrYCBpbW1lZGlhdGVseSBleGl0cyB0aGUgbG9vcCBlbnRpcmVseSwgd2hpbGUgYGNvbnRpbnVlYCBza2lwcyB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgaXRlcmF0aW9uIGFuZCBtb3ZlcyB0byB0aGUgbmV4dCBpdGVyYXRpb24uXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgTGlzdDxBY2NvdW50PiBhY2NvdW50cyA9IFtTRUxFQ1QgSWQsIE5hbWUsIEFubnVhbFJldmVudWUgRlJPTSBBY2NvdW50XTtcblxuLy8gVXNpbmcgY29udGludWUgLSBza2lwIGludmFsaWQgcmVjb3Jkc1xuZm9yIChBY2NvdW50IGFjYyA6IGFjY291bnRzKSB7XG4gICAgaWYgKGFjYy5Bbm51YWxSZXZlbnVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBhY2NvdW50LCBnbyB0byBuZXh0IGl0ZXJhdGlvblxuICAgIH1cblxuICAgIC8vIFRoaXMgY29kZSBvbmx5IHJ1bnMgZm9yIGFjY291bnRzIHdpdGggcmV2ZW51ZVxuICAgIGFjYy5SYXRpbmcgPSBhY2MuQW5udWFsUmV2ZW51ZSA+IDEwMDAwMDAgPyAnSG90JyA6ICdDb2xkJztcbn1cblxuLy8gVXNpbmcgYnJlYWsgLSBleGl0IHdoZW4gZm91bmRcbmZvciAoQWNjb3VudCBhY2MgOiBhY2NvdW50cykge1xuICAgIGlmIChhY2MuTmFtZSA9PSAnVGFyZ2V0IEFjY291bnQnKSB7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnRm91bmQgdGFyZ2V0IGFjY291bnQnKTtcbiAgICAgICAgYnJlYWs7IC8vIEV4aXQgbG9vcCBjb21wbGV0ZWx5LCBkb24ndCBwcm9jZXNzIHJlbWFpbmluZyBhY2NvdW50c1xuICAgIH1cblxuICAgIC8vIFRoaXMgY29kZSBydW5zIHVudGlsIHRhcmdldCBpcyBmb3VuZFxuICAgIFN5c3RlbS5kZWJ1ZygnU3RpbGwgc2VhcmNoaW5nOiAnICsgYWNjLk5hbWUpO1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcImNvbnRpbnVlID0gc2tpcCBjdXJyZW50IGl0ZXJhdGlvbiwgYnJlYWsgPSBleGl0IGVudGlyZSBsb29wLiBVc2UgY29udGludWUgZm9yIGZpbHRlcmluZywgYnJlYWsgZm9yIGVhcmx5IHRlcm1pbmF0aW9uLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkxvb3AgY29udHJvbCBxdWVzdGlvbnMgdGVzdCB1bmRlcnN0YW5kaW5nIG9mIGZsb3cgbW9kaWZpY2F0aW9uLiBSZW1lbWJlcjogY29udGludWUgc2tpcHMsIGJyZWFrIGV4aXRzLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDUsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSBuZWVkIHRvIHByb2Nlc3Mgb25seSB0aGUgZmlyc3QgNTAgcmVjb3JkcyBpbiBhIGxpc3QuIFNob3cgdHdvIGFwcHJvYWNoZXMuXCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgTElNSVQgaW4gU09RTCBxdWVyeSBvciB0cmFkaXRpb25hbCBmb3IgbG9vcCB3aXRoIGNvdW50ZXJcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiV2hlbiB5b3Ugb25seSBuZWVkIGEgc3Vic2V0IG9mIHJlY29yZHMsIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8gbGltaXQgYXQgdGhlIHF1ZXJ5IGxldmVsLiBJZiB5b3UgYWxyZWFkeSBoYXZlIHRoZSBmdWxsIGxpc3QsIHVzZSBhIHRyYWRpdGlvbmFsIGZvciBsb29wIHdpdGggaW5kZXggY29udHJvbC5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBBcHByb2FjaCAxOiBMaW1pdCBhdCBxdWVyeSBsZXZlbCAoQkVTVClcbkxpc3Q8TGVhZD4gbGVhZHMgPSBbU0VMRUNUIElkLCBOYW1lIEZST00gTGVhZCBPUkRFUiBCWSBDcmVhdGVkRGF0ZSBMSU1JVCA1MF07XG5mb3IgKExlYWQgbGVhZCA6IGxlYWRzKSB7XG4gICAgLy8gUHJvY2VzcyBhbGwgNTAgcmVjb3Jkc1xufVxuXG4vLyBBcHByb2FjaCAyOiBMaW1pdCBkdXJpbmcgcHJvY2Vzc2luZ1xuTGlzdDxMZWFkPiBhbGxMZWFkcyA9IFtTRUxFQ1QgSWQsIE5hbWUgRlJPTSBMZWFkIE9SREVSIEJZIENyZWF0ZWREYXRlXTtcbmZvciAoSW50ZWdlciBpID0gMDsgaSA8IE1hdGgubWluKGFsbExlYWRzLnNpemUoKSwgNTApOyBpKyspIHtcbiAgICBMZWFkIGxlYWQgPSBhbGxMZWFkcy5nZXQoaSk7XG4gICAgLy8gUHJvY2VzcyBvbmx5IGZpcnN0IDUwXG59XG5cbi8vIEFwcHJvYWNoIDM6IEVuaGFuY2VkIGZvciB3aXRoIGNvdW50ZXJcbkxpc3Q8TGVhZD4gYWxsTGVhZHMgPSBbU0VMRUNUIElkLCBOYW1lIEZST00gTGVhZCBPUkRFUiBCWSBDcmVhdGVkRGF0ZV07XG5JbnRlZ2VyIGNvdW50ID0gMDtcbmZvciAoTGVhZCBsZWFkIDogYWxsTGVhZHMpIHtcbiAgICBpZiAoY291bnQgPj0gNTApIGJyZWFrO1xuXG4gICAgLy8gUHJvY2VzcyByZWNvcmRcbiAgICBjb3VudCsrO1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkFsd2F5cyBwcmVmZXIgbGltaXRpbmcgYXQgdGhlIGRhdGFiYXNlIGxldmVsIChTT1FMIExJTUlUKSByYXRoZXIgdGhhbiBpbiBBcGV4IGxvb3BzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiUXVlcnkgb3B0aW1pemF0aW9uIHF1ZXN0aW9ucyBmYXZvciBkYXRhYmFzZS1sZXZlbCBmaWx0ZXJpbmcgb3ZlciBBcGV4LWxldmVsIGZpbHRlcmluZy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA2LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCdzIHdyb25nIHdpdGggYGlmIChzdHJpbmdWYWx1ZSA9PSBudWxsIHx8IHN0cmluZ1ZhbHVlID09ICcnKSB7Li4ufWAgYW5kIGhvdyBkbyB5b3UgaW1wcm92ZSBpdD9cIixcbiAgICAgICAgYW5zd2VyOiBcIlZlcmJvc2UgYW5kIGRvZXNuJ3QgaGFuZGxlIHdoaXRlc3BhY2UuIFVzZSBTdHJpbmcuaXNCbGFuaygpIGZvciBjb21wcmVoZW5zaXZlIGNoZWNraW5nXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIk1hbnVhbCBudWxsIGFuZCBlbXB0eSBjaGVja2luZyBpcyB2ZXJib3NlIGFuZCBlcnJvci1wcm9uZS4gU3RyaW5nLmlzQmxhbmsoKSBoYW5kbGVzIG51bGwsIGVtcHR5IHN0cmluZywgYW5kIHdoaXRlc3BhY2Utb25seSBzdHJpbmdzIGluIG9uZSBjYWxsLCBtYWtpbmcgY29kZSBjbGVhbmVyIGFuZCBtb3JlIHJvYnVzdC5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBTdHJpbmcgc3RyaW5nVmFsdWUgPSBnZXRWYWx1ZUZyb21Tb21ld2hlcmUoKTtcblxuLy8gVmVyYm9zZSBhbmQgaW5jb21wbGV0ZVxuaWYgKHN0cmluZ1ZhbHVlID09IG51bGwgfHwgc3RyaW5nVmFsdWUgPT0gJycpIHtcbiAgICAvLyBEb2Vzbid0IGNhdGNoICcgICAnICh3aGl0ZXNwYWNlIG9ubHkpXG59XG5cbi8vIEJldHRlciBidXQgc3RpbGwgdmVyYm9zZVxuaWYgKHN0cmluZ1ZhbHVlID09IG51bGwgfHwgc3RyaW5nVmFsdWUudHJpbSgpLmxlbmd0aCgpID09IDApIHtcbiAgICAvLyBIYW5kbGVzIHdoaXRlc3BhY2UgYnV0IHZlcmJvc2Vcbn1cblxuLy8gQmVzdDogY29tcHJlaGVuc2l2ZSBhbmQgY29uY2lzZVxuaWYgKFN0cmluZy5pc0JsYW5rKHN0cmluZ1ZhbHVlKSkge1xuICAgIC8vIEhhbmRsZXMgbnVsbCwgZW1wdHksIGFuZCB3aGl0ZXNwYWNlLW9ubHlcbn1cblxuLy8gRm9yIHByb2Nlc3Npbmcgd2l0aCBkZWZhdWx0XG5TdHJpbmcgcHJvY2Vzc2VkVmFsdWUgPSBTdHJpbmcuaXNCbGFuayhzdHJpbmdWYWx1ZSkgPyAnRGVmYXVsdCcgOiBzdHJpbmdWYWx1ZS50cmltKCk7YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiVXNlIFN0cmluZyB1dGlsaXR5IG1ldGhvZHMgKGlzQmxhbmssIGlzTm90QmxhbmssIGlzTm90RW1wdHkpIGluc3RlYWQgb2YgbWFudWFsIG51bGwvZW1wdHkgY2hlY2tzLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlN0cmluZyB2YWxpZGF0aW9uIHF1ZXN0aW9ucyBmYXZvciB1dGlsaXR5IG1ldGhvZHMgb3ZlciBtYW51YWwgY2hlY2tpbmcuIFJlbWVtYmVyOiBpc0JsYW5rIGluY2x1ZGVzIHdoaXRlc3BhY2UuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcbiAgICAgICAgcXVlc3Rpb246IFwiQSBsb29wIGlzIGNhdXNpbmcgJ0NQVSB0aW1lb3V0IGV4Y2VlZGVkJy4gSG93IGRvIHlvdSBvcHRpbWl6ZSBpdD9cIixcbiAgICAgICAgYW5zd2VyOiBcIk1vdmUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIHJlZHVjZSBjb21wbGV4aXR5LCBvciB1c2UgZGF0YWJhc2Ugb3BlcmF0aW9ucyBpbnN0ZWFkIG9mIGxvb3BzXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkNQVSB0aW1lb3V0cyBvY2N1ciB3aGVuIHN5bmNocm9ub3VzIEFwZXggcnVucyB0b28gbG9uZyAoMTAgc2Vjb25kcykuIFNvbHV0aW9ucyBpbmNsdWRlIG1vdmluZyBoZWF2eSBwcm9jZXNzaW5nIHRvIGFzeW5jIGNvbnRleHQsIG9wdGltaXppbmcgYWxnb3JpdGhtcywgb3IgcmVwbGFjaW5nIEFwZXggbG9vcHMgd2l0aCBkYXRhYmFzZSBvcGVyYXRpb25zLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYC8vIFByb2JsZW06IEhlYXZ5IHByb2Nlc3NpbmcgaW4gc3luYyBjb250ZXh0XG5wdWJsaWMgdm9pZCBwcm9jZXNzTGFyZ2VEYXRhc2V0KExpc3Q8QWNjb3VudD4gYWNjb3VudHMpIHtcbiAgICBmb3IgKEFjY291bnQgYWNjIDogYWNjb3VudHMpIHtcbiAgICAgICAgLy8gQ29tcGxleCBjYWxjdWxhdGlvbnMgY2F1c2luZyB0aW1lb3V0XG4gICAgICAgIGZvciAoQ29udGFjdCBjb24gOiBbU0VMRUNUIElkIEZST00gQ29udGFjdCBXSEVSRSBBY2NvdW50SWQgPSA6YWNjLklkXSkge1xuICAgICAgICAgICAgLy8gTmVzdGVkIHF1ZXJ5ICsgcHJvY2Vzc2luZyA9IENQVSBraWxsZXJcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gU29sdXRpb24gMTogTW92ZSB0byBhc3luY1xuQGZ1dHVyZVxucHVibGljIHN0YXRpYyB2b2lkIHByb2Nlc3NMYXJnZURhdGFzZXRBc3luYyhMaXN0PElkPiBhY2NvdW50SWRzKSB7XG4gICAgLy8gNjAgc2Vjb25kIGxpbWl0IGluc3RlYWQgb2YgMTAgc2Vjb25kc1xuICAgIExpc3Q8QWNjb3VudD4gYWNjb3VudHMgPSBbU0VMRUNUIElkIEZST00gQWNjb3VudCBXSEVSRSBJZCBJTiA6YWNjb3VudElkc107XG4gICAgLy8gUHJvY2VzcyB3aXRoIGhpZ2hlciBsaW1pdHNcbn1cblxuLy8gU29sdXRpb24gMjogQnVsa2lmeSBxdWVyaWVzXG5wdWJsaWMgdm9pZCBwcm9jZXNzTGFyZ2VEYXRhc2V0QnVsayhMaXN0PEFjY291bnQ+IGFjY291bnRzKSB7XG4gICAgU2V0PElkPiBhY2NvdW50SWRzID0gbmV3IFNldDxJZD4oKTtcbiAgICBmb3IgKEFjY291bnQgYWNjIDogYWNjb3VudHMpIHtcbiAgICAgICAgYWNjb3VudElkcy5hZGQoYWNjLklkKTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgcXVlcnkgaW5zdGVhZCBvZiBsb29wIHF1ZXJpZXNcbiAgICBNYXA8SWQsIExpc3Q8Q29udGFjdD4+IGNvbnRhY3RzQnlBY2NvdW50ID0gbmV3IE1hcDxJZCwgTGlzdDxDb250YWN0Pj4oKTtcbiAgICBmb3IgKENvbnRhY3QgY29uIDogW1NFTEVDVCBJZCwgQWNjb3VudElkIEZST00gQ29udGFjdCBXSEVSRSBBY2NvdW50SWQgSU4gOmFjY291bnRJZHNdKSB7XG4gICAgICAgIC8vIEdyb3VwIGVmZmljaWVudGx5XG4gICAgfVxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkNQVSB0aW1lb3V0cyByZXF1aXJlIGFyY2hpdGVjdHVyYWwgY2hhbmdlczogYXN5bmMgcHJvY2Vzc2luZywgcXVlcnkgYnVsa2lmaWNhdGlvbiwgb3IgZGF0YWJhc2Ugb3BlcmF0aW9ucy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJHb3Zlcm5vciBsaW1pdCBzY2VuYXJpb3MgdGVzdCB1bmRlcnN0YW5kaW5nIG9mIFNhbGVzZm9yY2UgcGxhdGZvcm0gY29uc3RyYWludHMgYW5kIG9wdGltaXphdGlvbiBzdHJhdGVnaWVzLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDgsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSdyZSBwcm9jZXNzaW5nIEFjY291bnQgcmVjb3JkcyBhbmQgbmVlZCB0byBza2lwIGluYWN0aXZlIG9uZXMuIEJlc3QgYXBwcm9hY2g/XCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgY29udGludWUgc3RhdGVtZW50IHRvIHNraXAgaW5hY3RpdmUgYWNjb3VudHMgaW4gdGhlIGxvb3BcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiV2hlbiB5b3UgbmVlZCB0byBza2lwIGNlcnRhaW4gcmVjb3JkcyBkdXJpbmcgcHJvY2Vzc2luZywgdGhlIGNvbnRpbnVlIHN0YXRlbWVudCBwcm92aWRlcyBjbGVhbiwgcmVhZGFibGUgY29kZSB0aGF0IG1vdmVzIHRvIHRoZSBuZXh0IGl0ZXJhdGlvbiB3aXRob3V0IGRlZXBseSBuZXN0aW5nIHRoZSBtYWluIGxvZ2ljLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyB2b2lkIHByb2Nlc3NBY2NvdW50cyhMaXN0PEFjY291bnQ+IGFjY291bnRzKSB7XG4gICAgZm9yIChBY2NvdW50IGFjYyA6IGFjY291bnRzKSB7XG4gICAgICAgIC8vIEd1YXJkIGNsYXVzZTogc2tpcCBpbmFjdGl2ZSBhY2NvdW50c1xuICAgICAgICBpZiAoYWNjLkFjdGl2ZV9fYyAhPSB0cnVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IGFjY291bnRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1haW4gcHJvY2Vzc2luZyBsb2dpYyBvbmx5IHJ1bnMgZm9yIGFjdGl2ZSBhY2NvdW50c1xuICAgICAgICBpZiAoYWNjLkFubnVhbFJldmVudWUgPiAxMDAwMDAwKSB7XG4gICAgICAgICAgICBhY2MuUmF0aW5nID0gJ0hvdCc7XG4gICAgICAgIH1cblxuICAgICAgICBhY2MuTGFzdFByb2Nlc3NlZF9fYyA9IFN5c3RlbS5ub3coKTtcbiAgICAgICAgU3lzdGVtLmRlYnVnKCdQcm9jZXNzZWQgYWN0aXZlIGFjY291bnQ6ICcgKyBhY2MuTmFtZSk7XG4gICAgfVxufVxuXG4vLyBBbHRlcm5hdGl2ZTogZmlsdGVyIGluIHF1ZXJ5IChldmVuIGJldHRlcilcbkxpc3Q8QWNjb3VudD4gYWN0aXZlQWNjb3VudHMgPSBbU0VMRUNUIElkLCBOYW1lLCBBbm51YWxSZXZlbnVlIEZST00gQWNjb3VudCBXSEVSRSBBY3RpdmVfX2MgPSB0cnVlXTtcbmZvciAoQWNjb3VudCBhY2MgOiBhY3RpdmVBY2NvdW50cykge1xuICAgIC8vIEFsbCBhY2NvdW50cyBhcmUgYWxyZWFkeSBhY3RpdmVcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJVc2UgY29udGludWUgZm9yIGNsZWFuIGd1YXJkIGNsYXVzZXMsIGJ1dCBwcmVmZXIgZmlsdGVyaW5nIGluIFNPUUwgcXVlcmllcyB3aGVuIHBvc3NpYmxlLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkVhcmx5IGV4aXQgcGF0dGVybnMgaW1wcm92ZSBjb2RlIHJlYWRhYmlsaXR5LiBHdWFyZCBjbGF1c2VzIHdpdGggY29udGludWUgYXJlIHByZWZlcnJlZCBvdmVyIGRlZXAgbmVzdGluZy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA5LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiRXhwbGFpbiB3aGVuIGVuaGFuY2VkIGZvciBsb29wcyBhcmUgcHJlZmVycmVkIG92ZXIgdHJhZGl0aW9uYWwgZm9yIGxvb3BzLlwiLFxuICAgICAgICBhbnN3ZXI6IFwiRW5oYW5jZWQgZm9yIHdoZW4gcHJvY2Vzc2luZyBhbGwgZWxlbWVudHMsIHRyYWRpdGlvbmFsIGZvciB3aGVuIHlvdSBuZWVkIGluZGV4IG9yIHNraXAgZWxlbWVudHNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiRW5oYW5jZWQgZm9yIGxvb3BzIGFyZSBzYWZlciAobm8gaW5kZXggYm91bmRzIGlzc3VlcykgYW5kIGNsZWFuZXIgZm9yIHByb2Nlc3NpbmcgYWxsIGVsZW1lbnRzLiBUcmFkaXRpb25hbCBmb3IgbG9vcHMgZ2l2ZSB5b3UgaW5kZXggY29udHJvbCBmb3IgcGFydGlhbCBwcm9jZXNzaW5nIG9yIHdoZW4geW91IG5lZWQgZWxlbWVudCBwb3NpdGlvbi5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBMaXN0PENvbnRhY3Q+IGNvbnRhY3RzID0gW1NFTEVDVCBJZCwgTmFtZSwgRW1haWwgRlJPTSBDb250YWN0XTtcblxuLy8gRW5oYW5jZWQgZm9yOiBQcm9jZXNzIGFsbCBlbGVtZW50cyAoUFJFRkVSUkVEKVxuZm9yIChDb250YWN0IGNvbiA6IGNvbnRhY3RzKSB7XG4gICAgLy8gQ2xlYW4sIHNhZmUsIG5vIGluZGV4IG1hbmFnZW1lbnRcbiAgICBpZiAoU3RyaW5nLmlzTm90QmxhbmsoY29uLkVtYWlsKSkge1xuICAgICAgICBzZW5kRW1haWwoY29uLkVtYWlsKTtcbiAgICB9XG59XG5cbi8vIFRyYWRpdGlvbmFsIGZvcjogV2hlbiB5b3UgbmVlZCB0aGUgaW5kZXhcbmZvciAoSW50ZWdlciBpID0gMDsgaSA8IGNvbnRhY3RzLnNpemUoKTsgaSsrKSB7XG4gICAgQ29udGFjdCBjb24gPSBjb250YWN0cy5nZXQoaSk7XG4gICAgU3lzdGVtLmRlYnVnKCdQcm9jZXNzaW5nIGNvbnRhY3QgIycgKyAoaSArIDEpICsgJzogJyArIGNvbi5OYW1lKTtcbn1cblxuLy8gVHJhZGl0aW9uYWwgZm9yOiBQcm9jZXNzIG9ubHkgZmlyc3QgaGFsZlxuZm9yIChJbnRlZ2VyIGkgPSAwOyBpIDwgY29udGFjdHMuc2l6ZSgpIC8gMjsgaSsrKSB7XG4gICAgQ29udGFjdCBjb24gPSBjb250YWN0cy5nZXQoaSk7XG4gICAgLy8gUHJvY2VzcyBzdWJzZXRcbn1cblxuLy8gVHJhZGl0aW9uYWwgZm9yOiBTa2lwIGV2ZXJ5IG90aGVyIGVsZW1lbnRcbmZvciAoSW50ZWdlciBpID0gMDsgaSA8IGNvbnRhY3RzLnNpemUoKTsgaSArPSAyKSB7XG4gICAgQ29udGFjdCBjb24gPSBjb250YWN0cy5nZXQoaSk7XG4gICAgLy8gUHJvY2VzcyBldmVyeSBvdGhlciBjb250YWN0XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiRW5oYW5jZWQgZm9yID0gYWxsIGVsZW1lbnRzIHNhZmVseS4gVHJhZGl0aW9uYWwgZm9yID0gaW5kZXggY29udHJvbCBhbmQgcGFydGlhbCBwcm9jZXNzaW5nLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkxvb3AgY2hvaWNlIHF1ZXN0aW9ucyB0ZXN0IHVuZGVyc3RhbmRpbmcgb2Ygd2hlbiBpbmRleCBhY2Nlc3MgaXMgbmVjZXNzYXJ5IHZzLiBzaW1wbGUgaXRlcmF0aW9uLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDEwLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYWR2YW5jZWQnLFxuICAgICAgICBxdWVzdGlvbjogXCJBIGJ1c2luZXNzIHJ1bGUgaGFzIDggZGlmZmVyZW50IGNvbmRpdGlvbnMuIEhvdyBkbyB5b3Ugc3RydWN0dXJlIHRoaXMgY2xlYW5seT9cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBlYXJseSByZXR1cm5zLCBzd2l0Y2ggc3RhdGVtZW50cywgb3Igc3RyYXRlZ3kgcGF0dGVybiB0byBhdm9pZCBkZWVwIG5lc3RpbmdcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiTXVsdGlwbGUgY29uZGl0aW9ucyBjYW4gY3JlYXRlIGRlZXBseSBuZXN0ZWQsIGhhcmQtdG8tcmVhZCBjb2RlLiBDbGVhbiBhcHByb2FjaGVzIGluY2x1ZGUgZ3VhcmQgY2xhdXNlcyB3aXRoIGVhcmx5IHJldHVybnMsIHN3aXRjaCBzdGF0ZW1lbnRzIGZvciBleGFjdCBtYXRjaGVzLCBvciBvcmdhbml6aW5nIGludG8gc2VwYXJhdGUgbWV0aG9kcy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBQcm9ibGVtOiBEZWVwIG5lc3Rpbmcgd2l0aCBtYW55IGNvbmRpdGlvbnNcbnB1YmxpYyBTdHJpbmcgY2F0ZWdvcml6ZU9wcG9ydHVuaXR5KE9wcG9ydHVuaXR5IG9wcCkge1xuICAgIGlmIChvcHAuQW1vdW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG9wcC5BbW91bnQgPiAxMDAwMDAwKSB7XG4gICAgICAgICAgICBpZiAob3BwLlByb2JhYmlsaXR5ID4gODApIHtcbiAgICAgICAgICAgICAgICBpZiAob3BwLlR5cGUgPT0gJ05ldyBDdXN0b21lcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVlcCBuZXN0aW5nIGNvbnRpbnVlcy4uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1Vua25vd24nO1xufVxuXG4vLyBTb2x1dGlvbiAxOiBFYXJseSByZXR1cm5zIChndWFyZCBjbGF1c2VzKVxucHVibGljIFN0cmluZyBjYXRlZ29yaXplT3Bwb3J0dW5pdHlDbGVhbihPcHBvcnR1bml0eSBvcHApIHtcbiAgICAvLyBIYW5kbGUgaW52YWxpZCBjYXNlcyBlYXJseVxuICAgIGlmIChvcHAuQW1vdW50ID09IG51bGwpIHJldHVybiAnTm8gQW1vdW50JztcbiAgICBpZiAob3BwLlByb2JhYmlsaXR5ID09IG51bGwpIHJldHVybiAnTm8gUHJvYmFiaWxpdHknO1xuXG4gICAgLy8gTGFyZ2UgZGVhbHNcbiAgICBpZiAob3BwLkFtb3VudCA+IDEwMDAwMDApIHtcbiAgICAgICAgaWYgKG9wcC5Qcm9iYWJpbGl0eSA+IDgwKSByZXR1cm4gJ0xhcmdlIFN1cmUgRGVhbCc7XG4gICAgICAgIGlmIChvcHAuUHJvYmFiaWxpdHkgPiA1MCkgcmV0dXJuICdMYXJnZSBMaWtlbHkgRGVhbCc7XG4gICAgICAgIHJldHVybiAnTGFyZ2UgUmlza3kgRGVhbCc7XG4gICAgfVxuXG4gICAgLy8gTWVkaXVtIGRlYWxzXG4gICAgaWYgKG9wcC5BbW91bnQgPiAxMDAwMDApIHtcbiAgICAgICAgcmV0dXJuIG9wcC5Qcm9iYWJpbGl0eSA+IDcwID8gJ01lZGl1bSBTdXJlIERlYWwnIDogJ01lZGl1bSBEZWFsJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ1NtYWxsIERlYWwnO1xufVxuXG4vLyBTb2x1dGlvbiAyOiBTd2l0Y2ggZm9yIGV4YWN0IG1hdGNoaW5nXG5wdWJsaWMgU3RyaW5nIGNhdGVnb3JpemVCeVN0YWdlKE9wcG9ydHVuaXR5IG9wcCkge1xuICAgIHN3aXRjaCBvbiBvcHAuU3RhZ2VOYW1lIHtcbiAgICAgICAgd2hlbiAnUHJvc3BlY3RpbmcnLCAnUXVhbGlmaWNhdGlvbicgeyByZXR1cm4gJ0Vhcmx5IFN0YWdlJzsgfVxuICAgICAgICB3aGVuICdOZWVkcyBBbmFseXNpcycsICdWYWx1ZSBQcm9wb3NpdGlvbicgeyByZXR1cm4gJ01pZCBTdGFnZSc7IH1cbiAgICAgICAgd2hlbiAnSWQuIERlY2lzaW9uIE1ha2VycycsICdQZXJjZXB0aW9uIEFuYWx5c2lzJyB7IHJldHVybiAnTGF0ZSBTdGFnZSc7IH1cbiAgICAgICAgd2hlbiAnUHJvcG9zYWwvUHJpY2UgUXVvdGUnLCAnTmVnb3RpYXRpb24vUmV2aWV3JyB7IHJldHVybiAnRmluYWwgU3RhZ2UnOyB9XG4gICAgICAgIHdoZW4gJ0Nsb3NlZCBXb24nIHsgcmV0dXJuICdXb24nOyB9XG4gICAgICAgIHdoZW4gJ0Nsb3NlZCBMb3N0JyB7IHJldHVybiAnTG9zdCc7IH1cbiAgICAgICAgd2hlbiBlbHNlIHsgcmV0dXJuICdVbmtub3duIFN0YWdlJzsgfVxuICAgIH1cbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJDb21wbGV4IGNvbmRpdGlvbnMgbmVlZCBjbGVhbiBzdHJ1Y3R1cmU6IGVhcmx5IHJldHVybnMsIHN3aXRjaCBzdGF0ZW1lbnRzLCBvciBzZXBhcmF0ZSBtZXRob2RzIHRvIGF2b2lkIG5lc3RpbmcuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiQ29kZSBxdWFsaXR5IHF1ZXN0aW9ucyB0ZXN0IGFiaWxpdHkgdG8gd3JpdGUgbWFpbnRhaW5hYmxlIGxvZ2ljLiBEZWVwIG5lc3RpbmcgaXMgYW4gYW50aS1wYXR0ZXJuLlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuXG4gICdjbGFzc2VzLWFuZC1vYmplY3RzJzoge1xuICAgIHRpdGxlOiAnQ2xhc3NlcyBhbmQgT2JqZWN0cycsXG4gICAgb3ZlcnZpZXc6ICdNYXN0ZXIgb2JqZWN0LW9yaWVudGVkIHByb2dyYW1taW5nIGluIEFwZXguIFlvdXIgY29udHJvbCBmbG93IGxvZ2ljIG5lZWRzIG9yZ2FuaXphdGlvbiBhbmQgcmV1c2FiaWxpdHkgLSBDbGFzc2VzIGFyZSBjb250YWluZXJzIGZvciByZWxhdGVkIGZ1bmN0aW9uYWxpdHkuIFVuZGVyc3RhbmRpbmcgY2xhc3NlcyBpcyBjcnVjaWFsIGJlY2F1c2UgMzAlIG9mIFNhbGVzZm9yY2UgZGV2ZWxvcG1lbnQgaW52b2x2ZXMgY3JlYXRpbmcgYW5kIHVzaW5nIGN1c3RvbSBjbGFzc2VzLiBUaGlzIGtub3dsZWRnZSBkaXJlY3RseSBlbmFibGVzIFNPUUwgb3BlcmF0aW9ucyAob3JnYW5pemVkIGRhdGEgYWNjZXNzKSBhbmQgVHJpZ2dlcnMgKG9yZ2FuaXplZCBhdXRvbWF0aW9uKS4nLFxuICAgIGNvZGVFeGFtcGxlczogW1xuICAgICAge1xuICAgICAgICB0aXRsZTogJ0NsYXNzIFN0cnVjdHVyZScsXG4gICAgICAgIGNvZGU6IGBwdWJsaWMgY2xhc3MgQ3VzdG9tZXJNYW5hZ2VyIHtcbiAgICAvLyDinIUgQlVJTERJTkcgT046IENvbnRyb2wgZmxvdyBsb2dpYyBuZWVkcyBvcmdhbml6YXRpb24gYW5kIHJldXNhYmlsaXR5XG4gICAgLy8g4pyFIE5FVyBDT05DRVBUOiBDbGFzc2VzIGFyZSBjb250YWluZXJzIGZvciByZWxhdGVkIGZ1bmN0aW9uYWxpdHlcblxuICAgIC8vIOKchSBJTlNUQU5DRSBWQVJJQUJMRVM6IERhdGEgdGhhdCBiZWxvbmdzIHRvIGVhY2ggb2JqZWN0XG4gICAgcHJpdmF0ZSBTdHJpbmcgbWFuYWdlck5hbWU7XG4gICAgcHJpdmF0ZSBJbnRlZ2VyIGN1c3RvbWVyc1Byb2Nlc3NlZDtcbiAgICBwcml2YXRlIExpc3Q8U3RyaW5nPiBwcm9jZXNzZWRDdXN0b21lcklkcztcbiAgICAvLyDinIUgV0hZIHByaXZhdGU6IEVuY2Fwc3VsYXRpb24gLSBjb250cm9sbGVkIGFjY2VzcyBvbmx5XG4gICAgLy8g4pyFIENPTk5FQ1RJT046IFNhbWUgdmFyaWFibGUgcHJpbmNpcGxlcyBmcm9tIFZhcmlhYmxlcyB0b3BpY1xuICAgIC8vIPCfkqEgTkVYVCBUT1BJQzogU09RTCB3aWxsIHBvcHVsYXRlIHRoZXNlIHdpdGggcmVhbCBkYXRhXG5cbiAgICAvLyDinIUgU1RBVElDIFZBUklBQkxFUzogU2hhcmVkIGFjcm9zcyBBTEwgb2JqZWN0cyBvZiB0aGlzIGNsYXNzXG4gICAgcHJpdmF0ZSBzdGF0aWMgSW50ZWdlciB0b3RhbEN1c3RvbWVyc1Byb2Nlc3NlZCA9IDA7XG4gICAgLy8g4pyFIFdIQVQ6IE9uZSBjb3B5IHNoYXJlZCBieSBhbGwgQ3VzdG9tZXJNYW5hZ2VyIG9iamVjdHNcbiAgICAvLyDinIUgV0hZOiBUcmFjayBnbG9iYWwgc3RhdGlzdGljcyBhY3Jvc3MgYWxsIGluc3RhbmNlc1xuXG4gICAgLy8g4pyFIENPTlNUQU5UUzogVmFsdWVzIHRoYXQgbmV2ZXIgY2hhbmdlXG4gICAgcHVibGljIHN0YXRpYyBmaW5hbCBJbnRlZ2VyIE1BWF9DVVNUT01FUlNfUEVSX0JBVENIID0gMjAwO1xuICAgIC8vIOKchSBXSFkgMjAwOiBTYWxlc2ZvcmNlIGdvdmVybm9yIGxpbWl0cyBmb3IgYnVsayBwcm9jZXNzaW5nXG5cbiAgICAvLyDinIUgQ09OU1RSVUNUT1I6IEluaXRpYWxpemUgb2JqZWN0IHdoZW4gY3JlYXRlZFxuICAgIHB1YmxpYyBDdXN0b21lck1hbmFnZXIoU3RyaW5nIG5hbWUpIHtcbiAgICAgICAgLy8g4pyFIFdIQVQ6IFJ1bnMgYXV0b21hdGljYWxseSB3aGVuIG9iamVjdCBjcmVhdGVkIHdpdGggJ25ldydcbiAgICAgICAgLy8g4pyFIFdIWTogRW5zdXJlcyBvYmplY3Qgc3RhcnRzIGluIHZhbGlkIHN0YXRlXG4gICAgICAgIHRoaXMubWFuYWdlck5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmN1c3RvbWVyc1Byb2Nlc3NlZCA9IDA7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkQ3VzdG9tZXJJZHMgPSBuZXcgTGlzdDxTdHJpbmc+KCk7XG4gICAgICAgIC8vIOKchSBDT05ORUNUSU9OOiBMaXN0IGluaXRpYWxpemF0aW9uIGZyb20gQ29sbGVjdGlvbnMgdG9waWNcbiAgICAgICAgLy8g8J+SgCBFWEFNIFRSQVA6IEZvcmdldHRpbmcgdG8gaW5pdGlhbGl6ZSBjb2xsZWN0aW9ucyA9IG51bGwgZXJyb3JzXG4gICAgfVxuXG4gICAgLy8g4pyFIElOU1RBTkNFIE1FVEhPRDogT3BlcmF0ZXMgb24gc3BlY2lmaWMgb2JqZWN0J3MgZGF0YVxuICAgIHB1YmxpYyB2b2lkIHByb2Nlc3NDdXN0b21lcihBY2NvdW50IGN1c3RvbWVyKSB7XG4gICAgICAgIC8vIOKchSBWQUxJREFUSU9OOiBTYW1lIHBhdHRlcm5zIGZyb20gQ29udHJvbCBGbG93IHRvcGljXG4gICAgICAgIGlmIChjdXN0b21lciA9PSBudWxsIHx8IFN0cmluZy5pc0JsYW5rKGN1c3RvbWVyLk5hbWUpKSB7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ0ludmFsaWQgY3VzdG9tZXIgZGF0YSBwcm92aWRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBFYXJseSBleGl0IHBhdHRlcm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOKchSBCVVNJTkVTUyBMT0dJQzogQXBwbHkgcHJvY2Vzc2luZyBydWxlc1xuICAgICAgICBpZiAoY3VzdG9tZXIuQW5udWFsUmV2ZW51ZSAhPSBudWxsICYmIGN1c3RvbWVyLkFubnVhbFJldmVudWUgPiAxMDAwMDApIHtcbiAgICAgICAgICAgIGN1c3RvbWVyLkN1c3RvbWVyUHJpb3JpdHlfX2MgPSAnSGlnaCc7XG4gICAgICAgICAgICAvLyDinIUgQ09OTkVDVElPTjogQ29uZGl0aW9uYWwgbG9naWMgZnJvbSBDb250cm9sIEZsb3cgdG9waWNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOKchSBTVEFURSBUUkFDS0lORzogVXBkYXRlIG9iamVjdCdzIGludGVybmFsIGRhdGFcbiAgICAgICAgdGhpcy5jdXN0b21lcnNQcm9jZXNzZWQrKztcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRDdXN0b21lcklkcy5hZGQoY3VzdG9tZXIuSWQpO1xuICAgICAgICB0b3RhbEN1c3RvbWVyc1Byb2Nlc3NlZCsrOyAvLyBTdGF0aWMgdmFyaWFibGVcblxuICAgICAgICBTeXN0ZW0uZGVidWcodGhpcy5tYW5hZ2VyTmFtZSArICcgcHJvY2Vzc2VkOiAnICsgY3VzdG9tZXIuTmFtZSk7XG4gICAgICAgIC8vIPCfkqEgTkVYVCBUT1BJQzogU09RTCB3aWxsIHByb3ZpZGUgY3VzdG9tZXIgZGF0YSBlZmZpY2llbnRseVxuICAgIH1cblxuICAgIC8vIOKchSBTVEFUSUMgTUVUSE9EOiBVdGlsaXR5IGZ1bmN0aW9uLCBubyBvYmplY3QgbmVlZGVkXG4gICAgcHVibGljIHN0YXRpYyBCb29sZWFuIGlzSGlnaFZhbHVlQ3VzdG9tZXIoQWNjb3VudCBjdXN0b21lcikge1xuICAgICAgICAvLyDinIUgV0hFTiBUTyBVU0U6IFB1cmUgZnVuY3Rpb24gdGhhdCBkb2Vzbid0IG5lZWQgb2JqZWN0IHN0YXRlXG4gICAgICAgIC8vIOKchSBSRVVTQUJJTElUWTogQ2FuIGJlIGNhbGxlZCBmcm9tIGFueXdoZXJlXG4gICAgICAgIGlmIChjdXN0b21lcj8uQW5udWFsUmV2ZW51ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1c3RvbWVyLkFubnVhbFJldmVudWUgPiA1MDAwMDA7XG4gICAgICAgIC8vIOKchSBDT05ORUNUSU9OOiBOdWxsIHNhZmV0eSBmcm9tIFZhcmlhYmxlcyB0b3BpY1xuICAgIH1cblxuICAgIC8vIOKchSBHRVRURVIgTUVUSE9EOiBDb250cm9sbGVkIGFjY2VzcyB0byBwcml2YXRlIGRhdGFcbiAgICBwdWJsaWMgSW50ZWdlciBnZXRDdXN0b21lcnNQcm9jZXNzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbWVyc1Byb2Nlc3NlZDtcbiAgICAgICAgLy8g4pyFIEVOQ0FQU1VMQVRJT046IFJlYWQtb25seSBhY2Nlc3MgdG8gaW50ZXJuYWwgc3RhdGVcbiAgICB9XG59XG5cbi8vIOKchSBVU0FHRSBFWEFNUExFOiBIb3cgY2xhc3NlcyB3b3JrIHRvZ2V0aGVyXG5wdWJsaWMgY2xhc3MgQnVzaW5lc3NMb2dpY0V4YW1wbGUge1xuICAgIHB1YmxpYyB2b2lkIGRlbW9uc3RyYXRlQ2xhc3NVc2FnZSgpIHtcbiAgICAgICAgLy8g4pyFIE9CSkVDVCBDUkVBVElPTjogQ29uc3RydWN0b3IgcnVucyBhdXRvbWF0aWNhbGx5XG4gICAgICAgIEN1c3RvbWVyTWFuYWdlciBzYWxlc01hbmFnZXIgPSBuZXcgQ3VzdG9tZXJNYW5hZ2VyKCdKb2huIFNtaXRoJyk7XG4gICAgICAgIEN1c3RvbWVyTWFuYWdlciBzdXBwb3J0TWFuYWdlciA9IG5ldyBDdXN0b21lck1hbmFnZXIoJ0phbmUgRG9lJyk7XG4gICAgICAgIC8vIOKchSBNVUxUSVBMRSBPQkpFQ1RTOiBFYWNoIGhhcyBpdHMgb3duIHN0YXRlXG5cbiAgICAgICAgLy8g4pyFIFNUQVRJQyBNRVRIT0Q6IENhbGxlZCBvbiBjbGFzcywgbm90IG9iamVjdFxuICAgICAgICBMaXN0PEFjY291bnQ+IGFjY291bnRzID0gW1NFTEVDVCBJZCwgTmFtZSwgQW5udWFsUmV2ZW51ZSBGUk9NIEFjY291bnQgTElNSVQgMTBdO1xuXG4gICAgICAgIGZvciAoQWNjb3VudCBhY2MgOiBhY2NvdW50cykge1xuICAgICAgICAgICAgLy8g4pyFIERFQ0lTSU9OIExPR0lDOiBGcm9tIENvbnRyb2wgRmxvdyB0b3BpY1xuICAgICAgICAgICAgaWYgKEN1c3RvbWVyTWFuYWdlci5pc0hpZ2hWYWx1ZUN1c3RvbWVyKGFjYykpIHtcbiAgICAgICAgICAgICAgICBzYWxlc01hbmFnZXIucHJvY2Vzc0N1c3RvbWVyKGFjYyk7XG4gICAgICAgICAgICAgICAgLy8g4pyFIElOU1RBTkNFIE1FVEhPRDogQ2FsbGVkIG9uIHNwZWNpZmljIG9iamVjdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgU3lzdGVtLmRlYnVnKCdTYWxlcyBwcm9jZXNzZWQ6ICcgKyBzYWxlc01hbmFnZXIuZ2V0Q3VzdG9tZXJzUHJvY2Vzc2VkKCkpO1xuICAgICAgICAvLyDwn5KhIE5FWFQgVE9QSUM6IFNPUUwgd2lsbCBnZXQgZGF0YSBtb3JlIGVmZmljaWVudGx5XG4gICAgfVxufWAsXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnQ2xhc3NlcyBlbmNhcHN1bGF0ZSByZWxhdGVkIGRhdGEgYW5kIGJlaGF2aW9yLiBVc2UgaW5zdGFuY2UgdmFyaWFibGVzIGZvciBvYmplY3Qgc3RhdGUsIGNvbnN0cnVjdG9ycyBmb3IgaW5pdGlhbGl6YXRpb24sIGluc3RhbmNlIG1ldGhvZHMgZm9yIG9iamVjdCBvcGVyYXRpb25zLCBhbmQgc3RhdGljIG1ldGhvZHMgZm9yIHV0aWxpdGllcy4nXG4gICAgICB9XG4gICAgXSxcbiAgICBwcmFjdGljZVF1ZXN0aW9uczogW1xuICAgICAge1xuICAgICAgICBudW1iZXI6IDEsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoYXQncyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgY2xhc3MgYW5kIGFuIG9iamVjdCBpbiBBcGV4P1wiLFxuICAgICAgICBhbnN3ZXI6IFwiQSBjbGFzcyBpcyBhIGJsdWVwcmludC90ZW1wbGF0ZSwgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIGNyZWF0ZWQgZnJvbSB0aGF0IGNsYXNzXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkEgY2xhc3MgZGVmaW5lcyB0aGUgc3RydWN0dXJlICh2YXJpYWJsZXMgYW5kIG1ldGhvZHMpIGJ1dCBkb2Vzbid0IGV4aXN0IGluIG1lbW9yeS4gQW4gb2JqZWN0IGlzIGEgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgdGhhdCBjbGFzcyB0aGF0IGFjdHVhbGx5IGhvbGRzIGRhdGEgYW5kIGNhbiBleGVjdXRlIG1ldGhvZHMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIGNsYXNzIEFjY291bnQge1xuICAgIHB1YmxpYyBTdHJpbmcgbmFtZTsgIC8vIENsYXNzIGRlZmluZXMgc3RydWN0dXJlXG4gICAgcHVibGljIHZvaWQgZGlzcGxheSgpIHsgU3lzdGVtLmRlYnVnKG5hbWUpOyB9XG59XG5cbi8vIE9iamVjdCBjcmVhdGlvbiBmcm9tIGNsYXNzXG5BY2NvdW50IG15QWNjb3VudCA9IG5ldyBBY2NvdW50KCk7ICAvLyBDcmVhdGUgb2JqZWN0IGluc3RhbmNlXG5teUFjY291bnQubmFtZSA9ICdBY21lIENvcnAnOyAgICAgICAvLyBTZXQgZGF0YSBpbiBvYmplY3Rcbm15QWNjb3VudC5kaXNwbGF5KCk7ICAgICAgICAgICAgICAgIC8vIENhbGwgbWV0aG9kIG9uIG9iamVjdGAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkNsYXNzID0gYmx1ZXByaW50LCBPYmplY3QgPSBhY3R1YWwgaW5zdGFuY2UuIFlvdSBuZWVkIHRvIGluc3RhbnRpYXRlIGEgY2xhc3Mgd2l0aCAnbmV3JyB0byBjcmVhdGUgYW4gb2JqZWN0LlwiLFxuICAgICAgICBleGFtVGlwOiBcIlBEMSBmcmVxdWVudGx5IHRlc3RzIHVuZGVyc3RhbmRpbmcgb2YgY2xhc3NlcyB2cyBvYmplY3RzLiBSZW1lbWJlcjogY2xhc3NlcyBkZWZpbmUsIG9iamVjdHMgZXhlY3V0ZS5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAyLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGVuIHNob3VsZCB5b3UgdXNlIGEgY29uc3RydWN0b3IgaW4gQXBleD9cIixcbiAgICAgICAgYW5zd2VyOiBcIldoZW4geW91IG5lZWQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSB2YXJpYWJsZXMgb3IgcGVyZm9ybSBzZXR1cCB3aGVuIGFuIG9iamVjdCBpcyBjcmVhdGVkXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkNvbnN0cnVjdG9ycyBlbnN1cmUgb2JqZWN0cyBzdGFydCBpbiBhIHZhbGlkIHN0YXRlLiBVc2UgdGhlbSB0byBzZXQgZGVmYXVsdCB2YWx1ZXMsIGluaXRpYWxpemUgY29sbGVjdGlvbnMsIG9yIHBlcmZvcm0gdmFsaWRhdGlvbi4gSWYgeW91IGRvbid0IGNyZWF0ZSBhIGNvbnN0cnVjdG9yLCBBcGV4IHByb3ZpZGVzIGEgZGVmYXVsdCBuby1hcmd1bWVudCBjb25zdHJ1Y3Rvci5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgY2xhc3MgT3JkZXJQcm9jZXNzb3Ige1xuICAgIHByaXZhdGUgU3RyaW5nIHByb2Nlc3Nvck5hbWU7XG4gICAgcHJpdmF0ZSBMaXN0PE9yZGVyPiBwZW5kaW5nT3JkZXJzO1xuICAgIHByaXZhdGUgRGF0ZVRpbWUgY3JlYXRlZEF0O1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaW5pdGlhbGl6ZXMgb2JqZWN0IHN0YXRlXG4gICAgcHVibGljIE9yZGVyUHJvY2Vzc29yKFN0cmluZyBuYW1lKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yTmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucGVuZGluZ09yZGVycyA9IG5ldyBMaXN0PE9yZGVyPigpOyAvLyBJbml0aWFsaXplIGNvbGxlY3Rpb25cbiAgICAgICAgdGhpcy5jcmVhdGVkQXQgPSBTeXN0ZW0ubm93KCk7ICAgICAgICAgIC8vIFNldCB0aW1lc3RhbXBcblxuICAgICAgICAvLyBWYWxpZGF0aW9uIGluIGNvbnN0cnVjdG9yXG4gICAgICAgIGlmIChTdHJpbmcuaXNCbGFuayhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUHJvY2Vzc29yIG5hbWUgY2Fubm90IGJlIGJsYW5rJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdmVybG9hZGVkIGNvbnN0cnVjdG9yIHdpdGggZGlmZmVyZW50IHBhcmFtZXRlcnNcbiAgICBwdWJsaWMgT3JkZXJQcm9jZXNzb3IoU3RyaW5nIG5hbWUsIEludGVnZXIgaW5pdGlhbENhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMobmFtZSk7IC8vIENhbGwgb3RoZXIgY29uc3RydWN0b3JcbiAgICAgICAgdGhpcy5wZW5kaW5nT3JkZXJzID0gbmV3IExpc3Q8T3JkZXI+KGluaXRpYWxDYXBhY2l0eSk7XG4gICAgfVxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkNvbnN0cnVjdG9ycyBpbml0aWFsaXplIG9iamVjdCBzdGF0ZSBhbmQgZW5zdXJlIHZhbGlkIHN0YXJ0aW5nIGNvbmRpdGlvbnMuIEFsd2F5cyBpbml0aWFsaXplIGNvbGxlY3Rpb25zIHRvIGF2b2lkIG51bGwgZXJyb3JzLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkNvbnN0cnVjdG9yIHF1ZXN0aW9ucyBvZnRlbiB0ZXN0IGluaXRpYWxpemF0aW9uIHBhdHRlcm5zIGFuZCBvdmVybG9hZGluZy4gUmVtZW1iZXI6IG5vIHJldHVybiB0eXBlIGZvciBjb25zdHJ1Y3RvcnMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoYXQncyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGluc3RhbmNlIGFuZCBzdGF0aWMgbWV0aG9kcz8gV2hlbiB3b3VsZCB5b3UgdXNlIGVhY2g/XCIsXG4gICAgICAgIGFuc3dlcjogXCJJbnN0YW5jZSBtZXRob2RzIG9wZXJhdGUgb24gb2JqZWN0IGRhdGEsIHN0YXRpYyBtZXRob2RzIGFyZSB1dGlsaXRpZXMgdGhhdCBkb24ndCBuZWVkIG9iamVjdCBzdGF0ZVwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJJbnN0YW5jZSBtZXRob2RzIGhhdmUgYWNjZXNzIHRvIGluc3RhbmNlIHZhcmlhYmxlcyBhbmQgcmVwcmVzZW50IG9iamVjdCBiZWhhdmlvci4gU3RhdGljIG1ldGhvZHMgY2FuJ3QgYWNjZXNzIGluc3RhbmNlIHZhcmlhYmxlcyBhbmQgYXJlIGNhbGxlZCBvbiB0aGUgY2xhc3MgaXRzZWxmLCBub3Qgb2JqZWN0cy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgY2xhc3MgQ3VzdG9tZXJTZXJ2aWNlIHtcbiAgICBwcml2YXRlIFN0cmluZyBzZXJ2aWNlTmFtZTtcbiAgICBwcml2YXRlIEludGVnZXIgcmVxdWVzdHNIYW5kbGVkO1xuXG4gICAgLy8gSW5zdGFuY2UgbWV0aG9kIC0gbmVlZHMgb2JqZWN0IHN0YXRlXG4gICAgcHVibGljIHZvaWQgaGFuZGxlQ3VzdG9tZXJSZXF1ZXN0KENhc2UgY3VzdG9tZXJDYXNlKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdHNIYW5kbGVkKys7ICAvLyBVc2VzIGluc3RhbmNlIHZhcmlhYmxlXG4gICAgICAgIFN5c3RlbS5kZWJ1Zyh0aGlzLnNlcnZpY2VOYW1lICsgJyBoYW5kbGVkIGNhc2U6ICcgKyBjdXN0b21lckNhc2UuU3ViamVjdCk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljIG1ldGhvZCAtIHV0aWxpdHkgZnVuY3Rpb24sIG5vIG9iamVjdCBuZWVkZWRcbiAgICBwdWJsaWMgc3RhdGljIEJvb2xlYW4gaXNIaWdoUHJpb3JpdHlDYXNlKENhc2UgY3VzdG9tZXJDYXNlKSB7XG4gICAgICAgIHJldHVybiBjdXN0b21lckNhc2UuUHJpb3JpdHkgPT0gJ0hpZ2gnIHx8IGN1c3RvbWVyQ2FzZS5Qcmlvcml0eSA9PSAnQ3JpdGljYWwnO1xuICAgICAgICAvLyBObyBhY2Nlc3MgdG8gaW5zdGFuY2UgdmFyaWFibGVzXG4gICAgfVxuXG4gICAgLy8gU3RhdGljIG1ldGhvZCAtIGhlbHBlciBmb3IgY2FsY3VsYXRpb25zXG4gICAgcHVibGljIHN0YXRpYyBEZWNpbWFsIGNhbGN1bGF0ZVNMQShEYXRlVGltZSBjcmVhdGVkLCBTdHJpbmcgcHJpb3JpdHkpIHtcbiAgICAgICAgRGVjaW1hbCBob3VycyA9IDI0OyAvLyBEZWZhdWx0XG4gICAgICAgIGlmIChwcmlvcml0eSA9PSAnSGlnaCcpIGhvdXJzID0gNDtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09ICdDcml0aWNhbCcpIGhvdXJzID0gMTtcbiAgICAgICAgcmV0dXJuIGhvdXJzO1xuICAgIH1cbn1cblxuLy8gVXNhZ2UgZXhhbXBsZXNcbkN1c3RvbWVyU2VydmljZSBzZXJ2aWNlID0gbmV3IEN1c3RvbWVyU2VydmljZSgpO1xuc2VydmljZS5oYW5kbGVDdXN0b21lclJlcXVlc3Qoc29tZUNhc2UpOyAvLyBJbnN0YW5jZSBtZXRob2RcblxuQm9vbGVhbiBpc0hpZ2ggPSBDdXN0b21lclNlcnZpY2UuaXNIaWdoUHJpb3JpdHlDYXNlKHNvbWVDYXNlKTsgLy8gU3RhdGljIG1ldGhvZGAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkluc3RhbmNlIG1ldGhvZHMgZm9yIG9iamVjdC1zcGVjaWZpYyBvcGVyYXRpb25zLCBzdGF0aWMgbWV0aG9kcyBmb3IgdXRpbGl0aWVzIGFuZCBoZWxwZXIgZnVuY3Rpb25zLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlN0YXRpYyBtZXRob2QgcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiB3aGVuIG9iamVjdCBzdGF0ZSBpcyBuZWVkZWQgdnMuIHB1cmUgZnVuY3Rpb25zLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDQsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoYXQgaXMgZW5jYXBzdWxhdGlvbiBhbmQgd2h5IHVzZSBwcml2YXRlIHZhcmlhYmxlcz9cIixcbiAgICAgICAgYW5zd2VyOiBcIkVuY2Fwc3VsYXRpb24gaGlkZXMgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgY29udHJvbHMgYWNjZXNzIHRvIGRhdGEgdGhyb3VnaCBwdWJsaWMgbWV0aG9kc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJQcml2YXRlIHZhcmlhYmxlcyBwcmV2ZW50IGV4dGVybmFsIGNvZGUgZnJvbSBkaXJlY3RseSBtb2RpZnlpbmcgb2JqZWN0IHN0YXRlLiBUaGlzIGVuc3VyZXMgZGF0YSBpbnRlZ3JpdHkgYW5kIGFsbG93cyB5b3UgdG8gY29udHJvbCBob3cgZGF0YSBpcyBhY2Nlc3NlZCBvciBtb2RpZmllZC5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgY2xhc3MgQmFua0FjY291bnQge1xuICAgIC8vIFByaXZhdGUgdmFyaWFibGVzIC0gY2Fubm90IGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gb3V0c2lkZVxuICAgIHByaXZhdGUgRGVjaW1hbCBiYWxhbmNlO1xuICAgIHByaXZhdGUgU3RyaW5nIGFjY291bnROdW1iZXI7XG5cbiAgICBwdWJsaWMgQmFua0FjY291bnQoU3RyaW5nIGFjY051bSwgRGVjaW1hbCBpbml0aWFsQmFsYW5jZSkge1xuICAgICAgICB0aGlzLmFjY291bnROdW1iZXIgPSBhY2NOdW07XG4gICAgICAgIHRoaXMuYmFsYW5jZSA9IGluaXRpYWxCYWxhbmNlO1xuICAgIH1cblxuICAgIC8vIFB1YmxpYyBnZXR0ZXIgLSBjb250cm9sbGVkIHJlYWQgYWNjZXNzXG4gICAgcHVibGljIERlY2ltYWwgZ2V0QmFsYW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWMgbWV0aG9kIHdpdGggdmFsaWRhdGlvbiAtIGNvbnRyb2xsZWQgd3JpdGUgYWNjZXNzXG4gICAgcHVibGljIEJvb2xlYW4gd2l0aGRyYXcoRGVjaW1hbCBhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ0ludmFsaWQgd2l0aGRyYXdhbCBhbW91bnQnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbW91bnQgPiB0aGlzLmJhbGFuY2UpIHtcbiAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnSW5zdWZmaWNpZW50IGZ1bmRzJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJhbGFuY2UgLT0gYW1vdW50OyAvLyBDb250cm9sbGVkIG1vZGlmaWNhdGlvblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBEaXJlY3QgYWNjZXNzIHByZXZlbnRlZDpcbiAgICAvLyBhY2NvdW50LmJhbGFuY2UgPSAtMTAwMDsgLy8gQ09NUElMQVRJT04gRVJST1IgLSBwcml2YXRlIHZhcmlhYmxlXG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiUHJpdmF0ZSB2YXJpYWJsZXMgd2l0aCBwdWJsaWMgbWV0aG9kcyBwcm92aWRlIGNvbnRyb2xsZWQgYWNjZXNzIGFuZCBtYWludGFpbiBkYXRhIGludGVncml0eS5cIixcbiAgICAgICAgZXhhbVRpcDogXCJFbmNhcHN1bGF0aW9uIHF1ZXN0aW9ucyB0ZXN0IHVuZGVyc3RhbmRpbmcgb2YgYWNjZXNzIG1vZGlmaWVycyBhbmQgZGF0YSBwcm90ZWN0aW9uIHByaW5jaXBsZXMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcbiAgICAgICAgcXVlc3Rpb246IFwiWW91ciBjbGFzcyBuZWVkcyB0byB0cmFjayB0b3RhbCByZWNvcmRzIHByb2Nlc3NlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcy4gSG93IGRvIHlvdSBpbXBsZW1lbnQgdGhpcz9cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBhIHN0YXRpYyB2YXJpYWJsZSB0aGF0J3Mgc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjbGFzc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJTdGF0aWMgdmFyaWFibGVzIGJlbG9uZyB0byB0aGUgY2xhc3MsIG5vdCBpbmRpdmlkdWFsIG9iamVjdHMuIEFsbCBpbnN0YW5jZXMgc2hhcmUgdGhlIHNhbWUgc3RhdGljIHZhcmlhYmxlLCBtYWtpbmcgaXQgcGVyZmVjdCBmb3IgdHJhY2tpbmcgZ2xvYmFsIGNvdW50ZXJzIG9yIHNoYXJlZCBzdGF0ZS5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgY2xhc3MgUmVjb3JkUHJvY2Vzc29yIHtcbiAgICAvLyBTdGF0aWMgdmFyaWFibGUgLSBzaGFyZWQgYWNyb3NzIEFMTCBpbnN0YW5jZXNcbiAgICBwcml2YXRlIHN0YXRpYyBJbnRlZ2VyIHRvdGFsUmVjb3Jkc1Byb2Nlc3NlZCA9IDA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgTWFwPFN0cmluZywgSW50ZWdlcj4gcHJvY2Vzc2luZ1N0YXRzID0gbmV3IE1hcDxTdHJpbmcsIEludGVnZXI+KCk7XG5cbiAgICAvLyBJbnN0YW5jZSB2YXJpYWJsZXMgLSB1bmlxdWUgdG8gZWFjaCBvYmplY3RcbiAgICBwcml2YXRlIFN0cmluZyBwcm9jZXNzb3JOYW1lO1xuICAgIHByaXZhdGUgSW50ZWdlciBpbnN0YW5jZVJlY29yZHNQcm9jZXNzZWQ7XG5cbiAgICBwdWJsaWMgUmVjb3JkUHJvY2Vzc29yKFN0cmluZyBuYW1lKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yTmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VSZWNvcmRzUHJvY2Vzc2VkID0gMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgdm9pZCBwcm9jZXNzUmVjb3JkKFNPYmplY3QgcmVjb3JkKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBpbnN0YW5jZSBjb3VudGVyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VSZWNvcmRzUHJvY2Vzc2VkKys7XG5cbiAgICAgICAgLy8gVXBkYXRlIHNoYXJlZCBzdGF0aWMgY291bnRlclxuICAgICAgICB0b3RhbFJlY29yZHNQcm9jZXNzZWQrKztcblxuICAgICAgICAvLyBVcGRhdGUgc2hhcmVkIHN0YXRzXG4gICAgICAgIFN0cmluZyBvYmplY3RUeXBlID0gcmVjb3JkLmdldFNPYmplY3RUeXBlKCkuZ2V0RGVzY3JpYmUoKS5nZXROYW1lKCk7XG4gICAgICAgIEludGVnZXIgY3VycmVudENvdW50ID0gcHJvY2Vzc2luZ1N0YXRzLmdldChvYmplY3RUeXBlKTtcbiAgICAgICAgcHJvY2Vzc2luZ1N0YXRzLnB1dChvYmplY3RUeXBlLCAoY3VycmVudENvdW50ID09IG51bGwgPyAxIDogY3VycmVudENvdW50ICsgMSkpO1xuICAgIH1cblxuICAgIC8vIFN0YXRpYyBtZXRob2QgdG8gYWNjZXNzIHNoYXJlZCBkYXRhXG4gICAgcHVibGljIHN0YXRpYyBJbnRlZ2VyIGdldFRvdGFsUmVjb3Jkc1Byb2Nlc3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRvdGFsUmVjb3Jkc1Byb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIE1hcDxTdHJpbmcsIEludGVnZXI+IGdldFByb2Nlc3NpbmdTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NpbmdTdGF0cy5jbG9uZSgpOyAvLyBSZXR1cm4gY29weSBmb3Igc2FmZXR5XG4gICAgfVxufVxuXG4vLyBVc2FnZSAtIGFsbCBpbnN0YW5jZXMgc2hhcmUgc3RhdGljIHZhcmlhYmxlc1xuUmVjb3JkUHJvY2Vzc29yIHByb2MxID0gbmV3IFJlY29yZFByb2Nlc3NvcignUHJvY2Vzc29yMScpO1xuUmVjb3JkUHJvY2Vzc29yIHByb2MyID0gbmV3IFJlY29yZFByb2Nlc3NvcignUHJvY2Vzc29yMicpO1xuXG5wcm9jMS5wcm9jZXNzUmVjb3JkKHNvbWVBY2NvdW50KTsgIC8vIHRvdGFsUmVjb3Jkc1Byb2Nlc3NlZCA9IDFcbnByb2MyLnByb2Nlc3NSZWNvcmQoc29tZUNvbnRhY3QpOyAgLy8gdG90YWxSZWNvcmRzUHJvY2Vzc2VkID0gMlxuXG5TeXN0ZW0uZGVidWcoUmVjb3JkUHJvY2Vzc29yLmdldFRvdGFsUmVjb3Jkc1Byb2Nlc3NlZCgpKTsgLy8gMmAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlN0YXRpYyB2YXJpYWJsZXMgYXJlIHNoYXJlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcyBhbmQgcGVyc2lzdCBmb3IgdGhlIGVudGlyZSB0cmFuc2FjdGlvbi5cIixcbiAgICAgICAgZXhhbVRpcDogXCJTdGF0aWMgdmFyaWFibGUgcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiBjbGFzcy1sZXZlbCB2cyBpbnN0YW5jZS1sZXZlbCBkYXRhIHNoYXJpbmcuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNixcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSBoYXZlIGEgY2xhc3Mgd2l0aCBib3RoIGEgcGFyYW1ldGVyaXplZCBjb25zdHJ1Y3RvciBhbmQgbmVlZCBhIGRlZmF1bHQgY29uc3RydWN0b3IuIEhvdyBkbyB5b3UgaW1wbGVtZW50IHRoaXM/XCIsXG4gICAgICAgIGFuc3dlcjogXCJDcmVhdGUgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggZGlmZmVyZW50IHBhcmFtZXRlciBsaXN0cyAoY29uc3RydWN0b3Igb3ZlcmxvYWRpbmcpXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIllvdSBjYW4gaGF2ZSBtdWx0aXBsZSBjb25zdHJ1Y3RvcnMgYXMgbG9uZyBhcyB0aGV5IGhhdmUgZGlmZmVyZW50IHBhcmFtZXRlciBzaWduYXR1cmVzLiBUaGlzIGFsbG93cyBmbGV4aWJsZSBvYmplY3QgY3JlYXRpb24gcGF0dGVybnMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIGNsYXNzIEVtYWlsU2VydmljZSB7XG4gICAgcHJpdmF0ZSBTdHJpbmcgc2VydmljZU5hbWU7XG4gICAgcHJpdmF0ZSBTdHJpbmcgZGVmYXVsdFRlbXBsYXRlO1xuICAgIHByaXZhdGUgQm9vbGVhbiBkZWJ1Z01vZGU7XG5cbiAgICAvLyBEZWZhdWx0IGNvbnN0cnVjdG9yXG4gICAgcHVibGljIEVtYWlsU2VydmljZSgpIHtcbiAgICAgICAgdGhpcygnRGVmYXVsdCBFbWFpbCBTZXJ2aWNlJywgJ3N0YW5kYXJkX3RlbXBsYXRlJywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdG9yIHdpdGggc2VydmljZSBuYW1lIG9ubHlcbiAgICBwdWJsaWMgRW1haWxTZXJ2aWNlKFN0cmluZyBuYW1lKSB7XG4gICAgICAgIHRoaXMobmFtZSwgJ3N0YW5kYXJkX3RlbXBsYXRlJywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdG9yIHdpdGggbmFtZSBhbmQgdGVtcGxhdGVcbiAgICBwdWJsaWMgRW1haWxTZXJ2aWNlKFN0cmluZyBuYW1lLCBTdHJpbmcgdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcyhuYW1lLCB0ZW1wbGF0ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIEZ1bGwgY29uc3RydWN0b3IgLSBhbGwgb3RoZXJzIGNhbGwgdGhpcyBvbmVcbiAgICBwdWJsaWMgRW1haWxTZXJ2aWNlKFN0cmluZyBuYW1lLCBTdHJpbmcgdGVtcGxhdGUsIEJvb2xlYW4gZGVidWcpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZGVmYXVsdFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuZGVidWdNb2RlID0gZGVidWc7XG5cbiAgICAgICAgLy8gQ29tbW9uIGluaXRpYWxpemF0aW9uIGxvZ2ljIGluIG9uZSBwbGFjZVxuICAgICAgICB2YWxpZGF0ZUlucHV0cygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCB2YWxpZGF0ZUlucHV0cygpIHtcbiAgICAgICAgaWYgKFN0cmluZy5pc0JsYW5rKHRoaXMuc2VydmljZU5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gJ1VubmFtZWQgU2VydmljZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZy5pc0JsYW5rKHRoaXMuZGVmYXVsdFRlbXBsYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0VGVtcGxhdGUgPSAnYmFzaWNfdGVtcGxhdGUnO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBGbGV4aWJsZSBvYmplY3QgY3JlYXRpb25cbkVtYWlsU2VydmljZSBzZXJ2aWNlMSA9IG5ldyBFbWFpbFNlcnZpY2UoKTtcbkVtYWlsU2VydmljZSBzZXJ2aWNlMiA9IG5ldyBFbWFpbFNlcnZpY2UoJ01hcmtldGluZyBTZXJ2aWNlJyk7XG5FbWFpbFNlcnZpY2Ugc2VydmljZTMgPSBuZXcgRW1haWxTZXJ2aWNlKCdTYWxlcyBTZXJ2aWNlJywgJ3NhbGVzX3RlbXBsYXRlJyk7XG5FbWFpbFNlcnZpY2Ugc2VydmljZTQgPSBuZXcgRW1haWxTZXJ2aWNlKCdEZWJ1ZyBTZXJ2aWNlJywgJ2RlYnVnX3RlbXBsYXRlJywgdHJ1ZSk7YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQ29uc3RydWN0b3Igb3ZlcmxvYWRpbmcgcHJvdmlkZXMgZmxleGlibGUgb2JqZWN0IGNyZWF0aW9uLiBVc2UgY29uc3RydWN0b3IgY2hhaW5pbmcgd2l0aCB0aGlzKCkgdG8gYXZvaWQgY29kZSBkdXBsaWNhdGlvbi5cIixcbiAgICAgICAgZXhhbVRpcDogXCJDb25zdHJ1Y3RvciBvdmVybG9hZGluZyBxdWVzdGlvbnMgdGVzdCB1bmRlcnN0YW5kaW5nIG9mIHBhcmFtZXRlciBzaWduYXR1cmVzIGFuZCBpbml0aWFsaXphdGlvbiBwYXR0ZXJucy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA3LFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGF0IGhhcHBlbnMgaWYgeW91IGRvbid0IGRlZmluZSBhIGNvbnN0cnVjdG9yIGluIHlvdXIgQXBleCBjbGFzcz9cIixcbiAgICAgICAgYW5zd2VyOiBcIkFwZXggYXV0b21hdGljYWxseSBwcm92aWRlcyBhIGRlZmF1bHQgbm8tYXJndW1lbnQgY29uc3RydWN0b3JcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiSWYgeW91IGRvbid0IHdyaXRlIGFueSBjb25zdHJ1Y3RvcnMsIEFwZXggY3JlYXRlcyBhIGRlZmF1bHQgY29uc3RydWN0b3IgdGhhdCB0YWtlcyBubyBwYXJhbWV0ZXJzIGFuZCBkb2VzIG5vdGhpbmcuIEhvd2V2ZXIsIGlmIHlvdSBjcmVhdGUgYW55IGNvbnN0cnVjdG9yLCB0aGUgZGVmYXVsdCBvbmUgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYC8vIENsYXNzIHdpdGhvdXQgZXhwbGljaXQgY29uc3RydWN0b3JcbnB1YmxpYyBjbGFzcyBTaW1wbGVDbGFzcyB7XG4gICAgcHVibGljIFN0cmluZyBuYW1lO1xuICAgIHB1YmxpYyBJbnRlZ2VyIHZhbHVlO1xuXG4gICAgLy8gQXBleCBhdXRvbWF0aWNhbGx5IHByb3ZpZGVzOlxuICAgIC8vIHB1YmxpYyBTaW1wbGVDbGFzcygpIHsgfVxufVxuXG4vLyBVc2FnZSB3b3JrcyBmaW5lXG5TaW1wbGVDbGFzcyBvYmoxID0gbmV3IFNpbXBsZUNsYXNzKCk7IC8vIFVzZXMgZGVmYXVsdCBjb25zdHJ1Y3Rvclxub2JqMS5uYW1lID0gJ1Rlc3QnO1xuXG4vLyBDbGFzcyB3aXRoIGV4cGxpY2l0IGNvbnN0cnVjdG9yXG5wdWJsaWMgY2xhc3MgRXhwbGljaXRDb25zdHJ1Y3RvckNsYXNzIHtcbiAgICBwdWJsaWMgU3RyaW5nIG5hbWU7XG5cbiAgICBwdWJsaWMgRXhwbGljaXRDb25zdHJ1Y3RvckNsYXNzKFN0cmluZyBuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBjb25zdHJ1Y3RvciBOTyBMT05HRVIgUFJPVklERURcbn1cblxuLy8gVGhpcyB3b3VsZCBjYXVzZSBjb21waWxhdGlvbiBlcnJvcjpcbi8vIEV4cGxpY2l0Q29uc3RydWN0b3JDbGFzcyBvYmoyID0gbmV3IEV4cGxpY2l0Q29uc3RydWN0b3JDbGFzcygpOyAvLyBFUlJPUlxuXG4vLyBUaGlzIHdvcmtzOlxuRXhwbGljaXRDb25zdHJ1Y3RvckNsYXNzIG9iajMgPSBuZXcgRXhwbGljaXRDb25zdHJ1Y3RvckNsYXNzKCdWYWxpZCcpO2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkRlZmF1bHQgY29uc3RydWN0b3IgaXMgcHJvdmlkZWQgb25seSBpZiB5b3UgZG9uJ3Qgd3JpdGUgYW55IGNvbnN0cnVjdG9ycy4gV3JpdGluZyBvbmUgY29uc3RydWN0b3IgcmVtb3ZlcyB0aGUgZGVmYXVsdC5cIixcbiAgICAgICAgZXhhbVRpcDogXCJDb25zdHJ1Y3RvciBxdWVzdGlvbnMgb2Z0ZW4gdGVzdCB0aGlzIHJ1bGU6IGV4cGxpY2l0IGNvbnN0cnVjdG9yID0gbm8gbW9yZSBkZWZhdWx0IGNvbnN0cnVjdG9yLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDgsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJIb3cgZG8geW91IHByb3Blcmx5IGhhbmRsZSBudWxsIGNoZWNrcyB3aGVuIHdvcmtpbmcgd2l0aCBvYmplY3RzIGluIG1ldGhvZHM/XCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgbnVsbCBzYWZldHkgcGF0dGVybnMgYW5kIHZhbGlkYXRpb24gYXQgbWV0aG9kIGVudHJ5IHBvaW50c1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJBbHdheXMgdmFsaWRhdGUgb2JqZWN0IHBhcmFtZXRlcnMgYW5kIHVzZSBzYWZlIG5hdmlnYXRpb24gb3IgZXhwbGljaXQgbnVsbCBjaGVja3MgdG8gcHJldmVudCBOdWxsUG9pbnRlckV4Y2VwdGlvbnMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIGNsYXNzIENvbnRhY3RTZXJ2aWNlIHtcblxuICAgIHB1YmxpYyBTdHJpbmcgZ2V0Q29udGFjdERpc3BsYXlOYW1lKENvbnRhY3QgY29uKSB7XG4gICAgICAgIC8vIEd1YXJkIGNsYXVzZSAtIGVhcmx5IHJldHVybiBmb3IgbnVsbFxuICAgICAgICBpZiAoY29uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnVW5rbm93biBDb250YWN0JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhZmUgc3RyaW5nIG9wZXJhdGlvbnNcbiAgICAgICAgU3RyaW5nIGZpcnN0TmFtZSA9IFN0cmluZy5pc0JsYW5rKGNvbi5GaXJzdE5hbWUpID8gJycgOiBjb24uRmlyc3ROYW1lO1xuICAgICAgICBTdHJpbmcgbGFzdE5hbWUgPSBTdHJpbmcuaXNCbGFuayhjb24uTGFzdE5hbWUpID8gJ1Vua25vd24nIDogY29uLkxhc3ROYW1lO1xuXG4gICAgICAgIHJldHVybiBmaXJzdE5hbWUgKyAnICcgKyBsYXN0TmFtZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgQm9vbGVhbiBpc0hpZ2hWYWx1ZUNvbnRhY3QoQ29udGFjdCBjb24pIHtcbiAgICAgICAgLy8gTXVsdGlwbGUgdmFsaWRhdGlvbnNcbiAgICAgICAgaWYgKGNvbj8uQWNjb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYWZlIG5hdmlnYXRpb24gd2l0aCBudWxsIGNvYWxlc2NpbmdcbiAgICAgICAgRGVjaW1hbCByZXZlbnVlID0gY29uLkFjY291bnQuQW5udWFsUmV2ZW51ZSA/PyAwO1xuICAgICAgICByZXR1cm4gcmV2ZW51ZSA+IDEwMDAwMDA7XG4gICAgfVxuXG4gICAgcHVibGljIHZvaWQgdXBkYXRlQ29udGFjdFByZWZlcmVuY2VzKENvbnRhY3QgY29uLCBNYXA8U3RyaW5nLCBPYmplY3Q+IHByZWZzKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGJvdGggcGFyYW1ldGVyc1xuICAgICAgICBpZiAoY29uID09IG51bGwgfHwgcHJlZnMgPT0gbnVsbCB8fCBwcmVmcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnSW52YWxpZCBwYXJhbWV0ZXJzIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYWZlIG1hcCBhY2Nlc3NcbiAgICAgICAgaWYgKHByZWZzLmNvbnRhaW5zS2V5KCdFbWFpbF9PcHRfT3V0X19jJykpIHtcbiAgICAgICAgICAgIGNvbi5FbWFpbF9PcHRfT3V0X19jID0gQm9vbGVhbi52YWx1ZU9mKHByZWZzLmdldCgnRW1haWxfT3B0X091dF9fYycpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGJlZm9yZSBETUxcbiAgICAgICAgaWYgKGNvbi5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGUgY29uO1xuICAgICAgICB9XG4gICAgfVxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlVzZSBndWFyZCBjbGF1c2VzLCBzYWZlIG5hdmlnYXRpb24gKD8uKSwgYW5kIG51bGwgY29hbGVzY2luZyAoPz8pIGZvciByb2J1c3QgbnVsbCBoYW5kbGluZy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJOdWxsIHNhZmV0eSBxdWVzdGlvbnMgdGVzdCBkZWZlbnNpdmUgcHJvZ3JhbW1pbmcgcHJhY3RpY2VzLiBBbHdheXMgdmFsaWRhdGUgaW5wdXRzIGVhcmx5LlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDksXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhZHZhbmNlZCcsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSBuZWVkIGEgdXRpbGl0eSBjbGFzcyB3aXRoIG9ubHkgc3RhdGljIG1ldGhvZHMuIFdoYXQncyB0aGUgYmVzdCBwcmFjdGljZSBmb3IgdGhpcz9cIixcbiAgICAgICAgYW5zd2VyOiBcIk1ha2UgdGhlIGNvbnN0cnVjdG9yIHByaXZhdGUgdG8gcHJldmVudCBpbnN0YW50aWF0aW9uIGFuZCBtYXJrIHRoZSBjbGFzcyBhcyBmaW5hbFwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJVdGlsaXR5IGNsYXNzZXMgc2hvdWxkbid0IGJlIGluc3RhbnRpYXRlZCBzaW5jZSB0aGV5IG9ubHkgY29udGFpbiBzdGF0aWMgbWV0aG9kcy4gQSBwcml2YXRlIGNvbnN0cnVjdG9yIHByZXZlbnRzIG9iamVjdCBjcmVhdGlvbi5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgZmluYWwgY2xhc3MgTWF0aFV0aWxzIHtcblxuICAgIC8vIFByaXZhdGUgY29uc3RydWN0b3IgcHJldmVudHMgaW5zdGFudGlhdGlvblxuICAgIHByaXZhdGUgTWF0aFV0aWxzKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oJ1V0aWxpdHkgY2xhc3MgY2Fubm90IGJlIGluc3RhbnRpYXRlZCcpO1xuICAgIH1cblxuICAgIC8vIEFsbCBtZXRob2RzIGFyZSBzdGF0aWNcbiAgICBwdWJsaWMgc3RhdGljIERlY2ltYWwgY2FsY3VsYXRlVGF4KERlY2ltYWwgYW1vdW50LCBEZWNpbWFsIHJhdGUpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsIHx8IHJhdGUgPT0gbnVsbCB8fCBhbW91bnQgPCAwIHx8IHJhdGUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdJbnZhbGlkIHRheCBjYWxjdWxhdGlvbiBwYXJhbWV0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFtb3VudCAqIChyYXRlIC8gMTAwKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIERlY2ltYWwgY2FsY3VsYXRlRGlzY291bnQoRGVjaW1hbCBvcmlnaW5hbFByaWNlLCBEZWNpbWFsIGRpc2NvdW50UGVyY2VudCkge1xuICAgICAgICBpZiAob3JpZ2luYWxQcmljZSA9PSBudWxsIHx8IGRpc2NvdW50UGVyY2VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxQcmljZTtcbiAgICAgICAgfVxuXG4gICAgICAgIERlY2ltYWwgZGlzY291bnQgPSBvcmlnaW5hbFByaWNlICogKGRpc2NvdW50UGVyY2VudCAvIDEwMCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFByaWNlIC0gZGlzY291bnQ7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBCb29sZWFuIGlzV2l0aGluUmFuZ2UoRGVjaW1hbCB2YWx1ZSwgRGVjaW1hbCBtaW4sIERlY2ltYWwgbWF4KSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbn1cblxuLy8gVXNhZ2UgLSBvbmx5IHN0YXRpYyBtZXRob2QgY2FsbHNcbkRlY2ltYWwgdGF4ID0gTWF0aFV0aWxzLmNhbGN1bGF0ZVRheCgxMDAuMDAsIDguNSk7XG5EZWNpbWFsIGRpc2NvdW50ZWQgPSBNYXRoVXRpbHMuY2FsY3VsYXRlRGlzY291bnQoMTAwLjAwLCAxMCk7XG5cbi8vIFRoaXMgd291bGQgY2F1c2UgZXJyb3I6XG4vLyBNYXRoVXRpbHMgdXRpbCA9IG5ldyBNYXRoVXRpbHMoKTsgLy8gQ09NUElMQVRJT04gRVJST1JgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJVdGlsaXR5IGNsYXNzZXMgdXNlIHByaXZhdGUgY29uc3RydWN0b3JzIGFuZCBzdGF0aWMgbWV0aG9kcyBvbmx5LiBNYXJrIGFzIGZpbmFsIGZvciBjbGFyaXR5LlwiLFxuICAgICAgICBleGFtVGlwOiBcIlV0aWxpdHkgY2xhc3MgcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiBzdGF0aWMtb25seSBkZXNpZ24gcGF0dGVybnMgYW5kIGluc3RhbnRpYXRpb24gcHJldmVudGlvbi5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxMCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkhvdyBkbyB5b3UgaW1wbGVtZW50IGEgY2xhc3MgdGhhdCBuZWVkcyB0byBtYWludGFpbiBhIGNvdW50IG9mIGFsbCBpbnN0YW5jZXMgY3JlYXRlZD9cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBhIHN0YXRpYyB2YXJpYWJsZSBpbmNyZW1lbnRlZCBpbiB0aGUgY29uc3RydWN0b3JcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiU3RhdGljIHZhcmlhYmxlcyBhcmUgc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIGFuZCBwZXJzaXN0IHRocm91Z2hvdXQgdGhlIHRyYW5zYWN0aW9uLiBJbmNyZW1lbnRpbmcgaW4gdGhlIGNvbnN0cnVjdG9yIHRyYWNrcyBldmVyeSBvYmplY3QgY3JlYXRpb24uXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIGNsYXNzIFNlc3Npb25NYW5hZ2VyIHtcbiAgICAvLyBTdGF0aWMgY291bnRlciBzaGFyZWQgYnkgYWxsIGluc3RhbmNlc1xuICAgIHByaXZhdGUgc3RhdGljIEludGVnZXIgaW5zdGFuY2VDb3VudCA9IDA7XG5cbiAgICAvLyBJbnN0YW5jZSB2YXJpYWJsZXNcbiAgICBwcml2YXRlIFN0cmluZyBzZXNzaW9uSWQ7XG4gICAgcHJpdmF0ZSBEYXRlVGltZSBjcmVhdGVkQXQ7XG5cbiAgICBwdWJsaWMgU2Vzc2lvbk1hbmFnZXIoKSB7XG4gICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyIGZvciBldmVyeSBpbnN0YW5jZSBjcmVhdGVkXG4gICAgICAgIGluc3RhbmNlQ291bnQrKztcblxuICAgICAgICB0aGlzLnNlc3Npb25JZCA9ICdTRVNTSU9OXycgKyBpbnN0YW5jZUNvdW50ICsgJ18nICsgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gU3lzdGVtLm5vdygpO1xuXG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnQ3JlYXRlZCBzZXNzaW9uICMnICsgaW5zdGFuY2VDb3VudCArICc6ICcgKyB0aGlzLnNlc3Npb25JZCk7XG4gICAgfVxuXG4gICAgLy8gUGFyYW1ldGVyaXplZCBjb25zdHJ1Y3RvciBhbHNvIGluY3JlbWVudHNcbiAgICBwdWJsaWMgU2Vzc2lvbk1hbmFnZXIoU3RyaW5nIGN1c3RvbUlkKSB7XG4gICAgICAgIHRoaXMoKTsgLy8gQ2FsbCBkZWZhdWx0IGNvbnN0cnVjdG9yIHRvIGluY3JlbWVudCBjb3VudGVyXG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gY3VzdG9tSWQgKyAnXycgKyBpbnN0YW5jZUNvdW50O1xuICAgIH1cblxuICAgIC8vIFN0YXRpYyBtZXRob2QgdG8gYWNjZXNzIGNvdW50XG4gICAgcHVibGljIHN0YXRpYyBJbnRlZ2VyIGdldFRvdGFsSW5zdGFuY2VzQ3JlYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlQ291bnQ7XG4gICAgfVxuXG4gICAgLy8gSW5zdGFuY2UgbWV0aG9kIHRvIGdldCB0aGlzIG9iamVjdCdzIG51bWJlclxuICAgIHB1YmxpYyBTdHJpbmcgZ2V0U2Vzc2lvbkluZm8oKSB7XG4gICAgICAgIHJldHVybiAnU2Vzc2lvbjogJyArIHRoaXMuc2Vzc2lvbklkICsgJyAoQ3JlYXRlZDogJyArIHRoaXMuY3JlYXRlZEF0ICsgJyknO1xuICAgIH1cbn1cblxuLy8gRGVtb25zdHJhdGlvblxuU3lzdGVtLmRlYnVnKCdJbml0aWFsIGNvdW50OiAnICsgU2Vzc2lvbk1hbmFnZXIuZ2V0VG90YWxJbnN0YW5jZXNDcmVhdGVkKCkpOyAvLyAwXG5cblNlc3Npb25NYW5hZ2VyIHNlc3Npb24xID0gbmV3IFNlc3Npb25NYW5hZ2VyKCk7XG5TeXN0ZW0uZGVidWcoJ0FmdGVyIHNlc3Npb24xOiAnICsgU2Vzc2lvbk1hbmFnZXIuZ2V0VG90YWxJbnN0YW5jZXNDcmVhdGVkKCkpOyAvLyAxXG5cblNlc3Npb25NYW5hZ2VyIHNlc3Npb24yID0gbmV3IFNlc3Npb25NYW5hZ2VyKCdDVVNUT00nKTtcblN5c3RlbS5kZWJ1ZygnQWZ0ZXIgc2Vzc2lvbjI6ICcgKyBTZXNzaW9uTWFuYWdlci5nZXRUb3RhbEluc3RhbmNlc0NyZWF0ZWQoKSk7IC8vIDJcblxuTGlzdDxTZXNzaW9uTWFuYWdlcj4gc2Vzc2lvbnMgPSBuZXcgTGlzdDxTZXNzaW9uTWFuYWdlcj4oKTtcbmZvciAoSW50ZWdlciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHNlc3Npb25zLmFkZChuZXcgU2Vzc2lvbk1hbmFnZXIoKSk7XG59XG5TeXN0ZW0uZGVidWcoJ0ZpbmFsIGNvdW50OiAnICsgU2Vzc2lvbk1hbmFnZXIuZ2V0VG90YWxJbnN0YW5jZXNDcmVhdGVkKCkpOyAvLyA1YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiU3RhdGljIHZhcmlhYmxlcyBpbiBjb25zdHJ1Y3RvcnMgdHJhY2sgZ2xvYmFsIGluc3RhbmNlIGNvdW50cyBhY3Jvc3MgYWxsIG9iamVjdCBjcmVhdGlvbi5cIixcbiAgICAgICAgZXhhbVRpcDogXCJJbnN0YW5jZSBjb3VudGluZyBxdWVzdGlvbnMgdGVzdCB1bmRlcnN0YW5kaW5nIG9mIHN0YXRpYyB2YXJpYWJsZSBsaWZlY3ljbGUgYW5kIGNvbnN0cnVjdG9yIGV4ZWN1dGlvbi5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxMSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCdzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcHVibGljLCBwcml2YXRlLCBhbmQgZ2xvYmFsIGFjY2VzcyBtb2RpZmllcnMgaW4gQXBleD9cIixcbiAgICAgICAgYW5zd2VyOiBcInB1YmxpYyA9IGFjY2Vzc2libGUgd2l0aGluIG5hbWVzcGFjZSwgcHJpdmF0ZSA9IHdpdGhpbiBjbGFzcyBvbmx5LCBnbG9iYWwgPSBhY2Nlc3NpYmxlIGV2ZXJ5d2hlcmVcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiQWNjZXNzIG1vZGlmaWVycyBjb250cm9sIHZpc2liaWxpdHkuIFByaXZhdGUgaXMgbW9zdCByZXN0cmljdGl2ZSAoY2xhc3Mgb25seSksIHB1YmxpYyBhbGxvd3MgYWNjZXNzIHdpdGhpbiB0aGUgc2FtZSBuYW1lc3BhY2UsIGdsb2JhbCBhbGxvd3MgYWNjZXNzIGZyb20gYW55d2hlcmUgaW5jbHVkaW5nIG1hbmFnZWQgcGFja2FnZXMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIGNsYXNzIEFjY2Vzc01vZGlmaWVyRGVtbyB7XG5cbiAgICAvLyBQcml2YXRlIC0gb25seSB0aGlzIGNsYXNzIGNhbiBhY2Nlc3NcbiAgICBwcml2YXRlIFN0cmluZyBpbnRlcm5hbERhdGEgPSAnc2VjcmV0JztcblxuICAgIC8vIFB1YmxpYyAtIGFjY2Vzc2libGUgd2l0aGluIHNhbWUgbmFtZXNwYWNlXG4gICAgcHVibGljIFN0cmluZyBwdWJsaWNEYXRhID0gJ3NoYXJlZCc7XG5cbiAgICAvLyBHbG9iYWwgLSBhY2Nlc3NpYmxlIGZyb20gYW55d2hlcmUgKHVzZSBzcGFyaW5nbHkpXG4gICAgZ2xvYmFsIFN0cmluZyBnbG9iYWxEYXRhID0gJ3VuaXZlcnNhbCc7XG5cbiAgICAvLyBQcml2YXRlIG1ldGhvZCAtIGludGVybmFsIHVzZSBvbmx5XG4gICAgcHJpdmF0ZSB2b2lkIGludGVybmFsUHJvY2VzcygpIHtcbiAgICAgICAgU3lzdGVtLmRlYnVnKCdJbnRlcm5hbCBwcm9jZXNzaW5nOiAnICsgdGhpcy5pbnRlcm5hbERhdGEpO1xuICAgIH1cblxuICAgIC8vIFB1YmxpYyBtZXRob2QgLSBuYW1lc3BhY2UgYWNjZXNzXG4gICAgcHVibGljIHZvaWQgcHJvY2Vzc0RhdGEoKSB7XG4gICAgICAgIGludGVybmFsUHJvY2VzcygpOyAvLyBDYW4gY2FsbCBwcml2YXRlIG1ldGhvZFxuICAgICAgICBTeXN0ZW0uZGVidWcoJ1Byb2Nlc3Npbmc6ICcgKyB0aGlzLnB1YmxpY0RhdGEpO1xuICAgIH1cblxuICAgIC8vIEdsb2JhbCBtZXRob2QgLSB1bml2ZXJzYWwgYWNjZXNzXG4gICAgZ2xvYmFsIHZvaWQgZ2xvYmFsUHJvY2VzcygpIHtcbiAgICAgICAgU3lzdGVtLmRlYnVnKCdHbG9iYWwgcHJvY2Vzc2luZzogJyArIHRoaXMuZ2xvYmFsRGF0YSk7XG4gICAgfVxufVxuXG4vLyBJbiBzYW1lIG5hbWVzcGFjZTpcbkFjY2Vzc01vZGlmaWVyRGVtbyBkZW1vID0gbmV3IEFjY2Vzc01vZGlmaWVyRGVtbygpO1xuU3lzdGVtLmRlYnVnKGRlbW8ucHVibGljRGF0YSk7ICAvLyBXb3Jrc1xuZGVtby5wcm9jZXNzRGF0YSgpOyAgICAgICAgICAgICAvLyBXb3Jrc1xuLy8gU3lzdGVtLmRlYnVnKGRlbW8uaW50ZXJuYWxEYXRhKTsgLy8gQ09NUElMQVRJT04gRVJST1IgLSBwcml2YXRlXG5cbi8vIEZyb20gbWFuYWdlZCBwYWNrYWdlIG9yIG90aGVyIG5hbWVzcGFjZTpcbi8vIE9ubHkgZ2xvYmFsIG1lbWJlcnMgd291bGQgYmUgYWNjZXNzaWJsZWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlVzZSBwcml2YXRlIGZvciBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiwgcHVibGljIGZvciBuYW1lc3BhY2Ugc2hhcmluZywgZ2xvYmFsIG9ubHkgd2hlbiBuZWNlc3NhcnkgZm9yIGV4dGVybmFsIGFjY2Vzcy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJBY2Nlc3MgbW9kaWZpZXIgcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiB2aXNpYmlsaXR5IHNjb3BlLiBHbG9iYWwgc2hvdWxkIGJlIHVzZWQgc3BhcmluZ2x5LlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDEyLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYWR2YW5jZWQnLFxuICAgICAgICBxdWVzdGlvbjogXCJIb3cgZG8geW91IGltcGxlbWVudCBhIHNpbmdsZXRvbiBwYXR0ZXJuIGluIEFwZXggdG8gZW5zdXJlIG9ubHkgb25lIGluc3RhbmNlIGV4aXN0cz9cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBhIHByaXZhdGUgY29uc3RydWN0b3IsIHN0YXRpYyB2YXJpYWJsZSB0byBob2xkIHRoZSBpbnN0YW5jZSwgYW5kIHN0YXRpYyBtZXRob2QgdG8gZ2V0IGl0XCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIlNpbmdsZXRvbiBwYXR0ZXJuIGVuc3VyZXMgb25seSBvbmUgaW5zdGFuY2UgZXhpc3RzIHRocm91Z2hvdXQgdGhlIHRyYW5zYWN0aW9uLiBVc2Ugc3RhdGljIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBzaW5nbGUgaW5zdGFuY2UgYW5kIGNvbnRyb2wgYWNjZXNzIHRocm91Z2ggYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBjbGFzcyBDb25maWd1cmF0aW9uTWFuYWdlciB7XG4gICAgLy8gU3RhdGljIHZhcmlhYmxlIHRvIGhvbGQgdGhlIHNpbmdsZSBpbnN0YW5jZVxuICAgIHByaXZhdGUgc3RhdGljIENvbmZpZ3VyYXRpb25NYW5hZ2VyIGluc3RhbmNlO1xuXG4gICAgLy8gSW5zdGFuY2UgdmFyaWFibGVzXG4gICAgcHJpdmF0ZSBNYXA8U3RyaW5nLCBTdHJpbmc+IHNldHRpbmdzO1xuICAgIHByaXZhdGUgRGF0ZVRpbWUgbGFzdFVwZGF0ZWQ7XG5cbiAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yIHByZXZlbnRzIGV4dGVybmFsIGluc3RhbnRpYXRpb25cbiAgICBwcml2YXRlIENvbmZpZ3VyYXRpb25NYW5hZ2VyKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gbmV3IE1hcDxTdHJpbmcsIFN0cmluZz4oKTtcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IFN5c3RlbS5ub3coKTtcbiAgICAgICAgbG9hZERlZmF1bHRTZXR0aW5ncygpO1xuICAgIH1cblxuICAgIC8vIFN0YXRpYyBtZXRob2QgdG8gZ2V0IHRoZSBzaW5nbGUgaW5zdGFuY2VcbiAgICBwdWJsaWMgc3RhdGljIENvbmZpZ3VyYXRpb25NYW5hZ2VyIGdldEluc3RhbmNlKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSBuZXcgQ29uZmlndXJhdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLy8gQnVzaW5lc3MgbWV0aG9kc1xuICAgIHB1YmxpYyBTdHJpbmcgZ2V0U2V0dGluZyhTdHJpbmcga2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmdldChrZXkpO1xuICAgIH1cblxuICAgIHB1YmxpYyB2b2lkIHNldFNldHRpbmcoU3RyaW5nIGtleSwgU3RyaW5nIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucHV0KGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGVkID0gU3lzdGVtLm5vdygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCBsb2FkRGVmYXVsdFNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnB1dCgnZGVidWdfbW9kZScsICdmYWxzZScpO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnB1dCgndGltZW91dF9zZWNvbmRzJywgJzMwJyk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucHV0KCdtYXhfcmVjb3JkcycsICcyMDAnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgSW50ZWdlciBnZXRTZXR0aW5nc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5zaXplKCk7XG4gICAgfVxufVxuXG4vLyBVc2FnZSAtIGFsd2F5cyByZXR1cm5zIHNhbWUgaW5zdGFuY2VcbkNvbmZpZ3VyYXRpb25NYW5hZ2VyIGNvbmZpZzEgPSBDb25maWd1cmF0aW9uTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuQ29uZmlndXJhdGlvbk1hbmFnZXIgY29uZmlnMiA9IENvbmZpZ3VyYXRpb25NYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cbmNvbmZpZzEuc2V0U2V0dGluZygnZGVidWdfbW9kZScsICd0cnVlJyk7XG5TeXN0ZW0uZGVidWcoY29uZmlnMi5nZXRTZXR0aW5nKCdkZWJ1Z19tb2RlJykpOyAvLyAndHJ1ZScgLSBzYW1lIGluc3RhbmNlXG5cblN5c3RlbS5kZWJ1Zyhjb25maWcxID09PSBjb25maWcyKTsgLy8gdHJ1ZSAtIGV4YWN0IHNhbWUgb2JqZWN0XG5cbi8vIFRoaXMgd291bGQgY2F1c2UgZXJyb3I6XG4vLyBDb25maWd1cmF0aW9uTWFuYWdlciBjb25maWczID0gbmV3IENvbmZpZ3VyYXRpb25NYW5hZ2VyKCk7IC8vIEVSUk9SYCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiU2luZ2xldG9uIHBhdHRlcm4gdXNlcyBwcml2YXRlIGNvbnN0cnVjdG9yIGFuZCBzdGF0aWMgZ2V0SW5zdGFuY2UoKSBtZXRob2QgdG8gZW5zdXJlIHNpbmdsZSBpbnN0YW5jZSBwZXIgdHJhbnNhY3Rpb24uXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiU2luZ2xldG9uIHF1ZXN0aW9ucyB0ZXN0IHVuZGVyc3RhbmRpbmcgb2YgaW5zdGFuY2UgY29udHJvbCBhbmQgc3RhdGljIHZhcmlhYmxlIHVzYWdlIGZvciBzaGFyZWQgc3RhdGUuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTMsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJZb3VyIGNsYXNzIG5lZWRzIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMgb2YgU2FsZXNmb3JjZSBvYmplY3RzLiBIb3cgZG8geW91IG1ha2UgaXQgZ2VuZXJpYz9cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBTT2JqZWN0IGFzIHBhcmFtZXRlciB0eXBlIGFuZCBnZXRTT2JqZWN0VHlwZSgpIGZvciB0eXBlLXNwZWNpZmljIG9wZXJhdGlvbnNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiU09iamVjdCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIFNhbGVzZm9yY2Ugb2JqZWN0cy4gVXNpbmcgU09iamVjdCBwYXJhbWV0ZXJzIG1ha2VzIHlvdXIgY2xhc3Mgd29yayB3aXRoIGFueSBzdGFuZGFyZCBvciBjdXN0b20gb2JqZWN0LlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBjbGFzcyBHZW5lcmljUmVjb3JkUHJvY2Vzc29yIHtcblxuICAgIHB1YmxpYyB2b2lkIHByb2Nlc3NSZWNvcmRzKExpc3Q8U09iamVjdD4gcmVjb3Jkcykge1xuICAgICAgICBpZiAocmVjb3JkcyA9PSBudWxsIHx8IHJlY29yZHMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgb2JqZWN0IHR5cGUgZm9yIHR5cGUtc3BlY2lmaWMgbG9naWNcbiAgICAgICAgU3RyaW5nIG9iamVjdFR5cGUgPSByZWNvcmRzWzBdLmdldFNPYmplY3RUeXBlKCkuZ2V0RGVzY3JpYmUoKS5nZXROYW1lKCk7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnUHJvY2Vzc2luZyAnICsgcmVjb3Jkcy5zaXplKCkgKyAnICcgKyBvYmplY3RUeXBlICsgJyByZWNvcmRzJyk7XG5cbiAgICAgICAgZm9yIChTT2JqZWN0IHJlY29yZCA6IHJlY29yZHMpIHtcbiAgICAgICAgICAgIHByb2Nlc3NJbmRpdmlkdWFsUmVjb3JkKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHZvaWQgcHJvY2Vzc0luZGl2aWR1YWxSZWNvcmQoU09iamVjdCByZWNvcmQpIHtcbiAgICAgICAgU3RyaW5nIG9iamVjdE5hbWUgPSByZWNvcmQuZ2V0U09iamVjdFR5cGUoKS5nZXREZXNjcmliZSgpLmdldE5hbWUoKTtcblxuICAgICAgICAvLyBUeXBlLXNwZWNpZmljIHByb2Nlc3NpbmdcbiAgICAgICAgaWYgKG9iamVjdE5hbWUgPT0gJ0FjY291bnQnKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWNjb3VudCgoQWNjb3VudClyZWNvcmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdE5hbWUgPT0gJ0NvbnRhY3QnKSB7XG4gICAgICAgICAgICBwcm9jZXNzQ29udGFjdCgoQ29udGFjdClyZWNvcmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdE5hbWUgPT0gJ09wcG9ydHVuaXR5Jykge1xuICAgICAgICAgICAgcHJvY2Vzc09wcG9ydHVuaXR5KChPcHBvcnR1bml0eSlyZWNvcmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc0dlbmVyaWNSZWNvcmQocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCBwcm9jZXNzQWNjb3VudChBY2NvdW50IGFjYykge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ1Byb2Nlc3NpbmcgQWNjb3VudDogJyArIGFjYy5OYW1lKTtcbiAgICAgICAgLy8gQWNjb3VudC1zcGVjaWZpYyBsb2dpY1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCBwcm9jZXNzQ29udGFjdChDb250YWN0IGNvbikge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ1Byb2Nlc3NpbmcgQ29udGFjdDogJyArIGNvbi5OYW1lKTtcbiAgICAgICAgLy8gQ29udGFjdC1zcGVjaWZpYyBsb2dpY1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCBwcm9jZXNzT3Bwb3J0dW5pdHkoT3Bwb3J0dW5pdHkgb3BwKSB7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnUHJvY2Vzc2luZyBPcHBvcnR1bml0eTogJyArIG9wcC5OYW1lKTtcbiAgICAgICAgLy8gT3Bwb3J0dW5pdHktc3BlY2lmaWMgbG9naWNcbiAgICB9XG5cbiAgICBwcml2YXRlIHZvaWQgcHJvY2Vzc0dlbmVyaWNSZWNvcmQoU09iamVjdCByZWNvcmQpIHtcbiAgICAgICAgU3lzdGVtLmRlYnVnKCdQcm9jZXNzaW5nIGdlbmVyaWMgcmVjb3JkOiAnICsgcmVjb3JkLklkKTtcbiAgICAgICAgLy8gR2VuZXJpYyBwcm9jZXNzaW5nIGZvciBhbnkgb2JqZWN0IHR5cGVcbiAgICB9XG59XG5cbi8vIFVzYWdlIHdpdGggZGlmZmVyZW50IG9iamVjdCB0eXBlc1xuR2VuZXJpY1JlY29yZFByb2Nlc3NvciBwcm9jZXNzb3IgPSBuZXcgR2VuZXJpY1JlY29yZFByb2Nlc3NvcigpO1xuXG5MaXN0PEFjY291bnQ+IGFjY291bnRzID0gW1NFTEVDVCBJZCwgTmFtZSBGUk9NIEFjY291bnQgTElNSVQgNV07XG5wcm9jZXNzb3IucHJvY2Vzc1JlY29yZHMoYWNjb3VudHMpO1xuXG5MaXN0PENvbnRhY3Q+IGNvbnRhY3RzID0gW1NFTEVDVCBJZCwgTmFtZSBGUk9NIENvbnRhY3QgTElNSVQgNV07XG5wcm9jZXNzb3IucHJvY2Vzc1JlY29yZHMoY29udGFjdHMpO2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlVzZSBTT2JqZWN0IGZvciBnZW5lcmljIHByb2dyYW1taW5nLiBVc2UgZ2V0U09iamVjdFR5cGUoKSBhbmQgY2FzdGluZyBmb3IgdHlwZS1zcGVjaWZpYyBvcGVyYXRpb25zLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkdlbmVyaWMgcHJvZ3JhbW1pbmcgcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiBTT2JqZWN0IGhpZXJhcmNoeSBhbmQgdHlwZSBjaGVja2luZyBwYXR0ZXJucy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxNCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcbiAgICAgICAgcXVlc3Rpb246IFwiSG93IGRvIHlvdSBpbXBsZW1lbnQgYSBmYWN0b3J5IHBhdHRlcm4gdG8gY3JlYXRlIGRpZmZlcmVudCB0eXBlcyBvZiBvYmplY3RzIGJhc2VkIG9uIGlucHV0P1wiLFxuICAgICAgICBhbnN3ZXI6IFwiVXNlIGEgc3RhdGljIGZhY3RvcnkgbWV0aG9kIHRoYXQgcmV0dXJucyBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIGJhc2VkIG9uIHBhcmFtZXRlcnNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiRmFjdG9yeSBwYXR0ZXJuIGNlbnRyYWxpemVzIG9iamVjdCBjcmVhdGlvbiBsb2dpYy4gVXNlIGEgc3RhdGljIG1ldGhvZCB0aGF0IHRha2VzIHBhcmFtZXRlcnMgYW5kIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIG9iamVjdCB0eXBlLCBvZnRlbiB1c2luZyBpbmhlcml0YW5jZSBvciBpbnRlcmZhY2VzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYC8vIEJhc2UgaW50ZXJmYWNlIGZvciBhbGwgbm90aWZpY2F0aW9uIHR5cGVzXG5wdWJsaWMgaW50ZXJmYWNlIE5vdGlmaWNhdGlvblNlcnZpY2Uge1xuICAgIHZvaWQgc2VuZE5vdGlmaWNhdGlvbihTdHJpbmcgbWVzc2FnZSwgU3RyaW5nIHJlY2lwaWVudCk7XG4gICAgQm9vbGVhbiBpc0F2YWlsYWJsZSgpO1xufVxuXG4vLyBFbWFpbCBpbXBsZW1lbnRhdGlvblxucHVibGljIGNsYXNzIEVtYWlsTm90aWZpY2F0aW9uU2VydmljZSBpbXBsZW1lbnRzIE5vdGlmaWNhdGlvblNlcnZpY2Uge1xuICAgIHB1YmxpYyB2b2lkIHNlbmROb3RpZmljYXRpb24oU3RyaW5nIG1lc3NhZ2UsIFN0cmluZyByZWNpcGllbnQpIHtcbiAgICAgICAgU3lzdGVtLmRlYnVnKCdTZW5kaW5nIGVtYWlsIHRvICcgKyByZWNpcGllbnQgKyAnOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIC8vIEVtYWlsLXNwZWNpZmljIGxvZ2ljXG4gICAgfVxuXG4gICAgcHVibGljIEJvb2xlYW4gaXNBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBFbWFpbCBhbHdheXMgYXZhaWxhYmxlXG4gICAgfVxufVxuXG4vLyBTTVMgaW1wbGVtZW50YXRpb25cbnB1YmxpYyBjbGFzcyBTTVNOb3RpZmljYXRpb25TZXJ2aWNlIGltcGxlbWVudHMgTm90aWZpY2F0aW9uU2VydmljZSB7XG4gICAgcHVibGljIHZvaWQgc2VuZE5vdGlmaWNhdGlvbihTdHJpbmcgbWVzc2FnZSwgU3RyaW5nIHJlY2lwaWVudCkge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ1NlbmRpbmcgU01TIHRvICcgKyByZWNpcGllbnQgKyAnOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIC8vIFNNUy1zcGVjaWZpYyBsb2dpY1xuICAgIH1cblxuICAgIHB1YmxpYyBCb29sZWFuIGlzQXZhaWxhYmxlKCkge1xuICAgICAgICAvLyBDaGVjayBTTVMgc2VydmljZSBhdmFpbGFiaWxpdHlcbiAgICAgICAgcmV0dXJuIFN5c3RlbS5ub3coKS5ob3VyKCkgPj0gOCAmJiBTeXN0ZW0ubm93KCkuaG91cigpIDw9IDIyO1xuICAgIH1cbn1cblxuLy8gU2xhY2sgaW1wbGVtZW50YXRpb25cbnB1YmxpYyBjbGFzcyBTbGFja05vdGlmaWNhdGlvblNlcnZpY2UgaW1wbGVtZW50cyBOb3RpZmljYXRpb25TZXJ2aWNlIHtcbiAgICBwdWJsaWMgdm9pZCBzZW5kTm90aWZpY2F0aW9uKFN0cmluZyBtZXNzYWdlLCBTdHJpbmcgcmVjaXBpZW50KSB7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnU2VuZGluZyBTbGFjayBtZXNzYWdlIHRvICcgKyByZWNpcGllbnQgKyAnOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIC8vIFNsYWNrLXNwZWNpZmljIGxvZ2ljXG4gICAgfVxuXG4gICAgcHVibGljIEJvb2xlYW4gaXNBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBTbGFjayBhbHdheXMgYXZhaWxhYmxlXG4gICAgfVxufVxuXG4vLyBGYWN0b3J5IGNsYXNzXG5wdWJsaWMgY2xhc3MgTm90aWZpY2F0aW9uRmFjdG9yeSB7XG5cbiAgICAvLyBGYWN0b3J5IG1ldGhvZCAtIGNyZWF0ZXMgYXBwcm9wcmlhdGUgbm90aWZpY2F0aW9uIHNlcnZpY2VcbiAgICBwdWJsaWMgc3RhdGljIE5vdGlmaWNhdGlvblNlcnZpY2UgY3JlYXRlTm90aWZpY2F0aW9uU2VydmljZShTdHJpbmcgdHlwZSkge1xuICAgICAgICBpZiAoU3RyaW5nLmlzQmxhbmsodHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ05vdGlmaWNhdGlvbiB0eXBlIGNhbm5vdCBiZSBibGFuaycpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIG9uIHR5cGUudG9Mb3dlckNhc2UoKSB7XG4gICAgICAgICAgICB3aGVuICdlbWFpbCcge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW1haWxOb3RpZmljYXRpb25TZXJ2aWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGVuICdzbXMnIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNNU05vdGlmaWNhdGlvblNlcnZpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoZW4gJ3NsYWNrJyB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTbGFja05vdGlmaWNhdGlvblNlcnZpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoZW4gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKCdVbmtub3duIG5vdGlmaWNhdGlvbiB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBtZXRob2Qgd2l0aCBmYWxsYmFjayBsb2dpY1xuICAgIHB1YmxpYyBzdGF0aWMgTm90aWZpY2F0aW9uU2VydmljZSBjcmVhdGVBdmFpbGFibGVTZXJ2aWNlKFN0cmluZyBwcmVmZXJyZWRUeXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBOb3RpZmljYXRpb25TZXJ2aWNlIHNlcnZpY2UgPSBjcmVhdGVOb3RpZmljYXRpb25TZXJ2aWNlKHByZWZlcnJlZFR5cGUpO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2UuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChFeGNlcHRpb24gZSkge1xuICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdQcmVmZXJyZWQgc2VydmljZSB1bmF2YWlsYWJsZTogJyArIGUuZ2V0TWVzc2FnZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGVtYWlsXG4gICAgICAgIHJldHVybiBuZXcgRW1haWxOb3RpZmljYXRpb25TZXJ2aWNlKCk7XG4gICAgfVxufVxuXG4vLyBVc2FnZVxuTm90aWZpY2F0aW9uU2VydmljZSBlbWFpbFNlcnZpY2UgPSBOb3RpZmljYXRpb25GYWN0b3J5LmNyZWF0ZU5vdGlmaWNhdGlvblNlcnZpY2UoJ2VtYWlsJyk7XG5lbWFpbFNlcnZpY2Uuc2VuZE5vdGlmaWNhdGlvbignV2VsY29tZSEnLCAndXNlckBleGFtcGxlLmNvbScpO1xuXG5Ob3RpZmljYXRpb25TZXJ2aWNlIHNtc1NlcnZpY2UgPSBOb3RpZmljYXRpb25GYWN0b3J5LmNyZWF0ZU5vdGlmaWNhdGlvblNlcnZpY2UoJ3NtcycpO1xuaWYgKHNtc1NlcnZpY2UuaXNBdmFpbGFibGUoKSkge1xuICAgIHNtc1NlcnZpY2Uuc2VuZE5vdGlmaWNhdGlvbignQWxlcnQhJywgJysxMjM0NTY3ODkwJyk7XG59XG5cbi8vIFdpdGggYXV0b21hdGljIGZhbGxiYWNrXG5Ob3RpZmljYXRpb25TZXJ2aWNlIHNlcnZpY2UgPSBOb3RpZmljYXRpb25GYWN0b3J5LmNyZWF0ZUF2YWlsYWJsZVNlcnZpY2UoJ3NtcycpO1xuc2VydmljZS5zZW5kTm90aWZpY2F0aW9uKCdJbXBvcnRhbnQgbWVzc2FnZScsICdyZWNpcGllbnQnKTtgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJGYWN0b3J5IHBhdHRlcm4gY2VudHJhbGl6ZXMgb2JqZWN0IGNyZWF0aW9uLiBVc2UgaW50ZXJmYWNlcyBmb3IgY29uc2lzdGVudCBiZWhhdmlvciBhY3Jvc3MgZGlmZmVyZW50IGltcGxlbWVudGF0aW9ucy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJGYWN0b3J5IHBhdHRlcm4gcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiBvYmplY3QgY3JlYXRpb24gc3RyYXRlZ2llcyBhbmQgcG9seW1vcnBoaXNtLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDE1LFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGF0J3MgdGhlIHB1cnBvc2Ugb2YgdGhlICd0aGlzJyBrZXl3b3JkIGluIEFwZXg/XCIsXG4gICAgICAgIGFuc3dlcjogXCJSZWZlcnMgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIGNsYXNzLCB1c2VkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBpbnN0YW5jZSB2YXJpYWJsZXMgYW5kIHBhcmFtZXRlcnNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiJ3RoaXMnIGV4cGxpY2l0bHkgcmVmZXJzIHRvIHRoZSBjdXJyZW50IG9iamVjdC4gSXQncyB1c2VmdWwgd2hlbiBwYXJhbWV0ZXIgbmFtZXMgbWF0Y2ggaW5zdGFuY2UgdmFyaWFibGUgbmFtZXMgb3Igd2hlbiB5b3Ugd2FudCB0byBiZSBleHBsaWNpdCBhYm91dCBhY2Nlc3NpbmcgaW5zdGFuY2UgbWVtYmVycy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgY2xhc3MgRW1wbG95ZWUge1xuICAgIHByaXZhdGUgU3RyaW5nIG5hbWU7XG4gICAgcHJpdmF0ZSBTdHJpbmcgZGVwYXJ0bWVudDtcbiAgICBwcml2YXRlIEludGVnZXIgc2FsYXJ5O1xuXG4gICAgLy8gQ29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXIgbmFtZXMgbWF0Y2hpbmcgaW5zdGFuY2UgdmFyaWFibGVzXG4gICAgcHVibGljIEVtcGxveWVlKFN0cmluZyBuYW1lLCBTdHJpbmcgZGVwYXJ0bWVudCwgSW50ZWdlciBzYWxhcnkpIHtcbiAgICAgICAgLy8gV2l0aG91dCAndGhpcycsIHlvdSdkIGFzc2lnbiBwYXJhbWV0ZXIgdG8gaXRzZWxmXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7ICAgICAgICAgICAvLyB0aGlzLm5hbWUgPSBpbnN0YW5jZSB2YXJpYWJsZVxuICAgICAgICB0aGlzLmRlcGFydG1lbnQgPSBkZXBhcnRtZW50OyAvLyBuYW1lID0gcGFyYW1ldGVyXG4gICAgICAgIHRoaXMuc2FsYXJ5ID0gc2FsYXJ5O1xuICAgIH1cblxuICAgIC8vIE1ldGhvZCBzaG93aW5nIGRpZmZlcmVudCB1c2VzIG9mICd0aGlzJ1xuICAgIHB1YmxpYyB2b2lkIHVwZGF0ZUVtcGxveWVlKFN0cmluZyBuYW1lLCBTdHJpbmcgZGVwYXJ0bWVudCkge1xuICAgICAgICAvLyBFeHBsaWNpdCByZWZlcmVuY2UgdG8gaW5zdGFuY2UgdmFyaWFibGVzXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZGVwYXJ0bWVudCA9IGRlcGFydG1lbnQ7XG5cbiAgICAgICAgLy8gQ2FsbGluZyBhbm90aGVyIG1ldGhvZCBvbiB0aGlzIG9iamVjdFxuICAgICAgICB0aGlzLnZhbGlkYXRlRW1wbG95ZWUoKTtcblxuICAgICAgICAvLyBQYXNzIGN1cnJlbnQgb2JqZWN0IHRvIGFub3RoZXIgbWV0aG9kXG4gICAgICAgIEVtcGxveWVlVmFsaWRhdG9yLnZhbGlkYXRlKHRoaXMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCB2YWxpZGF0ZUVtcGxveWVlKCkge1xuICAgICAgICAvLyAndGhpcycgaXMgb3B0aW9uYWwgd2hlbiBubyBuYW1pbmcgY29uZmxpY3RzXG4gICAgICAgIGlmIChTdHJpbmcuaXNCbGFuayhuYW1lKSkgeyAvLyBDb3VsZCB3cml0ZSB0aGlzLm5hbWVcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0VtcGxveWVlIG5hbWUgY2Fubm90IGJlIGJsYW5rJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gY3VycmVudCBvYmplY3QgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgIHB1YmxpYyBFbXBsb3llZSBzZXRTYWxhcnkoSW50ZWdlciBuZXdTYWxhcnkpIHtcbiAgICAgICAgdGhpcy5zYWxhcnkgPSBuZXdTYWxhcnk7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBSZXR1cm4gY3VycmVudCBvYmplY3RcbiAgICB9XG5cbiAgICBwdWJsaWMgRW1wbG95ZWUgc2V0RGVwYXJ0bWVudChTdHJpbmcgbmV3RGVwYXJ0bWVudCkge1xuICAgICAgICB0aGlzLmRlcGFydG1lbnQgPSBuZXdEZXBhcnRtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8vIE1ldGhvZCBjaGFpbmluZyBleGFtcGxlXG5FbXBsb3llZSBlbXAgPSBuZXcgRW1wbG95ZWUoJ0pvaG4gRG9lJywgJ1NhbGVzJywgNTAwMDApO1xuZW1wLnNldFNhbGFyeSg1NTAwMCkuc2V0RGVwYXJ0bWVudCgnTWFya2V0aW5nJyk7YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiVXNlICd0aGlzJyB0byByZXNvbHZlIG5hbWluZyBjb25mbGljdHMgYW5kIGZvciBleHBsaWNpdCBpbnN0YW5jZSBtZW1iZXIgYWNjZXNzLiBBbHNvIGVuYWJsZXMgbWV0aG9kIGNoYWluaW5nLlwiLFxuICAgICAgICBleGFtVGlwOiBcIid0aGlzJyBrZXl3b3JkIHF1ZXN0aW9ucyB0ZXN0IHVuZGVyc3RhbmRpbmcgb2Ygb2JqZWN0IHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVyIHZzIGluc3RhbmNlIHZhcmlhYmxlIGRpc2FtYmlndWF0aW9uLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDE2LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiSG93IGRvIHlvdSBwcm9wZXJseSBpbXBsZW1lbnQgYSBjbGFzcyB0aGF0IGhhbmRsZXMgZXhjZXB0aW9ucyBhbmQgZXJyb3IgbG9nZ2luZz9cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSB0cnktY2F0Y2ggYmxvY2tzLCBjdXN0b20gZXhjZXB0aW9ucywgYW5kIHByb3BlciBsb2dnaW5nIHBhdHRlcm5zIHdpdGggZGlmZmVyZW50IGVycm9yIGxldmVsc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJHb29kIGVycm9yIGhhbmRsaW5nIGluY2x1ZGVzIHNwZWNpZmljIGV4Y2VwdGlvbiB0eXBlcywgcHJvcGVyIGxvZ2dpbmcsIGFuZCBncmFjZWZ1bCBmYWlsdXJlIG1vZGVzLiBBbHdheXMgbG9nIGVub3VnaCBpbmZvcm1hdGlvbiBmb3IgZGVidWdnaW5nIHdpdGhvdXQgZXhwb3Npbmcgc2Vuc2l0aXZlIGRhdGEuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIGNsYXNzIEN1c3RvbWVyRGF0YVNlcnZpY2Uge1xuXG4gICAgLy8gQ3VzdG9tIGV4Y2VwdGlvbiBmb3IgYnVzaW5lc3MgbG9naWMgZXJyb3JzXG4gICAgcHVibGljIGNsYXNzIEN1c3RvbWVyRGF0YUV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7fVxuXG4gICAgcHVibGljIEJvb2xlYW4gcHJvY2Vzc0N1c3RvbWVyRGF0YShMaXN0PEN1c3RvbWVyX19jPiBjdXN0b21lcnMpIHtcbiAgICAgICAgaWYgKGN1c3RvbWVycyA9PSBudWxsIHx8IGN1c3RvbWVycy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZyhMb2dnaW5nTGV2ZWwuV0FSTiwgJ05vIGN1c3RvbWVycyBwcm92aWRlZCBmb3IgcHJvY2Vzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgSW50ZWdlciBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICBJbnRlZ2VyIGVycm9yQ291bnQgPSAwO1xuXG4gICAgICAgIGZvciAoQ3VzdG9tZXJfX2MgY3VzdG9tZXIgOiBjdXN0b21lcnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDdXN0b21lcihjdXN0b21lcik7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0luZGl2aWR1YWxDdXN0b21lcihjdXN0b21lcik7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKEN1c3RvbWVyRGF0YUV4Y2VwdGlvbiBlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDb3VudCsrO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZyhMb2dnaW5nTGV2ZWwuRVJST1IsICdCdXNpbmVzcyBsb2dpYyBlcnJvciBmb3IgY3VzdG9tZXIgJyArXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWVyLklkICsgJzogJyArIGUuZ2V0TWVzc2FnZSgpKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoRG1sRXhjZXB0aW9uIGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvckNvdW50Kys7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmRlYnVnKExvZ2dpbmdMZXZlbC5FUlJPUiwgJ0RhdGFiYXNlIGVycm9yIGZvciBjdXN0b21lciAnICtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tZXIuSWQgKyAnOiAnICsgZS5nZXREbWxNZXNzYWdlKDApKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoRXhjZXB0aW9uIGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvckNvdW50Kys7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmRlYnVnKExvZ2dpbmdMZXZlbC5FUlJPUiwgJ1VuZXhwZWN0ZWQgZXJyb3IgZm9yIGN1c3RvbWVyICcgK1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21lci5JZCArICc6ICcgKyBlLmdldE1lc3NhZ2UoKSArICcgYXQgbGluZSAnICsgZS5nZXRMaW5lTnVtYmVyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgU3lzdGVtLmRlYnVnKExvZ2dpbmdMZXZlbC5JTkZPLCAnUHJvY2Vzc2luZyBjb21wbGV0ZS4gU3VjY2VzczogJyArXG4gICAgICAgICAgICBzdWNjZXNzQ291bnQgKyAnLCBFcnJvcnM6ICcgKyBlcnJvckNvdW50KTtcblxuICAgICAgICByZXR1cm4gZXJyb3JDb3VudCA9PSAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCB2YWxpZGF0ZUN1c3RvbWVyKEN1c3RvbWVyX19jIGN1c3RvbWVyKSB7XG4gICAgICAgIGlmIChjdXN0b21lciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3VzdG9tZXJEYXRhRXhjZXB0aW9uKCdDdXN0b21lciByZWNvcmQgaXMgbnVsbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFN0cmluZy5pc0JsYW5rKGN1c3RvbWVyLk5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3VzdG9tZXJEYXRhRXhjZXB0aW9uKCdDdXN0b21lciBuYW1lIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoU3RyaW5nLmlzQmxhbmsoY3VzdG9tZXIuRW1haWxfX2MpIHx8ICFjdXN0b21lci5FbWFpbF9fYy5jb250YWlucygnQCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3VzdG9tZXJEYXRhRXhjZXB0aW9uKCdWYWxpZCBlbWFpbCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2b2lkIHByb2Nlc3NJbmRpdmlkdWFsQ3VzdG9tZXIoQ3VzdG9tZXJfX2MgY3VzdG9tZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGN1c3RvbWVyLkxhc3RfUHJvY2Vzc2VkX19jID0gU3lzdGVtLm5vdygpO1xuICAgICAgICAgICAgY3VzdG9tZXIuU3RhdHVzX19jID0gJ1Byb2Nlc3NlZCc7XG5cbiAgICAgICAgICAgIHVwZGF0ZSBjdXN0b21lcjtcblxuICAgICAgICB9IGNhdGNoIChEbWxFeGNlcHRpb24gZSkge1xuICAgICAgICAgICAgU3lzdGVtLmRlYnVnKExvZ2dpbmdMZXZlbC5FUlJPUiwgJ0ZhaWxlZCB0byB1cGRhdGUgY3VzdG9tZXI6ICcgKyBlLmdldE1lc3NhZ2UoKSk7XG4gICAgICAgICAgICB0aHJvdyBlOyAvLyBSZS10aHJvdyBmb3IgY2FsbGVyIHRvIGhhbmRsZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2FmZSBtZXRob2QgdGhhdCBuZXZlciB0aHJvd3MgZXhjZXB0aW9uc1xuICAgIHB1YmxpYyBDdXN0b21lclByb2Nlc3NpbmdSZXN1bHQgc2FmZVBwcm9jZXNzQ3VzdG9tZXJzKExpc3Q8Q3VzdG9tZXJfX2M+IGN1c3RvbWVycykge1xuICAgICAgICBDdXN0b21lclByb2Nlc3NpbmdSZXN1bHQgcmVzdWx0ID0gbmV3IEN1c3RvbWVyUHJvY2Vzc2luZ1Jlc3VsdCgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBCb29sZWFuIHN1Y2Nlc3MgPSBwcm9jZXNzQ3VzdG9tZXJEYXRhKGN1c3RvbWVycyk7XG4gICAgICAgICAgICByZXN1bHQuc3VjY2VzcyA9IHN1Y2Nlc3M7XG4gICAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IHN1Y2Nlc3MgPyAnQWxsIGN1c3RvbWVycyBwcm9jZXNzZWQnIDogJ1NvbWUgZXJyb3JzIG9jY3VycmVkJztcblxuICAgICAgICB9IGNhdGNoIChFeGNlcHRpb24gZSkge1xuICAgICAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ1Byb2Nlc3NpbmcgZmFpbGVkOiAnICsgZS5nZXRNZXNzYWdlKCk7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JEZXRhaWxzID0gZS5nZXRTdGFja1RyYWNlU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFJlc3VsdCB3cmFwcGVyIGNsYXNzXG4gICAgcHVibGljIGNsYXNzIEN1c3RvbWVyUHJvY2Vzc2luZ1Jlc3VsdCB7XG4gICAgICAgIHB1YmxpYyBCb29sZWFuIHN1Y2Nlc3M7XG4gICAgICAgIHB1YmxpYyBTdHJpbmcgbWVzc2FnZTtcbiAgICAgICAgcHVibGljIFN0cmluZyBlcnJvckRldGFpbHM7XG4gICAgfVxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlVzZSBzcGVjaWZpYyBleGNlcHRpb24gdHlwZXMsIHByb3BlciBsb2dnaW5nIGxldmVscywgYW5kIHNhZmUgd3JhcHBlciBtZXRob2RzIGZvciByb2J1c3QgZXJyb3IgaGFuZGxpbmcuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiRXhjZXB0aW9uIGhhbmRsaW5nIHF1ZXN0aW9ucyB0ZXN0IHVuZGVyc3RhbmRpbmcgb2YgdHJ5LWNhdGNoIHBhdHRlcm5zLCBjdXN0b20gZXhjZXB0aW9ucywgYW5kIGVycm9yIHJlY292ZXJ5IHN0cmF0ZWdpZXMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTcsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhZHZhbmNlZCcsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkhvdyBkbyB5b3UgaW1wbGVtZW50IGEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCBpbiBib3RoIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgY29udGV4dHM/XCIsXG4gICAgICAgIGFuc3dlcjogXCJEZXNpZ24gd2l0aCBjb250ZXh0IGF3YXJlbmVzcyBhbmQgdXNlIGFwcHJvcHJpYXRlIHBhdHRlcm5zIGZvciBnb3Zlcm5vciBsaW1pdHMgYW5kIHN0YXRlIG1hbmFnZW1lbnRcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiQ2xhc3NlcyB1c2VkIGluIGFzeW5jIGNvbnRleHRzIG5lZWQgdG8gaGFuZGxlIGRpZmZlcmVudCBnb3Zlcm5vciBsaW1pdHMsIHBvdGVudGlhbCBzZXJpYWxpemF0aW9uIHJlcXVpcmVtZW50cywgYW5kIHN0YXRlIG1hbmFnZW1lbnQgZGlmZmVyZW50bHkgdGhhbiBzeW5jaHJvbm91cyBjb250ZXh0cy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgY2xhc3MgRGF0YVByb2Nlc3NvciB7XG5cbiAgICAvLyBDb250ZXh0LWF3YXJlIHByb2Nlc3NpbmdcbiAgICBwdWJsaWMgZW51bSBQcm9jZXNzaW5nQ29udGV4dCB7XG4gICAgICAgIFNZTkNIUk9OT1VTLFxuICAgICAgICBGVVRVUkUsXG4gICAgICAgIEJBVENILFxuICAgICAgICBRVUVVRUFCTEVcbiAgICB9XG5cbiAgICBwcml2YXRlIFByb2Nlc3NpbmdDb250ZXh0IGNvbnRleHQ7XG4gICAgcHJpdmF0ZSBJbnRlZ2VyIGJhdGNoU2l6ZTtcblxuICAgIC8vIENvbnN0cnVjdG9yIHRoYXQgZGV0ZXJtaW5lcyBjb250ZXh0XG4gICAgcHVibGljIERhdGFQcm9jZXNzb3IoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGRldGVybWluZUNvbnRleHQoKTtcbiAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBnZXRCYXRjaFNpemVGb3JDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcHVibGljIERhdGFQcm9jZXNzb3IoUHJvY2Vzc2luZ0NvbnRleHQgZXhwbGljaXRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGV4cGxpY2l0Q29udGV4dDtcbiAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBnZXRCYXRjaFNpemVGb3JDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgLy8gTWFpbiBwcm9jZXNzaW5nIG1ldGhvZCAtIGNvbnRleHQgYXdhcmVcbiAgICBwdWJsaWMgUHJvY2Vzc2luZ1Jlc3VsdCBwcm9jZXNzUmVjb3JkcyhMaXN0PFNPYmplY3Q+IHJlY29yZHMpIHtcbiAgICAgICAgUHJvY2Vzc2luZ1Jlc3VsdCByZXN1bHQgPSBuZXcgUHJvY2Vzc2luZ1Jlc3VsdCgpO1xuICAgICAgICByZXN1bHQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgcmVzdWx0LnN0YXJ0VGltZSA9IFN5c3RlbS5ub3coKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoIG9uIHRoaXMuY29udGV4dCB7XG4gICAgICAgICAgICAgICAgd2hlbiBTWU5DSFJPTk9VUyB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NTeW5jaHJvbm91c2x5KHJlY29yZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGVuIEZVVFVSRSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NGb3JGdXR1cmUocmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoZW4gQkFUQ0gge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm9jZXNzRm9yQmF0Y2gocmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoZW4gUVVFVUVBQkxFIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0ZvclF1ZXVlYWJsZShyZWNvcmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaCAoRXhjZXB0aW9uIGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JNZXNzYWdlID0gZS5nZXRNZXNzYWdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuZW5kVGltZSA9IFN5c3RlbS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBTeW5jaHJvbm91cyBwcm9jZXNzaW5nIC0gc3RyaWN0ZXIgbGltaXRzXG4gICAgcHJpdmF0ZSBQcm9jZXNzaW5nUmVzdWx0IHByb2Nlc3NTeW5jaHJvbm91c2x5KExpc3Q8U09iamVjdD4gcmVjb3Jkcykge1xuICAgICAgICBQcm9jZXNzaW5nUmVzdWx0IHJlc3VsdCA9IG5ldyBQcm9jZXNzaW5nUmVzdWx0KCk7XG5cbiAgICAgICAgLy8gTGltaXQgcmVjb3JkcyB0byBhdm9pZCB0aW1lb3V0c1xuICAgICAgICBMaXN0PFNPYmplY3Q+IGxpbWl0ZWRSZWNvcmRzID0gcmVjb3Jkcy5zaXplKCkgPiAxMDAgP1xuICAgICAgICAgICAgbmV3IExpc3Q8U09iamVjdD4ocmVjb3Jkcykuc3ViTGlzdCgwLCAxMDApIDogcmVjb3JkcztcblxuICAgICAgICByZXN1bHQucmVjb3Jkc1Byb2Nlc3NlZCA9IHByb2Nlc3NSZWNvcmRzQmF0Y2gobGltaXRlZFJlY29yZHMpO1xuICAgICAgICByZXN1bHQuc3VjY2VzcyA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBGdXR1cmUgbWV0aG9kIHByb2Nlc3NpbmcgLSBoaWdoZXIgbGltaXRzXG4gICAgcHJpdmF0ZSBQcm9jZXNzaW5nUmVzdWx0IHByb2Nlc3NGb3JGdXR1cmUoTGlzdDxTT2JqZWN0PiByZWNvcmRzKSB7XG4gICAgICAgIFByb2Nlc3NpbmdSZXN1bHQgcmVzdWx0ID0gbmV3IFByb2Nlc3NpbmdSZXN1bHQoKTtcblxuICAgICAgICAvLyBDYW4gaGFuZGxlIG1vcmUgcmVjb3Jkc1xuICAgICAgICByZXN1bHQucmVjb3Jkc1Byb2Nlc3NlZCA9IHByb2Nlc3NSZWNvcmRzQmF0Y2gocmVjb3Jkcyk7XG4gICAgICAgIHJlc3VsdC5zdWNjZXNzID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEJhdGNoIHByb2Nlc3NpbmcgLSBoaWdoZXN0IGxpbWl0c1xuICAgIHByaXZhdGUgUHJvY2Vzc2luZ1Jlc3VsdCBwcm9jZXNzRm9yQmF0Y2goTGlzdDxTT2JqZWN0PiByZWNvcmRzKSB7XG4gICAgICAgIFByb2Nlc3NpbmdSZXN1bHQgcmVzdWx0ID0gbmV3IFByb2Nlc3NpbmdSZXN1bHQoKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGluIG9wdGltYWwgYmF0Y2ggc2l6ZXNcbiAgICAgICAgSW50ZWdlciBwcm9jZXNzZWQgPSAwO1xuICAgICAgICBmb3IgKEludGVnZXIgaSA9IDA7IGkgPCByZWNvcmRzLnNpemUoKTsgaSArPSB0aGlzLmJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgSW50ZWdlciBlbmRJbmRleCA9IE1hdGgubWluKGkgKyB0aGlzLmJhdGNoU2l6ZSwgcmVjb3Jkcy5zaXplKCkpO1xuICAgICAgICAgICAgTGlzdDxTT2JqZWN0PiBiYXRjaCA9IHJlY29yZHMuc3ViTGlzdChpLCBlbmRJbmRleCk7XG4gICAgICAgICAgICBwcm9jZXNzZWQgKz0gcHJvY2Vzc1JlY29yZHNCYXRjaChiYXRjaCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucmVjb3Jkc1Byb2Nlc3NlZCA9IHByb2Nlc3NlZDtcbiAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gUXVldWVhYmxlIHByb2Nlc3NpbmcgLSBjaGFpbmFibGVcbiAgICBwcml2YXRlIFByb2Nlc3NpbmdSZXN1bHQgcHJvY2Vzc0ZvclF1ZXVlYWJsZShMaXN0PFNPYmplY3Q+IHJlY29yZHMpIHtcbiAgICAgICAgUHJvY2Vzc2luZ1Jlc3VsdCByZXN1bHQgPSBuZXcgUHJvY2Vzc2luZ1Jlc3VsdCgpO1xuXG4gICAgICAgIHJlc3VsdC5yZWNvcmRzUHJvY2Vzc2VkID0gcHJvY2Vzc1JlY29yZHNCYXRjaChyZWNvcmRzKTtcbiAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICByZXN1bHQuY2FuQ2hhaW4gPSByZWNvcmRzLnNpemUoKSA+IDEwMDA7IC8vIEluZGljYXRlIGlmIGNoYWluaW5nIG5lZWRlZFxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gQ29yZSBwcm9jZXNzaW5nIGxvZ2ljXG4gICAgcHJpdmF0ZSBJbnRlZ2VyIHByb2Nlc3NSZWNvcmRzQmF0Y2goTGlzdDxTT2JqZWN0PiByZWNvcmRzKSB7XG4gICAgICAgIC8vIEFjdHVhbCBwcm9jZXNzaW5nIGxvZ2ljIGhlcmVcbiAgICAgICAgZm9yIChTT2JqZWN0IHJlY29yZCA6IHJlY29yZHMpIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgaW5kaXZpZHVhbCByZWNvcmRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3Jkcy5zaXplKCk7XG4gICAgfVxuXG4gICAgLy8gQ29udGV4dCBkZXRlY3Rpb25cbiAgICBwcml2YXRlIFByb2Nlc3NpbmdDb250ZXh0IGRldGVybWluZUNvbnRleHQoKSB7XG4gICAgICAgIGlmIChTeXN0ZW0uaXNGdXR1cmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb2Nlc3NpbmdDb250ZXh0LkZVVFVSRTtcbiAgICAgICAgfSBlbHNlIGlmIChTeXN0ZW0uaXNCYXRjaCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvY2Vzc2luZ0NvbnRleHQuQkFUQ0g7XG4gICAgICAgIH0gZWxzZSBpZiAoU3lzdGVtLmlzUXVldWVhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9jZXNzaW5nQ29udGV4dC5RVUVVRUFCTEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvY2Vzc2luZ0NvbnRleHQuU1lOQ0hST05PVVM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb250ZXh0LWFwcHJvcHJpYXRlIGJhdGNoIHNpemVzXG4gICAgcHJpdmF0ZSBJbnRlZ2VyIGdldEJhdGNoU2l6ZUZvckNvbnRleHQoKSB7XG4gICAgICAgIHN3aXRjaCBvbiB0aGlzLmNvbnRleHQge1xuICAgICAgICAgICAgd2hlbiBTWU5DSFJPTk9VUyB7IHJldHVybiA1MDsgfVxuICAgICAgICAgICAgd2hlbiBGVVRVUkUgeyByZXR1cm4gMTAwOyB9XG4gICAgICAgICAgICB3aGVuIEJBVENIIHsgcmV0dXJuIDIwMDsgfVxuICAgICAgICAgICAgd2hlbiBRVUVVRUFCTEUgeyByZXR1cm4gMTUwOyB9XG4gICAgICAgICAgICB3aGVuIGVsc2UgeyByZXR1cm4gNTA7IH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc3VsdCBjbGFzc1xuICAgIHB1YmxpYyBjbGFzcyBQcm9jZXNzaW5nUmVzdWx0IHtcbiAgICAgICAgcHVibGljIEJvb2xlYW4gc3VjY2VzcztcbiAgICAgICAgcHVibGljIFN0cmluZyBlcnJvck1lc3NhZ2U7XG4gICAgICAgIHB1YmxpYyBJbnRlZ2VyIHJlY29yZHNQcm9jZXNzZWQ7XG4gICAgICAgIHB1YmxpYyBQcm9jZXNzaW5nQ29udGV4dCBjb250ZXh0O1xuICAgICAgICBwdWJsaWMgRGF0ZVRpbWUgc3RhcnRUaW1lO1xuICAgICAgICBwdWJsaWMgRGF0ZVRpbWUgZW5kVGltZTtcbiAgICAgICAgcHVibGljIEJvb2xlYW4gY2FuQ2hhaW47XG4gICAgfVxufVxuXG4vLyBVc2FnZSBpbiBkaWZmZXJlbnQgY29udGV4dHNcbkRhdGFQcm9jZXNzb3IgcHJvY2Vzc29yID0gbmV3IERhdGFQcm9jZXNzb3IoKTsgLy8gQXV0by1kZXRlY3RzIGNvbnRleHRcblByb2Nlc3NpbmdSZXN1bHQgcmVzdWx0ID0gcHJvY2Vzc29yLnByb2Nlc3NSZWNvcmRzKG15UmVjb3Jkcyk7YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQ29udGV4dC1hd2FyZSBjbGFzc2VzIGFkYXB0IGJlaGF2aW9yIGJhc2VkIG9uIGV4ZWN1dGlvbiBlbnZpcm9ubWVudC4gVXNlIGRpZmZlcmVudCBzdHJhdGVnaWVzIGZvciBkaWZmZXJlbnQgZ292ZXJub3IgbGltaXQgY29udGV4dHMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiQXN5bmMtYXdhcmUgZGVzaWduIHF1ZXN0aW9ucyB0ZXN0IHVuZGVyc3RhbmRpbmcgb2YgZ292ZXJub3IgbGltaXQgZGlmZmVyZW5jZXMgYW5kIGNvbnRleHQgZGV0ZWN0aW9uIHBhdHRlcm5zLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDE4LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiSG93IGRvIHlvdSBpbXBsZW1lbnQgcHJvcGVyIGVxdWFsaXR5IGFuZCBjb21wYXJpc29uIGZvciBjdXN0b20gb2JqZWN0cz9cIixcbiAgICAgICAgYW5zd2VyOiBcIk92ZXJyaWRlIGVxdWFscygpIGFuZCBoYXNoQ29kZSgpIG1ldGhvZHMsIGltcGxlbWVudCBDb21wYXJhYmxlIGludGVyZmFjZSBmb3Igc29ydGluZ1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJDdXN0b20gZXF1YWxpdHkgYWxsb3dzIG9iamVjdHMgdG8gYmUgcHJvcGVybHkgY29tcGFyZWQgYW5kIHVzZWQgaW4gU2V0cy9NYXBzLiBQcm9wZXIgaGFzaENvZGUgZW5zdXJlcyBjb3JyZWN0IGJlaGF2aW9yIGluIGNvbGxlY3Rpb25zLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBjbGFzcyBQcm9kdWN0IGltcGxlbWVudHMgQ29tcGFyYWJsZSB7XG4gICAgcHVibGljIFN0cmluZyBuYW1lO1xuICAgIHB1YmxpYyBTdHJpbmcgc2t1O1xuICAgIHB1YmxpYyBEZWNpbWFsIHByaWNlO1xuICAgIHB1YmxpYyBTdHJpbmcgY2F0ZWdvcnk7XG5cbiAgICBwdWJsaWMgUHJvZHVjdChTdHJpbmcgbmFtZSwgU3RyaW5nIHNrdSwgRGVjaW1hbCBwcmljZSwgU3RyaW5nIGNhdGVnb3J5KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2t1ID0gc2t1O1xuICAgICAgICB0aGlzLnByaWNlID0gcHJpY2U7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBlcXVhbHMgZm9yIHByb3BlciBvYmplY3QgY29tcGFyaXNvblxuICAgIHB1YmxpYyBCb29sZWFuIGVxdWFscyhPYmplY3Qgb2JqKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvYmopIHJldHVybiB0cnVlOyAvLyBTYW1lIHJlZmVyZW5jZVxuICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgUHJvZHVjdCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBQcm9kdWN0IG90aGVyID0gKFByb2R1Y3QpIG9iajtcblxuICAgICAgICAvLyBQcm9kdWN0cyBhcmUgZXF1YWwgaWYgU0tVIG1hdGNoZXMgKGJ1c2luZXNzIHJ1bGUpXG4gICAgICAgIHJldHVybiB0aGlzLnNrdSAhPSBudWxsICYmIHRoaXMuc2t1LmVxdWFscyhvdGhlci5za3UpO1xuICAgIH1cblxuICAgIC8vIE11c3Qgb3ZlcnJpZGUgaGFzaENvZGUgd2hlbiBvdmVycmlkaW5nIGVxdWFsc1xuICAgIHB1YmxpYyBJbnRlZ2VyIGhhc2hDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5za3UgIT0gbnVsbCA/IHRoaXMuc2t1Lmhhc2hDb2RlKCkgOiAwO1xuICAgIH1cblxuICAgIC8vIEltcGxlbWVudCBDb21wYXJhYmxlIGZvciBzb3J0aW5nXG4gICAgcHVibGljIEludGVnZXIgY29tcGFyZVRvKE9iamVjdCBvYmopIHtcbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgUHJvZHVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDbGFzc0Nhc3RFeGNlcHRpb24oJ0Nhbm5vdCBjb21wYXJlIFByb2R1Y3QgdG8gJyArIG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9kdWN0IG90aGVyID0gKFByb2R1Y3QpIG9iajtcblxuICAgICAgICAvLyBQcmltYXJ5IHNvcnQ6IGNhdGVnb3J5XG4gICAgICAgIEludGVnZXIgY2F0ZWdvcnlDb21wYXJpc29uID0gY29tcGFyZVN0cmluZ3ModGhpcy5jYXRlZ29yeSwgb3RoZXIuY2F0ZWdvcnkpO1xuICAgICAgICBpZiAoY2F0ZWdvcnlDb21wYXJpc29uICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYXRlZ29yeUNvbXBhcmlzb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWNvbmRhcnkgc29ydDogcHJpY2UgKGRlc2NlbmRpbmcpXG4gICAgICAgIGlmICh0aGlzLnByaWNlICE9IG90aGVyLnByaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmljZSA+IG90aGVyLnByaWNlID8gLTEgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVydGlhcnkgc29ydDogbmFtZVxuICAgICAgICByZXR1cm4gY29tcGFyZVN0cmluZ3ModGhpcy5uYW1lLCBvdGhlci5uYW1lKTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXIgbWV0aG9kIGZvciBzdHJpbmcgY29tcGFyaXNvblxuICAgIHByaXZhdGUgSW50ZWdlciBjb21wYXJlU3RyaW5ncyhTdHJpbmcgc3RyMSwgU3RyaW5nIHN0cjIpIHtcbiAgICAgICAgaWYgKHN0cjEgPT0gbnVsbCAmJiBzdHIyID09IG51bGwpIHJldHVybiAwO1xuICAgICAgICBpZiAoc3RyMSA9PSBudWxsKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKHN0cjIgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gc3RyMS5jb21wYXJlVG8oc3RyMik7XG4gICAgfVxuXG4gICAgLy8gdG9TdHJpbmcgZm9yIGRlYnVnZ2luZ1xuICAgIHB1YmxpYyBvdmVycmlkZSBTdHJpbmcgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnUHJvZHVjdHtuYW1lPScgKyBuYW1lICsgJywgc2t1PScgKyBza3UgKyAnLCBwcmljZT0nICsgcHJpY2UgKyAnfSc7XG4gICAgfVxufVxuXG4vLyBVc2FnZSBleGFtcGxlc1xuUHJvZHVjdCBwcm9kdWN0MSA9IG5ldyBQcm9kdWN0KCdXaWRnZXQgQScsICdXR1QtMDAxJywgMTkuOTksICdFbGVjdHJvbmljcycpO1xuUHJvZHVjdCBwcm9kdWN0MiA9IG5ldyBQcm9kdWN0KCdXaWRnZXQgQSBEZWx1eGUnLCAnV0dULTAwMScsIDI5Ljk5LCAnRWxlY3Ryb25pY3MnKTtcblByb2R1Y3QgcHJvZHVjdDMgPSBuZXcgUHJvZHVjdCgnR2FkZ2V0IEInLCAnR0RULTAwMicsIDE1LjUwLCAnRWxlY3Ryb25pY3MnKTtcblxuLy8gRXF1YWxpdHkgdGVzdGluZ1xuU3lzdGVtLmRlYnVnKHByb2R1Y3QxLmVxdWFscyhwcm9kdWN0MikpOyAvLyB0cnVlIC0gc2FtZSBTS1VcblN5c3RlbS5kZWJ1Zyhwcm9kdWN0MS5lcXVhbHMocHJvZHVjdDMpKTsgLy8gZmFsc2UgLSBkaWZmZXJlbnQgU0tVXG5cbi8vIFNldCB1c2FnZSAtIGR1cGxpY2F0ZXMgcmVtb3ZlZCBiYXNlZCBvbiBlcXVhbHMvaGFzaENvZGVcblNldDxQcm9kdWN0PiBwcm9kdWN0U2V0ID0gbmV3IFNldDxQcm9kdWN0Pntwcm9kdWN0MSwgcHJvZHVjdDIsIHByb2R1Y3QzfTtcblN5c3RlbS5kZWJ1ZygnU2V0IHNpemU6ICcgKyBwcm9kdWN0U2V0LnNpemUoKSk7IC8vIDIgKHByb2R1Y3QxIGFuZCBwcm9kdWN0MiBhcmUgZXF1YWwpXG5cbi8vIExpc3Qgc29ydGluZ1xuTGlzdDxQcm9kdWN0PiBwcm9kdWN0cyA9IG5ldyBMaXN0PFByb2R1Y3Q+e3Byb2R1Y3QzLCBwcm9kdWN0MSwgcHJvZHVjdDJ9O1xucHJvZHVjdHMuc29ydCgpOyAvLyBVc2VzIGNvbXBhcmVUbyBtZXRob2RcbmZvciAoUHJvZHVjdCBwIDogcHJvZHVjdHMpIHtcbiAgICBTeXN0ZW0uZGVidWcocC50b1N0cmluZygpKTtcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJPdmVycmlkZSBlcXVhbHMoKSBhbmQgaGFzaENvZGUoKSB0b2dldGhlci4gSW1wbGVtZW50IENvbXBhcmFibGUgZm9yIGN1c3RvbSBzb3J0aW5nLiBVc2UgYnVzaW5lc3MgbG9naWMgZm9yIGVxdWFsaXR5LlwiLFxuICAgICAgICBleGFtVGlwOiBcIk9iamVjdCBjb21wYXJpc29uIHF1ZXN0aW9ucyB0ZXN0IHVuZGVyc3RhbmRpbmcgb2YgZXF1YWxzL2hhc2hDb2RlIGNvbnRyYWN0IGFuZCBzb3J0aW5nIGltcGxlbWVudGF0aW9uLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDE5LFxuICAgICAgICBkaWZmaWN1bHR5OiAnYWR2YW5jZWQnLFxuICAgICAgICBxdWVzdGlvbjogXCJEZXNpZ24gYSBjbGFzcyB0aGF0IGltcGxlbWVudHMgdGhlIG9ic2VydmVyIHBhdHRlcm4gZm9yIHJlYWwtdGltZSBub3RpZmljYXRpb25zLlwiLFxuICAgICAgICBhbnN3ZXI6IFwiVXNlIGludGVyZmFjZXMgZm9yIG9ic2VydmVycywgbWFpbnRhaW4gYSBsaXN0IG9mIG9ic2VydmVycywgYW5kIG5vdGlmeSB0aGVtIHdoZW4gZXZlbnRzIG9jY3VyXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIk9ic2VydmVyIHBhdHRlcm4gYWxsb3dzIG9iamVjdHMgdG8gYmUgbm90aWZpZWQgb2YgY2hhbmdlcyB3aXRob3V0IHRpZ2h0IGNvdXBsaW5nLiBVc2UgaW50ZXJmYWNlcyBmb3IgZmxleGliaWxpdHkgYW5kIGxpc3RzIHRvIG1hbmFnZSBtdWx0aXBsZSBvYnNlcnZlcnMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gT2JzZXJ2ZXIgaW50ZXJmYWNlXG5wdWJsaWMgaW50ZXJmYWNlIEludmVudG9yeU9ic2VydmVyIHtcbiAgICB2b2lkIG9uSW52ZW50b3J5Q2hhbmdlZChTdHJpbmcgcHJvZHVjdFNrdSwgSW50ZWdlciBvbGRRdWFudGl0eSwgSW50ZWdlciBuZXdRdWFudGl0eSk7XG4gICAgdm9pZCBvbkxvd1N0b2NrKFN0cmluZyBwcm9kdWN0U2t1LCBJbnRlZ2VyIGN1cnJlbnRRdWFudGl0eSwgSW50ZWdlciB0aHJlc2hvbGQpO1xuICAgIHZvaWQgb25PdXRPZlN0b2NrKFN0cmluZyBwcm9kdWN0U2t1KTtcbn1cblxuLy8gQ29uY3JldGUgb2JzZXJ2ZXIgaW1wbGVtZW50YXRpb25zXG5wdWJsaWMgY2xhc3MgRW1haWxOb3RpZmljYXRpb25PYnNlcnZlciBpbXBsZW1lbnRzIEludmVudG9yeU9ic2VydmVyIHtcbiAgICBwcml2YXRlIFN0cmluZyBlbWFpbEFkZHJlc3M7XG5cbiAgICBwdWJsaWMgRW1haWxOb3RpZmljYXRpb25PYnNlcnZlcihTdHJpbmcgZW1haWwpIHtcbiAgICAgICAgdGhpcy5lbWFpbEFkZHJlc3MgPSBlbWFpbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgdm9pZCBvbkludmVudG9yeUNoYW5nZWQoU3RyaW5nIHByb2R1Y3RTa3UsIEludGVnZXIgb2xkUXVhbnRpdHksIEludGVnZXIgbmV3UXVhbnRpdHkpIHtcbiAgICAgICAgU3lzdGVtLmRlYnVnKCdFbWFpbDogSW52ZW50b3J5IGNoYW5nZWQgZm9yICcgKyBwcm9kdWN0U2t1ICtcbiAgICAgICAgICAgICcgZnJvbSAnICsgb2xkUXVhbnRpdHkgKyAnIHRvICcgKyBuZXdRdWFudGl0eSk7XG4gICAgfVxuXG4gICAgcHVibGljIHZvaWQgb25Mb3dTdG9jayhTdHJpbmcgcHJvZHVjdFNrdSwgSW50ZWdlciBjdXJyZW50UXVhbnRpdHksIEludGVnZXIgdGhyZXNob2xkKSB7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnRW1haWwgQWxlcnQ6IExvdyBzdG9jayBmb3IgJyArIHByb2R1Y3RTa3UgK1xuICAgICAgICAgICAgJyAoJyArIGN1cnJlbnRRdWFudGl0eSArICcgcmVtYWluaW5nLCB0aHJlc2hvbGQ6ICcgKyB0aHJlc2hvbGQgKyAnKScpO1xuICAgIH1cblxuICAgIHB1YmxpYyB2b2lkIG9uT3V0T2ZTdG9jayhTdHJpbmcgcHJvZHVjdFNrdSkge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ1VSR0VOVCBFbWFpbDogJyArIHByb2R1Y3RTa3UgKyAnIGlzIG91dCBvZiBzdG9jayEnKTtcbiAgICB9XG59XG5cbnB1YmxpYyBjbGFzcyBTbGFja05vdGlmaWNhdGlvbk9ic2VydmVyIGltcGxlbWVudHMgSW52ZW50b3J5T2JzZXJ2ZXIge1xuICAgIHByaXZhdGUgU3RyaW5nIGNoYW5uZWw7XG5cbiAgICBwdWJsaWMgU2xhY2tOb3RpZmljYXRpb25PYnNlcnZlcihTdHJpbmcgc2xhY2tDaGFubmVsKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IHNsYWNrQ2hhbm5lbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgdm9pZCBvbkludmVudG9yeUNoYW5nZWQoU3RyaW5nIHByb2R1Y3RTa3UsIEludGVnZXIgb2xkUXVhbnRpdHksIEludGVnZXIgbmV3UXVhbnRpdHkpIHtcbiAgICAgICAgLy8gT25seSBub3RpZnkgb24gc2lnbmlmaWNhbnQgY2hhbmdlc1xuICAgICAgICBpZiAoTWF0aC5hYnMobmV3UXVhbnRpdHkgLSBvbGRRdWFudGl0eSkgPj0gMTApIHtcbiAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnU2xhY2sgJyArIGNoYW5uZWwgKyAnOiBTaWduaWZpY2FudCBpbnZlbnRvcnkgY2hhbmdlIGZvciAnICsgcHJvZHVjdFNrdSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgdm9pZCBvbkxvd1N0b2NrKFN0cmluZyBwcm9kdWN0U2t1LCBJbnRlZ2VyIGN1cnJlbnRRdWFudGl0eSwgSW50ZWdlciB0aHJlc2hvbGQpIHtcbiAgICAgICAgU3lzdGVtLmRlYnVnKCdTbGFjayAnICsgY2hhbm5lbCArICc6IOKaoO+4jyBMb3cgc3RvY2sgYWxlcnQgZm9yICcgKyBwcm9kdWN0U2t1KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdm9pZCBvbk91dE9mU3RvY2soU3RyaW5nIHByb2R1Y3RTa3UpIHtcbiAgICAgICAgU3lzdGVtLmRlYnVnKCdTbGFjayAnICsgY2hhbm5lbCArICc6IPCfmqggT1VUIE9GIFNUT0NLOiAnICsgcHJvZHVjdFNrdSk7XG4gICAgfVxufVxuXG4vLyBTdWJqZWN0IGNsYXNzIHRoYXQgbWFuYWdlcyBvYnNlcnZlcnNcbnB1YmxpYyBjbGFzcyBJbnZlbnRvcnlNYW5hZ2VyIHtcbiAgICBwcml2YXRlIE1hcDxTdHJpbmcsIEludGVnZXI+IGludmVudG9yeTtcbiAgICBwcml2YXRlIE1hcDxTdHJpbmcsIEludGVnZXI+IGxvd1N0b2NrVGhyZXNob2xkcztcbiAgICBwcml2YXRlIExpc3Q8SW52ZW50b3J5T2JzZXJ2ZXI+IG9ic2VydmVycztcblxuICAgIHB1YmxpYyBJbnZlbnRvcnlNYW5hZ2VyKCkge1xuICAgICAgICB0aGlzLmludmVudG9yeSA9IG5ldyBNYXA8U3RyaW5nLCBJbnRlZ2VyPigpO1xuICAgICAgICB0aGlzLmxvd1N0b2NrVGhyZXNob2xkcyA9IG5ldyBNYXA8U3RyaW5nLCBJbnRlZ2VyPigpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG5ldyBMaXN0PEludmVudG9yeU9ic2VydmVyPigpO1xuICAgIH1cblxuICAgIC8vIE9ic2VydmVyIG1hbmFnZW1lbnRcbiAgICBwdWJsaWMgdm9pZCBhZGRPYnNlcnZlcihJbnZlbnRvcnlPYnNlcnZlciBvYnNlcnZlcikge1xuICAgICAgICBpZiAob2JzZXJ2ZXIgIT0gbnVsbCAmJiAhdGhpcy5vYnNlcnZlcnMuY29udGFpbnMob2JzZXJ2ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHZvaWQgcmVtb3ZlT2JzZXJ2ZXIoSW52ZW50b3J5T2JzZXJ2ZXIgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucmVtb3ZlKHRoaXMub2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpKTtcbiAgICB9XG5cbiAgICAvLyBCdXNpbmVzcyBtZXRob2RzIHRoYXQgdHJpZ2dlciBub3RpZmljYXRpb25zXG4gICAgcHVibGljIHZvaWQgdXBkYXRlSW52ZW50b3J5KFN0cmluZyBwcm9kdWN0U2t1LCBJbnRlZ2VyIG5ld1F1YW50aXR5KSB7XG4gICAgICAgIEludGVnZXIgb2xkUXVhbnRpdHkgPSB0aGlzLmludmVudG9yeS5nZXQocHJvZHVjdFNrdSk7XG4gICAgICAgIGlmIChvbGRRdWFudGl0eSA9PSBudWxsKSBvbGRRdWFudGl0eSA9IDA7XG5cbiAgICAgICAgdGhpcy5pbnZlbnRvcnkucHV0KHByb2R1Y3RTa3UsIG5ld1F1YW50aXR5KTtcblxuICAgICAgICAvLyBOb3RpZnkgYWxsIG9ic2VydmVyc1xuICAgICAgICBub3RpZnlJbnZlbnRvcnlDaGFuZ2VkKHByb2R1Y3RTa3UsIG9sZFF1YW50aXR5LCBuZXdRdWFudGl0eSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHN0b2NrIGxldmVsc1xuICAgICAgICBjaGVja1N0b2NrTGV2ZWxzKHByb2R1Y3RTa3UsIG5ld1F1YW50aXR5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdm9pZCBzZXRMb3dTdG9ja1RocmVzaG9sZChTdHJpbmcgcHJvZHVjdFNrdSwgSW50ZWdlciB0aHJlc2hvbGQpIHtcbiAgICAgICAgdGhpcy5sb3dTdG9ja1RocmVzaG9sZHMucHV0KHByb2R1Y3RTa3UsIHRocmVzaG9sZCk7XG4gICAgfVxuXG4gICAgLy8gTm90aWZpY2F0aW9uIG1ldGhvZHNcbiAgICBwcml2YXRlIHZvaWQgbm90aWZ5SW52ZW50b3J5Q2hhbmdlZChTdHJpbmcgcHJvZHVjdFNrdSwgSW50ZWdlciBvbGRRdWFudGl0eSwgSW50ZWdlciBuZXdRdWFudGl0eSkge1xuICAgICAgICBmb3IgKEludmVudG9yeU9ic2VydmVyIG9ic2VydmVyIDogdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25JbnZlbnRvcnlDaGFuZ2VkKHByb2R1Y3RTa3UsIG9sZFF1YW50aXR5LCBuZXdRdWFudGl0eSk7XG4gICAgICAgICAgICB9IGNhdGNoIChFeGNlcHRpb24gZSkge1xuICAgICAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnRXJyb3Igbm90aWZ5aW5nIG9ic2VydmVyOiAnICsgZS5nZXRNZXNzYWdlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2b2lkIGNoZWNrU3RvY2tMZXZlbHMoU3RyaW5nIHByb2R1Y3RTa3UsIEludGVnZXIgY3VycmVudFF1YW50aXR5KSB7XG4gICAgICAgIGlmIChjdXJyZW50UXVhbnRpdHkgPT0gMCkge1xuICAgICAgICAgICAgbm90aWZ5T3V0T2ZTdG9jayhwcm9kdWN0U2t1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEludGVnZXIgdGhyZXNob2xkID0gdGhpcy5sb3dTdG9ja1RocmVzaG9sZHMuZ2V0KHByb2R1Y3RTa3UpO1xuICAgICAgICAgICAgaWYgKHRocmVzaG9sZCAhPSBudWxsICYmIGN1cnJlbnRRdWFudGl0eSA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBub3RpZnlMb3dTdG9jayhwcm9kdWN0U2t1LCBjdXJyZW50UXVhbnRpdHksIHRocmVzaG9sZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHZvaWQgbm90aWZ5TG93U3RvY2soU3RyaW5nIHByb2R1Y3RTa3UsIEludGVnZXIgY3VycmVudFF1YW50aXR5LCBJbnRlZ2VyIHRocmVzaG9sZCkge1xuICAgICAgICBmb3IgKEludmVudG9yeU9ic2VydmVyIG9ic2VydmVyIDogdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Mb3dTdG9jayhwcm9kdWN0U2t1LCBjdXJyZW50UXVhbnRpdHksIHRocmVzaG9sZCk7XG4gICAgICAgICAgICB9IGNhdGNoIChFeGNlcHRpb24gZSkge1xuICAgICAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnRXJyb3Igbm90aWZ5aW5nIG9ic2VydmVyOiAnICsgZS5nZXRNZXNzYWdlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2b2lkIG5vdGlmeU91dE9mU3RvY2soU3RyaW5nIHByb2R1Y3RTa3UpIHtcbiAgICAgICAgZm9yIChJbnZlbnRvcnlPYnNlcnZlciBvYnNlcnZlciA6IHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uT3V0T2ZTdG9jayhwcm9kdWN0U2t1KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKEV4Y2VwdGlvbiBlKSB7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdFcnJvciBub3RpZnlpbmcgb2JzZXJ2ZXI6ICcgKyBlLmdldE1lc3NhZ2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgICBwdWJsaWMgSW50ZWdlciBnZXRDdXJyZW50SW52ZW50b3J5KFN0cmluZyBwcm9kdWN0U2t1KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmVudG9yeS5nZXQocHJvZHVjdFNrdSk7XG4gICAgfVxufVxuXG4vLyBVc2FnZSBleGFtcGxlXG5JbnZlbnRvcnlNYW5hZ2VyIGludmVudG9yeSA9IG5ldyBJbnZlbnRvcnlNYW5hZ2VyKCk7XG5cbi8vIEFkZCBvYnNlcnZlcnNcbmludmVudG9yeS5hZGRPYnNlcnZlcihuZXcgRW1haWxOb3RpZmljYXRpb25PYnNlcnZlcignbWFuYWdlckBjb21wYW55LmNvbScpKTtcbmludmVudG9yeS5hZGRPYnNlcnZlcihuZXcgU2xhY2tOb3RpZmljYXRpb25PYnNlcnZlcignI2ludmVudG9yeS1hbGVydHMnKSk7XG5cbi8vIFNldCB0aHJlc2hvbGRzIGFuZCB1cGRhdGUgaW52ZW50b3J5XG5pbnZlbnRvcnkuc2V0TG93U3RvY2tUaHJlc2hvbGQoJ1dJREdFVC0wMDEnLCAxMCk7XG5pbnZlbnRvcnkudXBkYXRlSW52ZW50b3J5KCdXSURHRVQtMDAxJywgMTAwKTsgLy8gTm9ybWFsIHN0b2NrXG5pbnZlbnRvcnkudXBkYXRlSW52ZW50b3J5KCdXSURHRVQtMDAxJywgOCk7ICAgLy8gTG93IHN0b2NrIGFsZXJ0XG5pbnZlbnRvcnkudXBkYXRlSW52ZW50b3J5KCdXSURHRVQtMDAxJywgMCk7ICAgLy8gT3V0IG9mIHN0b2NrIGFsZXJ0YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiT2JzZXJ2ZXIgcGF0dGVybiB1c2VzIGludGVyZmFjZXMgZm9yIGxvb3NlIGNvdXBsaW5nIGFuZCBsaXN0IG1hbmFnZW1lbnQgZm9yIG11bHRpcGxlIG9ic2VydmVycy4gSGFuZGxlIG9ic2VydmVyIGV4Y2VwdGlvbnMgZ3JhY2VmdWxseS5cIixcbiAgICAgICAgZXhhbVRpcDogXCJPYnNlcnZlciBwYXR0ZXJuIHF1ZXN0aW9ucyB0ZXN0IHVuZGVyc3RhbmRpbmcgb2YgZGVzaWduIHBhdHRlcm5zLCBpbnRlcmZhY2VzLCBhbmQgZXZlbnQtZHJpdmVuIHByb2dyYW1taW5nLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDIwLFxuICAgICAgICBkaWZmaWN1bHR5OiAnZXhwZXJ0JyxcbiAgICAgICAgcXVlc3Rpb246IFwiRGVzaWduIGEgY29tcHJlaGVuc2l2ZSBjbGFzcyBoaWVyYXJjaHkgZm9yIGEgU2FsZXNmb3JjZSBpbnRlZ3JhdGlvbiB0aGF0IGhhbmRsZXMgbXVsdGlwbGUgZGF0YSBzb3VyY2VzIHdpdGggZGlmZmVyZW50IGF1dGhlbnRpY2F0aW9uIGFuZCBwcm9jZXNzaW5nIHJlcXVpcmVtZW50cy5cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBhYnN0cmFjdCBiYXNlIGNsYXNzIHdpdGggdGVtcGxhdGUgbWV0aG9kIHBhdHRlcm4sIGludGVyZmFjZXMgZm9yIGNvbnRyYWN0cywgYW5kIHN0cmF0ZWd5IHBhdHRlcm4gZm9yIGF1dGhlbnRpY2F0aW9uXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkNvbXBsZXggaW50ZWdyYXRpb24gc2NlbmFyaW9zIHJlcXVpcmUgZmxleGlibGUgYXJjaGl0ZWN0dXJlIHVzaW5nIG11bHRpcGxlIGRlc2lnbiBwYXR0ZXJucy4gQWJzdHJhY3QgY2xhc3NlcyBwcm92aWRlIGNvbW1vbiBzdHJ1Y3R1cmUgd2hpbGUgaW50ZXJmYWNlcyBlbnN1cmUgY29udHJhY3RzIGFyZSBtZXQuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gQmFzZSBpbnRlcmZhY2UgZm9yIGFsbCBkYXRhIHNvdXJjZXNcbnB1YmxpYyBpbnRlcmZhY2UgRGF0YVNvdXJjZSB7XG4gICAgQm9vbGVhbiBpc0Nvbm5lY3RlZCgpO1xuICAgIExpc3Q8U09iamVjdD4gZmV0Y2hEYXRhKE1hcDxTdHJpbmcsIE9iamVjdD4gcGFyYW1ldGVycyk7XG4gICAgdm9pZCBkaXNjb25uZWN0KCk7XG59XG5cbi8vIEF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5IGludGVyZmFjZVxucHVibGljIGludGVyZmFjZSBBdXRoZW50aWNhdGlvblN0cmF0ZWd5IHtcbiAgICBCb29sZWFuIGF1dGhlbnRpY2F0ZShNYXA8U3RyaW5nLCBTdHJpbmc+IGNyZWRlbnRpYWxzKTtcbiAgICBTdHJpbmcgZ2V0QXV0aFRva2VuKCk7XG4gICAgQm9vbGVhbiBpc1Rva2VuVmFsaWQoKTtcbn1cblxuLy8gT0F1dGggaW1wbGVtZW50YXRpb25cbnB1YmxpYyBjbGFzcyBPQXV0aFN0cmF0ZWd5IGltcGxlbWVudHMgQXV0aGVudGljYXRpb25TdHJhdGVneSB7XG4gICAgcHJpdmF0ZSBTdHJpbmcgYWNjZXNzVG9rZW47XG4gICAgcHJpdmF0ZSBEYXRlVGltZSB0b2tlbkV4cGlyeTtcblxuICAgIHB1YmxpYyBCb29sZWFuIGF1dGhlbnRpY2F0ZShNYXA8U3RyaW5nLCBTdHJpbmc+IGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIC8vIE9BdXRoIGZsb3cgaW1wbGVtZW50YXRpb25cbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9ICdvYXV0aF90b2tlbl8nICsgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKCk7XG4gICAgICAgIHRoaXMudG9rZW5FeHBpcnkgPSBTeXN0ZW0ubm93KCkuYWRkSG91cnMoMSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBTdHJpbmcgZ2V0QXV0aFRva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgQm9vbGVhbiBpc1Rva2VuVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuICE9IG51bGwgJiYgU3lzdGVtLm5vdygpIDwgdGhpcy50b2tlbkV4cGlyeTtcbiAgICB9XG59XG5cbi8vIEFQSSBLZXkgaW1wbGVtZW50YXRpb25cbnB1YmxpYyBjbGFzcyBBcGlLZXlTdHJhdGVneSBpbXBsZW1lbnRzIEF1dGhlbnRpY2F0aW9uU3RyYXRlZ3kge1xuICAgIHByaXZhdGUgU3RyaW5nIGFwaUtleTtcblxuICAgIHB1YmxpYyBCb29sZWFuIGF1dGhlbnRpY2F0ZShNYXA8U3RyaW5nLCBTdHJpbmc+IGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gY3JlZGVudGlhbHMuZ2V0KCdhcGlfa2V5Jyk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuaXNOb3RCbGFuayh0aGlzLmFwaUtleSk7XG4gICAgfVxuXG4gICAgcHVibGljIFN0cmluZyBnZXRBdXRoVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUtleTtcbiAgICB9XG5cbiAgICBwdWJsaWMgQm9vbGVhbiBpc1Rva2VuVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuaXNOb3RCbGFuayh0aGlzLmFwaUtleSk7XG4gICAgfVxufVxuXG4vLyBBYnN0cmFjdCBiYXNlIGNsYXNzIC0gVGVtcGxhdGUgTWV0aG9kIFBhdHRlcm5cbnB1YmxpYyBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdERhdGFTb3VyY2UgaW1wbGVtZW50cyBEYXRhU291cmNlIHtcbiAgICBwcm90ZWN0ZWQgQXV0aGVudGljYXRpb25TdHJhdGVneSBhdXRoU3RyYXRlZ3k7XG4gICAgcHJvdGVjdGVkIFN0cmluZyBzb3VyY2VOYW1lO1xuICAgIHByb3RlY3RlZCBCb29sZWFuIGNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHByb3RlY3RlZCBNYXA8U3RyaW5nLCBTdHJpbmc+IGNvbmZpZ3VyYXRpb247XG5cbiAgICBwdWJsaWMgQWJzdHJhY3REYXRhU291cmNlKFN0cmluZyBuYW1lLCBBdXRoZW50aWNhdGlvblN0cmF0ZWd5IGF1dGgpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VOYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hdXRoU3RyYXRlZ3kgPSBhdXRoO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBuZXcgTWFwPFN0cmluZywgU3RyaW5nPigpO1xuICAgIH1cblxuICAgIC8vIFRlbXBsYXRlIG1ldGhvZCAtIGRlZmluZXMgdGhlIGFsZ29yaXRobSBzdHJ1Y3R1cmVcbiAgICBwdWJsaWMgZmluYWwgTGlzdDxTT2JqZWN0PiBmZXRjaERhdGEoTWFwPFN0cmluZywgT2JqZWN0PiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIExpc3Q8U09iamVjdD4gcmVzdWx0cyA9IG5ldyBMaXN0PFNPYmplY3Q+KCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFN0ZXAgMTogVmFsaWRhdGUgY29ubmVjdGlvblxuICAgICAgICAgICAgaWYgKCFpc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGVwIDI6IFZhbGlkYXRlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXV0aFN0cmF0ZWd5LmlzVG9rZW5WYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmVBdXRoZW50aWNhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RlcCAzOiBWYWxpZGF0ZSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICB2YWxpZGF0ZVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgNDogVHJhbnNmb3JtIHBhcmFtZXRlcnMgKGhvb2sgbWV0aG9kKVxuICAgICAgICAgICAgTWFwPFN0cmluZywgT2JqZWN0PiB0cmFuc2Zvcm1lZFBhcmFtcyA9IHRyYW5zZm9ybVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgNTogRmV0Y2ggZGF0YSAoYWJzdHJhY3QgbWV0aG9kIC0gc3ViY2xhc3NlcyBpbXBsZW1lbnQpXG4gICAgICAgICAgICByZXN1bHRzID0gZG9GZXRjaERhdGEodHJhbnNmb3JtZWRQYXJhbXMpO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDY6IFRyYW5zZm9ybSByZXN1bHRzIChob29rIG1ldGhvZClcbiAgICAgICAgICAgIHJlc3VsdHMgPSB0cmFuc2Zvcm1SZXN1bHRzKHJlc3VsdHMpO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDc6IExvZyBzdWNjZXNzXG4gICAgICAgICAgICBsb2dPcGVyYXRpb24oJ1NVQ0NFU1MnLCByZXN1bHRzLnNpemUoKSArICcgcmVjb3JkcyBmZXRjaGVkJyk7XG5cbiAgICAgICAgfSBjYXRjaCAoRXhjZXB0aW9uIGUpIHtcbiAgICAgICAgICAgIGxvZ09wZXJhdGlvbignRVJST1InLCAnRmV0Y2ggZmFpbGVkOiAnICsgZS5nZXRNZXNzYWdlKCkpO1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLy8gQWJzdHJhY3QgbWV0aG9kcyAtIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgTGlzdDxTT2JqZWN0PiBkb0ZldGNoRGF0YShNYXA8U3RyaW5nLCBPYmplY3Q+IHBhcmFtZXRlcnMpO1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIHZhbGlkYXRlUGFyYW1ldGVycyhNYXA8U3RyaW5nLCBPYmplY3Q+IHBhcmFtZXRlcnMpO1xuXG4gICAgLy8gSG9vayBtZXRob2RzIC0gc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgdmlydHVhbCBNYXA8U3RyaW5nLCBPYmplY3Q+IHRyYW5zZm9ybVBhcmFtZXRlcnMoTWFwPFN0cmluZywgT2JqZWN0PiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzOyAvLyBEZWZhdWx0OiBubyB0cmFuc2Zvcm1hdGlvblxuICAgIH1cblxuICAgIHByb3RlY3RlZCB2aXJ0dWFsIExpc3Q8U09iamVjdD4gdHJhbnNmb3JtUmVzdWx0cyhMaXN0PFNPYmplY3Q+IHJlc3VsdHMpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7IC8vIERlZmF1bHQ6IG5vIHRyYW5zZm9ybWF0aW9uXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHZpcnR1YWwgdm9pZCBoYW5kbGVFcnJvcihFeGNlcHRpb24gZSkge1xuICAgICAgICBTeXN0ZW0uZGVidWcoTG9nZ2luZ0xldmVsLkVSUk9SLCAnRXJyb3IgaW4gJyArIHRoaXMuc291cmNlTmFtZSArICc6ICcgKyBlLmdldE1lc3NhZ2UoKSk7XG4gICAgfVxuXG4gICAgLy8gQ29tbW9uIG1ldGhvZHNcbiAgICBwdWJsaWMgQm9vbGVhbiBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGxvZ09wZXJhdGlvbignSU5GTycsICdDb25uZWN0ZWQgdG8gJyArIHRoaXMuc291cmNlTmFtZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHZvaWQgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgbG9nT3BlcmF0aW9uKCdJTkZPJywgJ0Rpc2Nvbm5lY3RlZCBmcm9tICcgKyB0aGlzLnNvdXJjZU5hbWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCByZUF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgTWFwPFN0cmluZywgU3RyaW5nPiBjcmVkZW50aWFscyA9IGdldFN0b3JlZENyZWRlbnRpYWxzKCk7XG4gICAgICAgIGlmICghdGhpcy5hdXRoU3RyYXRlZ3kuYXV0aGVudGljYXRlKGNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXhjZXB0aW9uKCdSZS1hdXRoZW50aWNhdGlvbiBmYWlsZWQgZm9yICcgKyB0aGlzLnNvdXJjZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHZpcnR1YWwgTWFwPFN0cmluZywgU3RyaW5nPiBnZXRTdG9yZWRDcmVkZW50aWFscygpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiAtIG92ZXJyaWRlIGluIHN1YmNsYXNzZXNcbiAgICAgICAgcmV0dXJuIG5ldyBNYXA8U3RyaW5nLCBTdHJpbmc+KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2b2lkIGxvZ09wZXJhdGlvbihTdHJpbmcgbGV2ZWwsIFN0cmluZyBtZXNzYWdlKSB7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnWycgKyB0aGlzLnNvdXJjZU5hbWUgKyAnXSAnICsgbGV2ZWwgKyAnOiAnICsgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIGV4Y2VwdGlvblxuICAgIHB1YmxpYyBjbGFzcyBBdXRoZW50aWNhdGlvbkV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7fVxufVxuXG4vLyBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgUkVTVCBBUElcbnB1YmxpYyBjbGFzcyBSZXN0QXBpRGF0YVNvdXJjZSBleHRlbmRzIEFic3RyYWN0RGF0YVNvdXJjZSB7XG4gICAgcHJpdmF0ZSBTdHJpbmcgZW5kcG9pbnQ7XG5cbiAgICBwdWJsaWMgUmVzdEFwaURhdGFTb3VyY2UoU3RyaW5nIG5hbWUsIFN0cmluZyBhcGlFbmRwb2ludCwgQXV0aGVudGljYXRpb25TdHJhdGVneSBhdXRoKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIGF1dGgpO1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gYXBpRW5kcG9pbnQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIExpc3Q8U09iamVjdD4gZG9GZXRjaERhdGEoTWFwPFN0cmluZywgT2JqZWN0PiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIC8vIFJFU1QgQVBJIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gICAgICAgIEh0dHBSZXF1ZXN0IHJlcSA9IG5ldyBIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXEuc2V0RW5kcG9pbnQodGhpcy5lbmRwb2ludCk7XG4gICAgICAgIHJlcS5zZXRNZXRob2QoJ0dFVCcpO1xuICAgICAgICByZXEuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0JlYXJlciAnICsgdGhpcy5hdXRoU3RyYXRlZ3kuZ2V0QXV0aFRva2VuKCkpO1xuXG4gICAgICAgIC8vIEFkZCBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICAgIFN0cmluZyBxdWVyeVBhcmFtcyA9IGJ1aWxkUXVlcnlTdHJpbmcocGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChTdHJpbmcuaXNOb3RCbGFuayhxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHJlcS5zZXRFbmRwb2ludCh0aGlzLmVuZHBvaW50ICsgJz8nICsgcXVlcnlQYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgSHR0cCBodHRwID0gbmV3IEh0dHAoKTtcbiAgICAgICAgSHR0cFJlc3BvbnNlIHJlc3BvbnNlID0gaHR0cC5zZW5kKHJlcSk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmdldFN0YXR1c0NvZGUoKSA9PSAyMDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUpzb25SZXNwb25zZShyZXNwb25zZS5nZXRCb2R5KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENhbGxvdXRFeGNlcHRpb24oJ0FQSSBjYWxsIGZhaWxlZDogJyArIHJlc3BvbnNlLmdldFN0YXR1cygpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIHZhbGlkYXRlUGFyYW1ldGVycyhNYXA8U3RyaW5nLCBPYmplY3Q+IHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT0gbnVsbCB8fCBwYXJhbWV0ZXJzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUGFyYW1ldGVycyBjYW5ub3QgYmUgbnVsbCBvciBlbXB0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUkVTVCBBUEkgc3BlY2lmaWMgdmFsaWRhdGlvbnNcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzLmNvbnRhaW5zS2V5KCdsaW1pdCcpKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1dCgnbGltaXQnLCAxMDApOyAvLyBEZWZhdWx0IGxpbWl0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgTWFwPFN0cmluZywgT2JqZWN0PiB0cmFuc2Zvcm1QYXJhbWV0ZXJzKE1hcDxTdHJpbmcsIE9iamVjdD4gcGFyYW1ldGVycykge1xuICAgICAgICBNYXA8U3RyaW5nLCBPYmplY3Q+IHRyYW5zZm9ybWVkID0gbmV3IE1hcDxTdHJpbmcsIE9iamVjdD4ocGFyYW1ldGVycyk7XG5cbiAgICAgICAgLy8gQ29udmVydCBTYWxlc2ZvcmNlIGZpZWxkIG5hbWVzIHRvIEFQSSBmaWVsZCBuYW1lc1xuICAgICAgICBpZiAodHJhbnNmb3JtZWQuY29udGFpbnNLZXkoJ0xhc3RNb2RpZmllZERhdGUnKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWQucHV0KCd1cGRhdGVkX2FmdGVyJywgdHJhbnNmb3JtZWQucmVtb3ZlKCdMYXN0TW9kaWZpZWREYXRlJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgU3RyaW5nIGJ1aWxkUXVlcnlTdHJpbmcoTWFwPFN0cmluZywgT2JqZWN0PiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIExpc3Q8U3RyaW5nPiBwYXJ0cyA9IG5ldyBMaXN0PFN0cmluZz4oKTtcbiAgICAgICAgZm9yIChTdHJpbmcga2V5IDogcGFyYW1ldGVycy5rZXlTZXQoKSkge1xuICAgICAgICAgICAgcGFydHMuYWRkKGtleSArICc9JyArIFN0cmluZy52YWx1ZU9mKHBhcmFtZXRlcnMuZ2V0KGtleSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmpvaW4ocGFydHMsICcmJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBMaXN0PFNPYmplY3Q+IHBhcnNlSnNvblJlc3BvbnNlKFN0cmluZyBqc29uQm9keSkge1xuICAgICAgICAvLyBKU09OIHBhcnNpbmcgbG9naWMgaGVyZVxuICAgICAgICBMaXN0PFNPYmplY3Q+IHJlc3VsdHMgPSBuZXcgTGlzdDxTT2JqZWN0PigpO1xuICAgICAgICAvLyAuLi4gcGFyc2luZyBpbXBsZW1lbnRhdGlvblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59XG5cbi8vIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIGZvciBEYXRhYmFzZVxucHVibGljIGNsYXNzIERhdGFiYXNlRGF0YVNvdXJjZSBleHRlbmRzIEFic3RyYWN0RGF0YVNvdXJjZSB7XG4gICAgcHJpdmF0ZSBTdHJpbmcgY29ubmVjdGlvblN0cmluZztcblxuICAgIHB1YmxpYyBEYXRhYmFzZURhdGFTb3VyY2UoU3RyaW5nIG5hbWUsIFN0cmluZyBjb25uU3RyaW5nLCBBdXRoZW50aWNhdGlvblN0cmF0ZWd5IGF1dGgpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgYXV0aCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0cmluZyA9IGNvbm5TdHJpbmc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIExpc3Q8U09iamVjdD4gZG9GZXRjaERhdGEoTWFwPFN0cmluZywgT2JqZWN0PiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIC8vIERhdGFiYXNlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gICAgICAgIFN0cmluZyBxdWVyeSA9IGJ1aWxkU3FsUXVlcnkocGFyYW1ldGVycyk7XG5cbiAgICAgICAgLy8gRXhlY3V0ZSBxdWVyeSAocHNldWRvLWNvZGUgLSBhY3R1YWwgaW1wbGVtZW50YXRpb24gd291bGQgdmFyeSlcbiAgICAgICAgTGlzdDxTT2JqZWN0PiByZXN1bHRzID0gZXhlY3V0ZVF1ZXJ5KHF1ZXJ5KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCB2YWxpZGF0ZVBhcmFtZXRlcnMoTWFwPFN0cmluZywgT2JqZWN0PiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIC8vIERhdGFiYXNlIHNwZWNpZmljIHZhbGlkYXRpb25zXG4gICAgICAgIGlmICghcGFyYW1ldGVycy5jb250YWluc0tleSgndGFibGVfbmFtZScpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUYWJsZSBuYW1lIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIFN0cmluZyBidWlsZFNxbFF1ZXJ5KE1hcDxTdHJpbmcsIE9iamVjdD4gcGFyYW1ldGVycykge1xuICAgICAgICBTdHJpbmcgdGFibGVOYW1lID0gU3RyaW5nLnZhbHVlT2YocGFyYW1ldGVycy5nZXQoJ3RhYmxlX25hbWUnKSk7XG4gICAgICAgIFN0cmluZyB3aGVyZUNsYXVzZSA9IFN0cmluZy52YWx1ZU9mKHBhcmFtZXRlcnMuZ2V0KCd3aGVyZV9jbGF1c2UnKSk7XG5cbiAgICAgICAgU3RyaW5nIHF1ZXJ5ID0gJ1NFTEVDVCAqIEZST00gJyArIHRhYmxlTmFtZTtcbiAgICAgICAgaWYgKFN0cmluZy5pc05vdEJsYW5rKHdoZXJlQ2xhdXNlKSkge1xuICAgICAgICAgICAgcXVlcnkgKz0gJyBXSEVSRSAnICsgd2hlcmVDbGF1c2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBMaXN0PFNPYmplY3Q+IGV4ZWN1dGVRdWVyeShTdHJpbmcgcXVlcnkpIHtcbiAgICAgICAgLy8gRGF0YWJhc2UgZXhlY3V0aW9uIGxvZ2ljXG4gICAgICAgIHJldHVybiBuZXcgTGlzdDxTT2JqZWN0PigpO1xuICAgIH1cbn1cblxuLy8gVXNhZ2UgZXhhbXBsZVxucHVibGljIGNsYXNzIEludGVncmF0aW9uU2VydmljZSB7XG4gICAgcHJpdmF0ZSBNYXA8U3RyaW5nLCBEYXRhU291cmNlPiBkYXRhU291cmNlcztcblxuICAgIHB1YmxpYyBJbnRlZ3JhdGlvblNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZXMgPSBuZXcgTWFwPFN0cmluZywgRGF0YVNvdXJjZT4oKTtcbiAgICAgICAgaW5pdGlhbGl6ZURhdGFTb3VyY2VzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2b2lkIGluaXRpYWxpemVEYXRhU291cmNlcygpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGRpZmZlcmVudCBkYXRhIHNvdXJjZXMgd2l0aCBhcHByb3ByaWF0ZSBhdXRoZW50aWNhdGlvblxuICAgICAgICBBdXRoZW50aWNhdGlvblN0cmF0ZWd5IG9hdXRoU3RyYXRlZ3kgPSBuZXcgT0F1dGhTdHJhdGVneSgpO1xuICAgICAgICBBdXRoZW50aWNhdGlvblN0cmF0ZWd5IGFwaUtleVN0cmF0ZWd5ID0gbmV3IEFwaUtleVN0cmF0ZWd5KCk7XG5cbiAgICAgICAgUmVzdEFwaURhdGFTb3VyY2UgcmVzdEFwaSA9IG5ldyBSZXN0QXBpRGF0YVNvdXJjZShcbiAgICAgICAgICAgICdFeHRlcm5hbCBBUEknLFxuICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLmV4dGVybmFsLmNvbS92MS9kYXRhJyxcbiAgICAgICAgICAgIG9hdXRoU3RyYXRlZ3lcbiAgICAgICAgKTtcblxuICAgICAgICBEYXRhYmFzZURhdGFTb3VyY2UgZGF0YWJhc2UgPSBuZXcgRGF0YWJhc2VEYXRhU291cmNlKFxuICAgICAgICAgICAgJ0xlZ2FjeSBEYXRhYmFzZScsXG4gICAgICAgICAgICAnamRiYzpteXNxbDovL2xvY2FsaG9zdDozMzA2L2xlZ2FjeScsXG4gICAgICAgICAgICBhcGlLZXlTdHJhdGVneVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZXMucHV0KCdhcGknLCByZXN0QXBpKTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlcy5wdXQoJ2RhdGFiYXNlJywgZGF0YWJhc2UpO1xuICAgIH1cblxuICAgIHB1YmxpYyBMaXN0PFNPYmplY3Q+IGZldGNoRnJvbVNvdXJjZShTdHJpbmcgc291cmNlTmFtZSwgTWFwPFN0cmluZywgT2JqZWN0PiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIERhdGFTb3VyY2Ugc291cmNlID0gdGhpcy5kYXRhU291cmNlcy5nZXQoc291cmNlTmFtZSk7XG4gICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVW5rbm93biBkYXRhIHNvdXJjZTogJyArIHNvdXJjZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5mZXRjaERhdGEocGFyYW1ldGVycyk7XG4gICAgfVxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkNvbXBsZXggYXJjaGl0ZWN0dXJlcyB1c2UgbXVsdGlwbGUgcGF0dGVybnM6IFRlbXBsYXRlIE1ldGhvZCBmb3Igc3RydWN0dXJlLCBTdHJhdGVneSBmb3IgYXV0aGVudGljYXRpb24sIEFic3RyYWN0IGNsYXNzZXMgZm9yIHNoYXJlZCBiZWhhdmlvci5cIixcbiAgICAgICAgZXhhbVRpcDogXCJBcmNoaXRlY3R1cmUgcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiBkZXNpZ24gcGF0dGVybnMsIGluaGVyaXRhbmNlLCBpbnRlcmZhY2VzLCBhbmQgc2VwYXJhdGlvbiBvZiBjb25jZXJucy5cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcblxuICAnc29xbC1hbmQtZG1sJzoge1xuICAgIHRpdGxlOiAnU09RTCBhbmQgRE1MJyxcbiAgICBvdmVydmlldzogJ01hc3RlciBTYWxlc2ZvcmNlIE9iamVjdCBRdWVyeSBMYW5ndWFnZSBhbmQgZGF0YWJhc2Ugb3BlcmF0aW9ucy4gU09RTCByZXRyaWV2ZXMgcmVjb3JkcyBmcm9tIFNhbGVzZm9yY2UsIERNTCBvcGVyYXRpb25zIG1vZGlmeSB0aGVtLicsXG4gICAgY29kZUV4YW1wbGVzOiBbXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnQmFzaWMgU09RTCBRdWVyaWVzJyxcbiAgICAgICAgY29kZTogYHB1YmxpYyBjbGFzcyBRdWVyeURlbW8ge1xuICAgIHB1YmxpYyB2b2lkIGJhc2ljUXVlcmllcygpIHtcbiAgICAgICAgLy8g4pyFIFdIQVQ6IEJhc2ljIFNFTEVDVCB3aXRoIHNwZWNpZmljIGZpZWxkc1xuICAgICAgICBMaXN0PEFjY291bnQ+IGFjY291bnRzID0gW1xuICAgICAgICAgICAgU0VMRUNUIElkLCBOYW1lLCBUeXBlLCBJbmR1c3RyeVxuICAgICAgICAgICAgRlJPTSBBY2NvdW50XG4gICAgICAgICAgICBXSEVSRSBUeXBlID0gJ0N1c3RvbWVyJ1xuICAgICAgICAgICAgTElNSVQgMTAwXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8g4pyFIFdIQVQ6IFF1ZXJ5IHdpdGggcmVsYXRpb25zaGlwcyAobG9va3VwKVxuICAgICAgICBMaXN0PENvbnRhY3Q+IGNvbnRhY3RzID0gW1xuICAgICAgICAgICAgU0VMRUNUIElkLCBOYW1lLCBFbWFpbCxcbiAgICAgICAgICAgICAgICAgICBBY2NvdW50Lk5hbWUsIEFjY291bnQuSW5kdXN0cnlcbiAgICAgICAgICAgIEZST00gQ29udGFjdFxuICAgICAgICAgICAgV0hFUkUgQWNjb3VudC5UeXBlID0gJ0N1c3RvbWVyJ1xuICAgICAgICBdO1xuXG4gICAgICAgIC8vIOKchSBXSEFUOiBRdWVyeSB3aXRoIGNoaWxkIHJlbGF0aW9uc2hpcHNcbiAgICAgICAgTGlzdDxBY2NvdW50PiBhY2NvdW50c1dpdGhDb250YWN0cyA9IFtcbiAgICAgICAgICAgIFNFTEVDVCBJZCwgTmFtZSxcbiAgICAgICAgICAgICAgICAgICAoU0VMRUNUIElkLCBOYW1lLCBFbWFpbCBGUk9NIENvbnRhY3RzKVxuICAgICAgICAgICAgRlJPTSBBY2NvdW50XG4gICAgICAgICAgICBXSEVSRSBJZCBJTiA6YWNjb3VudElkc1xuICAgICAgICBdO1xuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ1NPUUwgc3ludGF4IGlzIHNpbWlsYXIgdG8gU1FMIGJ1dCB3aXRoIFNhbGVzZm9yY2Utc3BlY2lmaWMgZmVhdHVyZXMgbGlrZSByZWxhdGlvbnNoaXAgcXVlcmllcy4gQWx3YXlzIHNwZWNpZnkgbmVlZGVkIGZpZWxkcyBleHBsaWNpdGx5IGFuZCB1c2UgTElNSVQgdG8gcHJldmVudCBnb3Zlcm5vciBsaW1pdCBpc3N1ZXMuJ1xuICAgICAgfVxuICAgIF0sXG4gICAgcHJhY3RpY2VRdWVzdGlvbnM6IFtcbiAgICAgIC8vIFByYWN0aWNlIHF1ZXN0aW9ucyBmb3IgU09RTC4uLlxuICAgIF1cbiAgfSxcblxuICAndHJpZ2dlcnMtYW5kLWF1dG9tYXRpb24nOiB7XG4gICAgdGl0bGU6ICdUcmlnZ2VycyBhbmQgQXV0b21hdGlvbicsXG4gICAgb3ZlcnZpZXc6ICdNYXN0ZXIgQXBleCB0cmlnZ2VycyBhbmQgYXV0b21hdGlvbiBwYXR0ZXJucy4gVHJpZ2dlcnMgZXhlY3V0ZSBhdXRvbWF0aWNhbGx5IHdoZW4gcmVjb3JkcyBhcmUgaW5zZXJ0ZWQsIHVwZGF0ZWQsIG9yIGRlbGV0ZWQuJyxcbiAgICBjb2RlRXhhbXBsZXM6IFtcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdUcmlnZ2VyIFN0cnVjdHVyZScsXG4gICAgICAgIGNvZGU6IGB0cmlnZ2VyIEFjY291bnRUcmlnZ2VyIG9uIEFjY291bnQgKGJlZm9yZSBpbnNlcnQsIGJlZm9yZSB1cGRhdGUsIGFmdGVyIGluc2VydCwgYWZ0ZXIgdXBkYXRlKSB7XG4gICAgLy8g4pyFIFdIQVQ6IFNpbmdsZSB0cmlnZ2VyIGhhbmRsZXMgbXVsdGlwbGUgZXZlbnRzXG4gICAgLy8g4pyFIFdIWTogQmV0dGVyIG9yZ2FuaXphdGlvbiBhbmQgcHJlZGljdGFibGUgZXhlY3V0aW9uIG9yZGVyXG5cbiAgICBpZiAoVHJpZ2dlci5pc0JlZm9yZSkge1xuICAgICAgICBpZiAoVHJpZ2dlci5pc0luc2VydCB8fCBUcmlnZ2VyLmlzVXBkYXRlKSB7XG4gICAgICAgICAgICBBY2NvdW50VHJpZ2dlckhhbmRsZXIudmFsaWRhdGVBY2NvdW50cyhUcmlnZ2VyLm5ldyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoVHJpZ2dlci5pc0FmdGVyKSB7XG4gICAgICAgIGlmIChUcmlnZ2VyLmlzSW5zZXJ0KSB7XG4gICAgICAgICAgICBBY2NvdW50VHJpZ2dlckhhbmRsZXIuY3JlYXRlRGVmYXVsdENvbnRhY3RzKFRyaWdnZXIubmV3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChUcmlnZ2VyLmlzVXBkYXRlKSB7XG4gICAgICAgICAgICBBY2NvdW50VHJpZ2dlckhhbmRsZXIudXBkYXRlUmVsYXRlZE9wcG9ydHVuaXRpZXMoXG4gICAgICAgICAgICAgICAgVHJpZ2dlci5uZXcsXG4gICAgICAgICAgICAgICAgVHJpZ2dlci5vbGRNYXBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59YCxcbiAgICAgICAgZXhwbGFuYXRpb246ICdVc2UgYSBzaW5nbGUgdHJpZ2dlciBwZXIgb2JqZWN0IHdpdGggbXVsdGlwbGUgZXZlbnRzLiBEZWxlZ2F0ZSBsb2dpYyB0byBoYW5kbGVyIGNsYXNzZXMgZm9yIGJldHRlciBvcmdhbml6YXRpb24gYW5kIHRlc3RhYmlsaXR5LidcbiAgICAgIH1cbiAgICBdLFxuICAgIHByYWN0aWNlUXVlc3Rpb25zOiBbXG4gICAgICAvLyBQcmFjdGljZSBxdWVzdGlvbnMgZm9yIFRyaWdnZXJzLi4uXG4gICAgXVxuICB9LFxuXG4gICdhc3luY2hyb25vdXMtYXBleCc6IHtcbiAgICB0aXRsZTogJ0FzeW5jaHJvbm91cyBBcGV4JyxcbiAgICBvdmVydmlldzogJ01hc3RlciBhc3luY2hyb25vdXMgcHJvY2Vzc2luZyB3aXRoIEZ1dHVyZSwgQmF0Y2gsIFF1ZXVlYWJsZSwgYW5kIFNjaGVkdWxhYmxlIEFwZXggZm9yIGhhbmRsaW5nIGxhcmdlIGRhdGEgdm9sdW1lcy4nLFxuICAgIGNvZGVFeGFtcGxlczogW1xuICAgICAge1xuICAgICAgICB0aXRsZTogJ0Z1dHVyZSBNZXRob2RzJyxcbiAgICAgICAgY29kZTogYHB1YmxpYyBjbGFzcyBBc3luY0RlbW8ge1xuICAgIC8vIOKchSBXSEFUOiBGdXR1cmUgbWV0aG9kIGZvciBhc3luYyBwcm9jZXNzaW5nXG4gICAgQGZ1dHVyZVxuICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBwcm9jZXNzQWNjb3VudHNBc3luYyhTZXQ8SWQ+IGFjY291bnRJZHMpIHtcbiAgICAgICAgLy8g4pyFIFdIQVQ6IFF1ZXJ5IHJlY29yZHMgaW4gdGhlIGFzeW5jIG1ldGhvZFxuICAgICAgICBMaXN0PEFjY291bnQ+IGFjY291bnRzID0gW1xuICAgICAgICAgICAgU0VMRUNUIElkLCBOYW1lLCBJbmR1c3RyeVxuICAgICAgICAgICAgRlJPTSBBY2NvdW50XG4gICAgICAgICAgICBXSEVSRSBJZCBJTiA6YWNjb3VudElkc1xuICAgICAgICBdO1xuXG4gICAgICAgIGZvciAoQWNjb3VudCBhY2MgOiBhY2NvdW50cykge1xuICAgICAgICAgICAgLy8gTG9uZy1ydW5uaW5nIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGFjYy5EZXNjcmlwdGlvbiA9ICdQcm9jZXNzZWQgYXN5bmMgb24gJyArIFN5c3RlbS5ub3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZSBhY2NvdW50cztcbiAgICB9XG59YCxcbiAgICAgICAgZXhwbGFuYXRpb246ICdGdXR1cmUgbWV0aG9kcyBydW4gYXN5bmNocm9ub3VzbHkgYW5kIG11c3QgYmUgc3RhdGljLiBUaGV5IGNhbiBvbmx5IGFjY2VwdCBwcmltaXRpdmUgdHlwZXMgYW5kIGNvbGxlY3Rpb25zIG9mIHByaW1pdGl2ZXMgYXMgcGFyYW1ldGVycy4nXG4gICAgICB9XG4gICAgXSxcbiAgICBwcmFjdGljZVF1ZXN0aW9uczogW1xuICAgICAgLy8gUHJhY3RpY2UgcXVlc3Rpb25zIGZvciBBc3luYyBBcGV4Li4uXG4gICAgXVxuICB9LFxuXG4gICd0ZXN0aW5nLWFuZC1kZWJ1Z2dpbmcnOiB7XG4gICAgdGl0bGU6ICdUZXN0aW5nIGFuZCBEZWJ1Z2dpbmcnLFxuICAgIG92ZXJ2aWV3OiAnTWFzdGVyIHVuaXQgdGVzdGluZywgdGVzdCBkYXRhIGNyZWF0aW9uLCBhbmQgdGVzdCBhdXRvbWF0aW9uIGluIEFwZXguIFByb3BlciB0ZXN0aW5nIGVuc3VyZXMgY29kZSBxdWFsaXR5IGFuZCBwcmV2ZW50cyByZWdyZXNzaW9ucy4nLFxuICAgIGNvZGVFeGFtcGxlczogW1xuICAgICAge1xuICAgICAgICB0aXRsZTogJ0Jhc2ljIFRlc3QgU3RydWN0dXJlJyxcbiAgICAgICAgY29kZTogYEBJc1Rlc3RcbnB1YmxpYyBjbGFzcyBBY2NvdW50UHJvY2Vzc29yVGVzdCB7XG5cbiAgICBAVGVzdFNldHVwXG4gICAgc3RhdGljIHZvaWQgY3JlYXRlVGVzdERhdGEoKSB7XG4gICAgICAgIC8vIOKchSBXSEFUOiBUZXN0IGRhdGEgY3JlYXRlZCBvbmNlIGZvciBhbGwgdGVzdCBtZXRob2RzXG4gICAgICAgIExpc3Q8QWNjb3VudD4gdGVzdEFjY291bnRzID0gbmV3IExpc3Q8QWNjb3VudD4oKTtcbiAgICAgICAgZm9yIChJbnRlZ2VyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgdGVzdEFjY291bnRzLmFkZChuZXcgQWNjb3VudChcbiAgICAgICAgICAgICAgICBOYW1lID0gJ1Rlc3QgQWNjb3VudCAnICsgaSxcbiAgICAgICAgICAgICAgICBUeXBlID0gJ0N1c3RvbWVyJyxcbiAgICAgICAgICAgICAgICBJbmR1c3RyeSA9ICdUZWNobm9sb2d5J1xuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0IHRlc3RBY2NvdW50cztcbiAgICB9XG5cbiAgICBASXNUZXN0XG4gICAgc3RhdGljIHZvaWQgdGVzdEFjY291bnRQcm9jZXNzaW5nKCkge1xuICAgICAgICAvLyDinIUgV0hBVDogUXVlcnkgdGVzdCBkYXRhXG4gICAgICAgIExpc3Q8QWNjb3VudD4gYWNjb3VudHMgPSBbU0VMRUNUIElkLCBOYW1lIEZST00gQWNjb3VudF07XG5cbiAgICAgICAgVGVzdC5zdGFydFRlc3QoKTtcbiAgICAgICAgLy8g4pyFIFdIQVQ6IEV4ZWN1dGUgY29kZSB1bmRlciB0ZXN0XG4gICAgICAgIEFjY291bnRQcm9jZXNzb3IgcHJvY2Vzc29yID0gbmV3IEFjY291bnRQcm9jZXNzb3IoJ1Rlc3QgUHJvY2Vzc29yJywgMjApO1xuICAgICAgICBwcm9jZXNzb3IucHJvY2Vzc0FjY291bnRzKGFjY291bnRzKTtcbiAgICAgICAgVGVzdC5zdG9wVGVzdCgpO1xuXG4gICAgICAgIC8vIOKchSBXSEFUOiBWZXJpZnkgcmVzdWx0c1xuICAgICAgICBMaXN0PEFjY291bnQ+IHByb2Nlc3NlZEFjY291bnRzID0gW1xuICAgICAgICAgICAgU0VMRUNUIElkLCBMYXN0X1Byb2Nlc3NlZF9EYXRlX19jXG4gICAgICAgICAgICBGUk9NIEFjY291bnRcbiAgICAgICAgXTtcblxuICAgICAgICBmb3IgKEFjY291bnQgYWNjIDogcHJvY2Vzc2VkQWNjb3VudHMpIHtcbiAgICAgICAgICAgIFN5c3RlbS5hc3NlcnROb3RFcXVhbHMobnVsbCwgYWNjLkxhc3RfUHJvY2Vzc2VkX0RhdGVfX2MsXG4gICAgICAgICAgICAgICAgJ0FjY291bnQgc2hvdWxkIGhhdmUgcHJvY2Vzc2luZyBkYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG59YCxcbiAgICAgICAgZXhwbGFuYXRpb246ICdVc2UgQFRlc3RTZXR1cCBmb3IgY29tbW9uIHRlc3QgZGF0YSwgVGVzdC5zdGFydFRlc3QoKS9zdG9wVGVzdCgpIHRvIHJlc2V0IGdvdmVybm9yIGxpbWl0cywgYW5kIFN5c3RlbS5hc3NlcnQgbWV0aG9kcyB0byB2ZXJpZnkgcmVzdWx0cy4nXG4gICAgICB9XG4gICAgXSxcbiAgICBwcmFjdGljZVF1ZXN0aW9uczogW1xuICAgICAgLy8gUHJhY3RpY2UgcXVlc3Rpb25zIGZvciBUZXN0aW5nLi4uXG4gICAgXVxuICB9XG59OyJdLCJuYW1lcyI6WyJ0b3BpY0NvbnRlbnQiLCJ0aXRsZSIsIm92ZXJ2aWV3IiwiY29kZUV4YW1wbGVzIiwiY29kZSIsImV4cGxhbmF0aW9uIiwicHJhY3RpY2VRdWVzdGlvbnMiLCJudW1iZXIiLCJkaWZmaWN1bHR5IiwicXVlc3Rpb24iLCJhbnN3ZXIiLCJjb3JyZWN0Q29kZSIsImtleUxlYXJuaW5nIiwiZXhhbVRpcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/topicContent.ts\n"));

/***/ })

});