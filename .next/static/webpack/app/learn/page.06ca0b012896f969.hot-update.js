"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/learn/page",{

/***/ "(app-pages-browser)/./src/data/topicContent.ts":
/*!**********************************!*\
  !*** ./src/data/topicContent.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   topicContent: function() { return /* binding */ topicContent; }\n/* harmony export */ });\nconst topicContent = {\n    \"variables-and-data-types\": {\n        title: \"Variables and Data Types\",\n        overview: \"Master Apex variables, primitive data types, and type conversion. Variables are the foundation of every Apex program - they store information your code needs. Understanding variables is crucial because EVERYTHING in Salesforce development builds on this: from simple field updates to complex business logic. This topic sets the stage for Collections (multiple values), Control Flow (decisions about values), and beyond.\",\n        codeExamples: [\n            {\n                title: \"Basic Variable Declaration\",\n                code: \"public class VariableExample {\\n    // ✅ WHAT: Class declaration with public access\\n    // \\uD83D\\uDC80 EXAM TRAP: Class name must match filename exactly\\n\\n    private String customerName;\\n    // ✅ WHAT: Instance variable for storing text\\n    // ✅ WHY: private = controlled access (encapsulation)\\n    // \\uD83D\\uDC80 COMMON MISTAKE: Variables default to null (not empty)\\n\\n    private Integer age = 0;\\n    // ✅ WHAT: Whole number with safe initialization\\n    // ✅ WHY: Prevents null pointer exceptions\\n    // \\uD83D\\uDC80 EXAM TRAP: Use Integer (not int) in Apex\\n\\n    public VariableExample(String name) {\\n        this.customerName = name;\\n        // ✅ WHAT: this = current object reference\\n        // ✅ WHY: Distinguishes parameter from field\\n    }\\n}\",\n                explanation: \"Apex uses wrapper types (Integer, Boolean, String) instead of Java primitives. All variables can be null and have methods. Always initialize variables or check for null before using them.\"\n            },\n            {\n                title: \"String Operations\",\n                code: \"public class StringDemo {\\n    public void processNames() {\\n        String firstName = 'John';\\n        // \\uD83D\\uDC80 EXAM TRAP: Single quotes (not double) in Apex\\n\\n        String lastName = 'Doe';\\n        String fullName = firstName + ' ' + lastName;\\n        // ✅ RESULT: 'John Doe'\\n\\n        Boolean hasContent = String.isNotBlank(fullName);\\n        // ✅ SAFE: Checks null AND empty AND whitespace\\n        // ✅ BETTER THAN: fullName != null && fullName.length() > 0\\n\\n        if (hasContent) {\\n            System.debug('Name: ' + fullName.toUpperCase());\\n        }\\n    }\\n}\",\n                explanation: \"String operations in Apex are null-safe when using built-in methods like isNotBlank(). Always use these instead of manual null checks for robust code.\"\n            },\n            {\n                title: \"Type Conversion\",\n                code: \"public class ConversionDemo {\\n    public void safeConversion() {\\n        String numberStr = '123';\\n        Integer result;\\n\\n        // ✅ SAFE: Check before converting\\n        if (numberStr.isNumeric()) {\\n            result = Integer.valueOf(numberStr);\\n        } else {\\n            result = 0; // Default fallback\\n        }\\n\\n        // ✅ SAFE: Try-catch for complex conversions\\n        try {\\n            Decimal price = Decimal.valueOf('19.99');\\n            System.debug('Price: ' + price);\\n        } catch (TypeException e) {\\n            System.debug('Invalid number format');\\n        }\\n    }\\n}\",\n                explanation: \"Always validate input before type conversion. Use isNumeric() for basic checks and try-catch for complex scenarios. TypeException is thrown for invalid conversions.\"\n            }\n        ],\n        practiceQuestions: [\n            {\n                number: 1,\n                difficulty: \"beginner\",\n                question: \"What is wrong with this code?\",\n                code: \"String name;\\nInteger length = name.length();\",\n                answer: \"NullPointerException will be thrown\",\n                explanation: \"The variable 'name' is declared but not initialized, so it defaults to null. Calling .length() on a null String throws a NullPointerException at runtime.\",\n                correctCode: \"String name = 'John';  // Initialize the variable\\nInteger length = name.length();  // Now safe to call\",\n                keyLearning: \"Always initialize variables or check for null before using them. Uninitialized reference variables default to null.\",\n                examTip: \"This is a very common PD1 certification question pattern. Always look for uninitialized variables in code samples.\"\n            },\n            {\n                number: 2,\n                difficulty: \"beginner\",\n                question: \"Which data type should you use for storing currency values in Salesforce?\",\n                answer: \"Decimal\",\n                explanation: \"Decimal is the best choice for currency because it provides exact precision without floating-point rounding errors. Double/Float can introduce rounding errors that are unacceptable for financial calculations.\",\n                correctCode: \"Decimal price = 19.99;\\nDecimal total = price * 1.08;  // Exact calculation\",\n                keyLearning: \"Use Decimal for financial calculations to avoid floating-point precision issues. Currency fields in Salesforce are also stored as Decimal.\",\n                examTip: \"Salesforce strongly recommends Decimal for currency. This appears in PD1 questions about data type selection.\"\n            },\n            {\n                number: 3,\n                difficulty: \"beginner\",\n                question: \"What happens when you declare 'Integer count;' without initialization?\",\n                answer: \"count defaults to null\",\n                explanation: \"In Apex, uninitialized primitive wrapper types (Integer, Double, Boolean, etc.) default to null, not zero. This is different from Java where primitives have default values.\",\n                correctCode: \"Integer count = 0;  // Explicitly initialize\\n// OR\\nInteger count;\\nif (count == null) {\\n    count = 0;  // Handle null case\\n}\",\n                keyLearning: \"Apex primitive wrappers default to null, not zero. Always initialize or null-check before using.\",\n                examTip: \"PD1 exam tests understanding of null vs zero. Remember Apex uses wrapper types (Integer) not primitives (int).\"\n            },\n            {\n                number: 4,\n                difficulty: \"beginner\",\n                question: \"Fix this code: 'boolean isActive = true;'\",\n                answer: \"Use Boolean (capital B) instead of boolean\",\n                explanation: \"Apex uses wrapper types, not Java primitives. 'boolean' (lowercase) doesn't exist in Apex - use 'Boolean' (capital B).\",\n                correctCode: \"Boolean isActive = true;  // Correct wrapper type\",\n                keyLearning: \"Apex only has wrapper types (Boolean, Integer, Double), not Java primitives (boolean, int, double).\",\n                examTip: \"Case sensitivity is tested on PD1. Always use capital letters for Apex data types.\"\n            },\n            {\n                number: 5,\n                difficulty: \"intermediate\",\n                question: \"What's the difference between 'Integer' and 'int' in Apex?\",\n                answer: \"'int' doesn't exist in Apex - only 'Integer' is valid\",\n                explanation: \"Unlike Java, Apex only has wrapper types. There are no primitive types like 'int', 'boolean', or 'double' in Apex. All data types are objects that can be null.\",\n                correctCode: \"Integer count = 10;     // Correct\\nBoolean flag = true;    // Correct\\nDouble rate = 2.5;      // Correct\",\n                keyLearning: \"Apex simplifies Java by only having wrapper types. This means all variables can be null and have methods.\",\n                examTip: \"This fundamental difference from Java is frequently tested. Remember: Apex = wrapper types only.\"\n            },\n            {\n                number: 6,\n                difficulty: \"intermediate\",\n                question: \"What happens with this code: Decimal d1 = null; Decimal d2 = 10; Decimal result = d1 + d2;\",\n                answer: \"NullPointerException is thrown\",\n                explanation: \"When performing arithmetic operations with Decimal variables, if any operand is null, the operation throws a NullPointerException. Unlike some languages that might treat null as zero, Apex requires explicit null checking.\",\n                correctCode: \"Decimal d1 = null;\\nDecimal d2 = 10;\\nDecimal result = (d1 != null ? d1 : 0) + d2;  // Safe addition\",\n                keyLearning: \"Always null-check Decimal variables before arithmetic operations. Apex doesn't auto-convert null to zero.\",\n                examTip: \"Null arithmetic operations are frequently tested scenarios on certification exams.\"\n            },\n            {\n                number: 7,\n                difficulty: \"beginner\",\n                question: \"You're reviewing code and see 'String name; System.debug(name.toUpperCase());' - what will happen and how do you fix it?\",\n                answer: \"NullPointerException will be thrown because 'name' is uninitialized (null)\",\n                explanation: \"In Apex, declaring a variable without initialization sets it to null. Calling methods on null objects throws NullPointerException at runtime. This is a common mistake for developers coming from languages where primitives have default values.\",\n                correctCode: \"// Option 1: Initialize with a value\\nString name = 'John';\\nSystem.debug(name.toUpperCase()); // Safe\\n\\n// Option 2: Null-check before use\\nString name;\\nif (String.isNotBlank(name)) {\\n    System.debug(name.toUpperCase());\\n}\",\n                keyLearning: \"Always initialize variables or null-check before calling methods. Uninitialized reference variables default to null in Apex.\",\n                examTip: \"This exact pattern appears frequently on certification exams. Always look for uninitialized variables in code samples.\"\n            },\n            {\n                number: 8,\n                difficulty: \"intermediate\",\n                question: \"A junior developer asks why 'int count = 0;' doesn't work in Apex. How do you explain it?\",\n                answer: \"Apex only has wrapper types like 'Integer', not primitives like 'int'\",\n                explanation: \"Unlike Java, Apex simplified the type system by only providing wrapper types (Integer, Boolean, Double, etc.). There are no primitive types (int, boolean, double) in Apex. This means all variables can be null and have methods.\",\n                correctCode: \"Integer count = 0;        // Correct - wrapper type\\nBoolean isActive = true;  // Correct - wrapper type\\nDouble rate = 2.5;        // Correct - wrapper type\\n\\n// These don't exist in Apex:\\n// int count = 0;        // Compilation error\\n// boolean flag = true;  // Compilation error\",\n                keyLearning: \"Apex = wrapper types only. This simplifies the language but means all variables can be null.\",\n                examTip: \"Type system questions are common. Remember: Apex wrapper types (Integer) vs Java primitives (int) - only wrappers exist in Apex.\"\n            },\n            {\n                number: 9,\n                difficulty: \"intermediate\",\n                question: \"You need to store monetary values with precision. What data type do you choose and why?\",\n                answer: \"Decimal - it provides exact precision without floating-point rounding errors\",\n                explanation: \"For financial calculations, Decimal is the only safe choice because it avoids floating-point arithmetic errors that can occur with Double. Currency fields in Salesforce are stored as Decimal, making this the natural choice for monetary calculations.\",\n                correctCode: \"// Correct for currency\\nDecimal price = 19.99;\\nDecimal tax = price * 0.08;\\nDecimal total = price + tax;  // Exact calculation\\n\\n// Wrong for currency - can have rounding errors\\nDouble price = 19.99;\\nDouble tax = price * 0.08;    // Potential precision loss\",\n                keyLearning: \"Use Decimal for all financial calculations to avoid floating-point precision issues. Currency fields in Salesforce use Decimal.\",\n                examTip: \"Currency data type questions appear frequently. Remember: Decimal for money, Double/Float for scientific calculations.\"\n            },\n            {\n                number: 10,\n                difficulty: \"beginner\",\n                question: \"Code review: 'Boolean isActive;' - what's the potential issue and how do you improve it?\",\n                answer: \"Uninitialized Boolean defaults to null, not false, which can cause unexpected behavior\",\n                explanation: \"In Apex, Boolean variables default to null when uninitialized, not false. This can cause issues in conditional logic where you might expect false behavior. Explicit initialization prevents confusion and potential NPEs.\",\n                correctCode: \"// Better: Explicit initialization\\nBoolean isActive = false;  // Clear intent, no null issues\\n\\n// Or handle null explicitly\\nBoolean isActive;\\nif (isActive == true) {    // Explicit null-safe comparison\\n    System.debug('Active');\\n}\",\n                keyLearning: \"Boolean variables default to null, not false. Always initialize or use explicit null-safe comparisons.\",\n                examTip: \"Boolean null behavior is tested frequently. Remember: null != false in Apex Boolean logic.\"\n            },\n            {\n                number: 11,\n                difficulty: \"intermediate\",\n                question: \"A method receives a String parameter that might be null, empty, or whitespace. Write the safest validation.\",\n                answer: \"Use String.isNotBlank() for comprehensive validation\",\n                explanation: \"String.isNotBlank() is the most comprehensive check as it validates against null, empty string, and strings containing only whitespace characters. This is safer than manual null checks or isEmpty().\",\n                correctCode: \"public void processName(String name) {\\n    // Best: Handles null, empty, and whitespace\\n    if (String.isNotBlank(name)) {\\n        System.debug('Valid name: ' + name.trim());\\n    } else {\\n        System.debug('Invalid name provided');\\n    }\\n}\\n\\n// Alternative for specific cases:\\nif (String.isNotEmpty(name)) { } // null and empty only\\nif (name != null && name.length() > 0) { } // Manual, more verbose\",\n                keyLearning: \"String.isNotBlank() is your best friend for string validation. It handles all edge cases in one call.\",\n                examTip: \"String validation questions are common. Know the difference: isNotBlank (null/empty/whitespace), isNotEmpty (null/empty only).\"\n            },\n            {\n                number: 12,\n                difficulty: \"advanced\",\n                question: \"Explain when you'd use 'final' keyword with variables and give a practical example.\",\n                answer: \"Use 'final' for constants and variables that shouldn't be reassigned after initialization\",\n                explanation: \"The 'final' keyword prevents variable reassignment after initialization, making code more predictable and catching accidental modifications. It's especially useful for constants, configuration values, and protecting important references.\",\n                correctCode: \"public class ConfigurationManager {\\n    // Class constant - compile-time constant\\n    private static final Integer MAX_RETRIES = 3;\\n\\n    // Instance constant - runtime constant\\n    private final String organizationId;\\n\\n    public ConfigurationManager() {\\n        // Can only be set once during construction\\n        this.organizationId = UserInfo.getOrganizationId();\\n    }\\n\\n    public void processData(List<Account> accounts) {\\n        // Method-level constant\\n        final Integer BATCH_SIZE = 200;\\n\\n        // organizationId = 'new-id';  // Compilation error\\n        // BATCH_SIZE = 300;           // Compilation error\\n    }\\n}\",\n                keyLearning: \"'final' prevents reassignment and documents intent. Use for constants, configuration, and protecting important references.\",\n                examTip: \"Final keyword questions test understanding of immutability. Remember: prevents reassignment, not object modification.\"\n            },\n            {\n                number: 13,\n                difficulty: \"intermediate\",\n                question: \"You see 'Object data = someMethod();' - what are the risks and how do you handle them safely?\",\n                answer: \"Risk of ClassCastException and loss of type safety. Use instanceof checks and explicit casting\",\n                explanation: \"Object is the most generic type in Apex. Using it loses compile-time type checking and requires runtime type verification. This can lead to ClassCastException if you cast to the wrong type.\",\n                correctCode: \"Object data = someMethod();\\n\\n// Safe approach with instanceof\\nif (data instanceof String) {\\n    String stringData = (String) data;\\n    System.debug('String value: ' + stringData);\\n} else if (data instanceof Integer) {\\n    Integer intData = (Integer) data;\\n    System.debug('Integer value: ' + intData);\\n} else if (data instanceof List<Object>) {\\n    List<Object> listData = (List<Object>) data;\\n    System.debug('List size: ' + listData.size());\\n} else {\\n    System.debug('Unknown data type: ' + (data != null ? data.getClass() : 'null'));\\n}\",\n                keyLearning: \"Object type loses type safety. Always use instanceof before casting to prevent ClassCastException.\",\n                examTip: \"Object casting questions test type safety understanding. Remember: instanceof before casting, handle null case.\"\n            },\n            {\n                number: 14,\n                difficulty: \"beginner\",\n                question: \"A developer uses 'Double' for currency calculations. What problems could this cause?\",\n                answer: \"Floating-point precision errors that can cause incorrect monetary calculations\",\n                explanation: \"Double uses floating-point arithmetic which can't exactly represent many decimal numbers, leading to rounding errors. For financial calculations, even tiny errors compound and can cause significant issues in accounting and reporting.\",\n                correctCode: \"// Wrong - potential precision errors\\nDouble price = 0.1;\\nDouble tax = 0.2;\\nDouble total = price + tax;  // Might not equal exactly 0.3\\n\\n// Correct - exact decimal arithmetic\\nDecimal price = 0.1;\\nDecimal tax = 0.2;\\nDecimal total = price + tax;  // Exactly 0.3\\n\\n// Real example\\nDecimal itemPrice = 19.99;\\nDecimal taxRate = 0.0825;    // 8.25%\\nDecimal totalPrice = itemPrice * (1 + taxRate);\",\n                keyLearning: \"Never use Double for currency. Decimal provides exact precision for financial calculations.\",\n                examTip: \"Currency precision questions are frequent. Remember: Decimal for money, Double for scientific measurements.\"\n            },\n            {\n                number: 15,\n                difficulty: \"intermediate\",\n                question: \"Write code to safely convert user input from String to Integer with proper error handling.\",\n                answer: \"Use try-catch with Integer.valueOf() and validate input first\",\n                explanation: \"String to Integer conversion can fail if the string contains non-numeric characters. Always validate input and handle TypeException to provide meaningful error messages.\",\n                correctCode: \"public Integer safeStringToInteger(String input, Integer defaultValue) {\\n    // Early validation\\n    if (String.isBlank(input)) {\\n        return defaultValue;\\n    }\\n\\n    // Remove whitespace\\n    input = input.trim();\\n\\n    // Check if purely numeric (optional optimization)\\n    if (!input.isNumeric()) {\\n        System.debug('Non-numeric input: ' + input);\\n        return defaultValue;\\n    }\\n\\n    try {\\n        return Integer.valueOf(input);\\n    } catch (TypeException e) {\\n        System.debug('Conversion error for input \\\"' + input + '\\\": ' + e.getMessage());\\n        return defaultValue;\\n    }\\n}\\n\\n// Usage example\\nInteger userAge = safeStringToInteger(userInput, 0);\",\n                keyLearning: \"Always validate string input before type conversion. Use try-catch for TypeException and provide meaningful defaults.\",\n                examTip: \"Type conversion questions test error handling skills. Remember: validate, try-catch, provide defaults.\"\n            },\n            {\n                number: 16,\n                difficulty: \"beginner\",\n                question: \"You need to compare two String variables for equality. What are the different approaches and their implications?\",\n                answer: \"Use .equals() method for content comparison, never == operator\",\n                explanation: \"In Apex (like Java), the == operator compares object references, not content. For string content comparison, always use .equals() method. This is a common source of bugs for developers new to Apex.\",\n                correctCode: \"String name1 = 'John';\\nString name2 = getName(); // Returns 'John'\\n\\n// Wrong - compares references (might be false even with same content)\\nif (name1 == name2) { }\\n\\n// Correct - compares content\\nif (name1.equals(name2)) { }\\n\\n// Better - null-safe comparison\\nif (name1?.equals(name2) == true) { }\\n\\n// Best - using String utility (handles nulls)\\nif (String.isEmpty(name1) && String.isEmpty(name2)) {\\n    // Both empty/null\\n} else if (name1?.equals(name2) == true) {\\n    // Content matches\\n}\",\n                keyLearning: \"String comparison: == compares references, .equals() compares content. Always use .equals() for string comparison.\",\n                examTip: \"String comparison is heavily tested. Remember: == for primitives/references, .equals() for content comparison.\"\n            },\n            {\n                number: 17,\n                difficulty: \"intermediate\",\n                question: \"A field might contain null or actual data. Write defensive code to handle both cases.\",\n                answer: \"Use null-coalescing operators and safe navigation for robust handling\",\n                explanation: \"Apex provides several mechanisms for safe null handling: null-coalescing (?:), safe navigation (?.), and traditional null checks. Combining these creates robust, readable code.\",\n                correctCode: \"public void processAccountData(Account acc) {\\n    // Null-coalescing - provide default if null\\n    String accountName = acc.Name ?? 'Unknown Account';\\n\\n    // Safe navigation - only call if not null\\n    Integer nameLength = acc.Name?.length();\\n\\n    // Traditional null check for complex logic\\n    if (acc.AnnualRevenue != null) {\\n        Decimal monthlyRevenue = acc.AnnualRevenue / 12;\\n        System.debug('Monthly revenue: ' + monthlyRevenue);\\n    } else {\\n        System.debug('Annual revenue not set');\\n    }\\n\\n    // Combining approaches\\n    String displayText = acc.Description?.abbreviate(50) ?? 'No description available';\\n\\n    // Safe field access with default\\n    String industry = acc.Industry ?? 'Not Specified';\\n    String type = acc.Type ?? 'Standard';\\n}\",\n                keyLearning: \"Use null-coalescing (??) for defaults, safe navigation (?.) for method calls, explicit checks for complex logic.\",\n                examTip: \"Null handling is critical for robust code. Know all three approaches: ??, ?., and explicit null checks.\"\n            },\n            {\n                number: 18,\n                difficulty: \"beginner\",\n                question: \"Explain the difference between 'String s = null;' and 'String s = \\\"\\\";' and when each matters.\",\n                answer: \"null means no object exists, empty string means object exists but contains no characters\",\n                explanation: \"This distinction is crucial for validation and business logic. null typically means 'no value provided' while empty string means 'value provided but empty'. Different validation methods handle these cases differently.\",\n                correctCode: \"String nullString = null;      // No object\\nString emptyString = '';       // Object exists, no content\\nString blankString = '   ';    // Object exists, whitespace only\\n\\n// Different validation results:\\nSystem.debug(String.isEmpty(nullString));     // true\\nSystem.debug(String.isEmpty(emptyString));    // true\\nSystem.debug(String.isEmpty(blankString));    // false\\n\\nSystem.debug(String.isBlank(nullString));     // true\\nSystem.debug(String.isBlank(emptyString));    // true\\nSystem.debug(String.isBlank(blankString));    // true\\n\\n// Null-safe operations:\\nSystem.debug(nullString?.length());           // null\\nSystem.debug(emptyString?.length());          // 0\\nSystem.debug(blankString?.length());          // 3\",\n                keyLearning: \"null = no object, empty = object with no content. Use appropriate validation method based on business needs.\",\n                examTip: \"String state questions are common. Know: null (no object), empty (no content), blank (no meaningful content).\"\n            },\n            {\n                number: 19,\n                difficulty: \"advanced\",\n                question: \"You're processing form data where numbers come as strings. Show the complete safe conversion pattern.\",\n                answer: \"Comprehensive validation with multiple fallback strategies\",\n                explanation: \"Real-world form processing requires handling various edge cases: null values, empty strings, non-numeric content, decimal vs integer, negative values, and range validation.\",\n                correctCode: \"public class FormDataProcessor {\\n    public static Decimal parseDecimalField(String input, String fieldName, Decimal defaultValue) {\\n        // Step 1: Handle null/empty\\n        if (String.isBlank(input)) {\\n            System.debug(fieldName + ' is blank, using default: ' + defaultValue);\\n            return defaultValue;\\n        }\\n\\n        // Step 2: Clean the input\\n        String cleaned = input.trim().replace(',', ''); // Remove commas\\n\\n        // Step 3: Basic numeric validation\\n        String numericPattern = '^-?\\\\d*\\\\.?\\\\d+$';\\n        if (!Pattern.matches(numericPattern, cleaned)) {\\n            System.debug('Invalid numeric format for ' + fieldName + ': ' + input);\\n            return defaultValue;\\n        }\\n\\n        // Step 4: Safe conversion\\n        try {\\n            Decimal result = Decimal.valueOf(cleaned);\\n\\n            // Step 5: Range validation (example)\\n            if (fieldName.contains('Price') && result < 0) {\\n                System.debug('Negative price not allowed: ' + result);\\n                return 0;\\n            }\\n\\n            return result;\\n        } catch (TypeException e) {\\n            System.debug('Conversion failed for ' + fieldName + ': ' + e.getMessage());\\n            return defaultValue;\\n        }\\n    }\\n\\n    // Usage example\\n    public static void processOrderForm(Map<String, String> formData) {\\n        Decimal price = parseDecimalField(formData.get('price'), 'Price', 0.00);\\n        Decimal quantity = parseDecimalField(formData.get('qty'), 'Quantity', 1.00);\\n        Decimal total = price * quantity;\\n    }\\n}\",\n                keyLearning: \"Production form processing needs comprehensive validation: null handling, cleaning, format checking, type conversion, and business rules.\",\n                examTip: \"Complex validation scenarios test real-world skills. Think: validate → clean → convert → business rules.\"\n            },\n            {\n                number: 20,\n                difficulty: \"advanced\",\n                question: \"You're mentoring someone on variable naming. What are the key principles with examples?\",\n                answer: \"Use descriptive names, consistent conventions, and context-appropriate scope indicators\",\n                explanation: \"Good variable naming improves code readability and maintainability. Follow conventions that make intent clear, scope obvious, and purpose explicit.\",\n                correctCode: \"public class VariableNamingBestPractices {\\n    // Constants: SCREAMING_SNAKE_CASE\\n    private static final Integer MAX_RETRY_ATTEMPTS = 3;\\n    private static final String DEFAULT_COUNTRY_CODE = 'US';\\n\\n    // Instance variables: camelCase with descriptive names\\n    private String customerEmailAddress;\\n    private Decimal monthlyRecurringRevenue;\\n    private Date lastLoginTimestamp;\\n\\n    // Method parameters: camelCase, context-clear\\n    public void updateCustomerProfile(String newEmailAddress,\\n                                    Boolean isEmailVerified,\\n                                    Date profileLastModified) {\\n\\n        // Local variables: descriptive within scope\\n        String normalizedEmail = newEmailAddress.toLowerCase().trim();\\n        Boolean isValidEmailFormat = validateEmailFormat(normalizedEmail);\\n\\n        // Loop variables: short names OK for short scopes\\n        for (Integer i = 0; i < MAX_RETRY_ATTEMPTS; i++) {\\n            // Process with clear intent\\n        }\\n\\n        // Collection variables: plural nouns\\n        List<Contact> customerContacts = new List<Contact>();\\n        Map<Id, Account> accountsById = new Map<Id, Account>();\\n\\n        // Boolean variables: is/has/can/should prefixes\\n        Boolean hasValidLicense = checkLicenseStatus();\\n        Boolean canProcessPayment = validatePaymentMethod();\\n        Boolean shouldSendNotification = determineNotificationPreference();\\n    }\\n}\\n\\n// Bad examples to avoid:\\n// String s, str, temp, data          // Too generic\\n// Integer num1, num2                 // Unclear purpose\\n// Boolean flag, check                // What kind of flag/check?\\n// List<Object> list                  // What does it contain?\",\n                keyLearning: \"Good names are self-documenting. Use: descriptive nouns, action verbs, consistent conventions, appropriate scope length.\",\n                examTip: \"Code quality questions include naming conventions. Remember: constants (CAPS), variables (camelCase), booleans (is/has/can).\"\n            }\n        ]\n    },\n    \"collections-deep-dive\": {\n        title: \"Collections Deep Dive\",\n        overview: \"Master Lists, Sets, Maps and bulkification patterns. Now that you understand single values (Variables), learn to handle MULTIPLE values efficiently. Collections are essential for Salesforce bulk processing and prevent governor limit violations. This knowledge directly enables Control Flow (processing collections) and triggers (handling bulk data changes).\",\n        codeExamples: [\n            {\n                title: \"List Fundamentals\",\n                code: \"public class ListDemo {\\n    public void processList() {\\n        // ✅ BUILDING ON: Variables hold ONE value (String name = 'John')\\n        // ✅ NEW CONCEPT: Lists hold MULTIPLE values of same type\\n        List<String> names = new List<String>();\\n        // ✅ CONNECTION: Same String type from Variables topic, but now a container\\n        // ✅ WHY: Processing multiple records requires collections\\n        // \\uD83D\\uDCA1 NEXT TOPIC: You'll use loops (Control Flow) to process these efficiently\\n\\n        names.add('John');\\n        names.add('Jane');\\n        names.add('John'); // ✅ Lists allow duplicates (unlike Sets)\\n\\n        // ✅ BUILDING FORWARD: This validation pattern crucial in Triggers\\n        if (!names.isEmpty()) {\\n            String first = names.get(0);\\n            System.debug('First name: ' + first);\\n        }\\n\\n        // ✅ ENHANCED FOR LOOP: Process each item\\n        // \\uD83D\\uDCA1 NEXT TOPIC: This loop syntax comes from Control Flow\\n        for (String name : names) {\\n            // ✅ CONNECTION: String validation from Variables topic\\n            if (String.isNotBlank(name)) {\\n                System.debug('Processing valid name: ' + name);\\n            }\\n        }\\n        // \\uD83D\\uDCA1 BUILDING FORWARD: This pattern scales to process 200 records in Triggers\\n    }\\n}\",\n                explanation: \"Lists are ordered collections that allow duplicates. Always check isEmpty() before accessing elements to avoid ListException. Use enhanced for loops for cleaner iteration.\"\n            },\n            {\n                title: \"Set Operations\",\n                code: \"public class SetDemo {\\n    public void demonstrateSets() {\\n        // ✅ WHAT: Container for unique values only\\n        Set<String> uniqueEmails = new Set<String>();\\n        // ✅ WHY: Sets automatically prevent duplicates\\n        // ✅ PERFORMANCE: contains() is O(1) vs List O(n)\\n\\n        uniqueEmails.add('john@example.com');\\n        uniqueEmails.add('jane@example.com');\\n        uniqueEmails.add('john@example.com'); // Ignored - duplicate\\n\\n        System.debug('Size: ' + uniqueEmails.size()); // 2, not 3\\n\\n        // ✅ FAST LOOKUP: Use for existence checks\\n        if (uniqueEmails.contains('john@example.com')) {\\n            System.debug('Email found');\\n        }\\n    }\\n}\",\n                explanation: \"Sets enforce uniqueness and provide O(1) lookup performance. Use Sets when you need to prevent duplicates or perform fast existence checks.\"\n            },\n            {\n                title: \"Map Usage\",\n                code: \"public class MapDemo {\\n    public void processAccounts() {\\n        // ✅ WHAT: Key-value storage for fast lookups\\n        Map<Id, Account> accountMap = new Map<Id, Account>();\\n        // ✅ WHY: Get records by ID without loops\\n\\n        List<Account> accounts = [SELECT Id, Name FROM Account LIMIT 10];\\n\\n        // ✅ POPULATE: Add records to map\\n        for (Account acc : accounts) {\\n            accountMap.put(acc.Id, acc);\\n        }\\n\\n        // ✅ SAFE ACCESS: Check key exists\\n        Id searchId = accounts[0].Id;\\n        if (accountMap.containsKey(searchId)) {\\n            Account found = accountMap.get(searchId);\\n            System.debug('Found: ' + found.Name);\\n        }\\n    }\\n}\",\n                explanation: \"Maps provide key-value storage with O(1) lookup performance. Always use containsKey() before get() to avoid null issues. Essential for bulkification patterns.\"\n            }\n        ],\n        practiceQuestions: [\n            {\n                number: 1,\n                difficulty: \"beginner\",\n                question: \"What's the difference between a List and a Set in Apex?\",\n                answer: \"Lists allow duplicates and maintain order, Sets prevent duplicates and don't guarantee order\",\n                explanation: \"Lists are indexed collections that can contain duplicate values and maintain insertion order. Sets automatically enforce uniqueness - attempting to add a duplicate value is ignored, and elements are not stored in any particular order.\",\n                correctCode: \"List<String> names = new List<String>{'John', 'Jane', 'John'};  // 3 items\\nSet<String> uniqueNames = new Set<String>{'John', 'Jane', 'John'};  // 2 items\",\n                keyLearning: \"Choose Lists when order matters and duplicates are allowed. Choose Sets when you need to ensure uniqueness and fast lookups.\",\n                examTip: \"PD1 frequently tests List vs Set differences. Remember: Lists = order + duplicates, Sets = uniqueness + fast contains().\"\n            },\n            {\n                number: 2,\n                difficulty: \"beginner\",\n                question: \"How do you safely access the first element of a List?\",\n                answer: \"Check if the list is not empty first: if (!myList.isEmpty()) { firstElement = myList.get(0); }\",\n                explanation: \"Always check if a List has elements before accessing by index to avoid System.ListException. Using isEmpty() is more readable than checking size() > 0.\",\n                correctCode: \"List<String> names = new List<String>();\\nif (!names.isEmpty()) {\\n    String first = names.get(0);  // Safe access\\n} else {\\n    System.debug('List is empty');\\n}\",\n                keyLearning: \"Never assume a List has elements. Always check isEmpty() or size() before using get(index).\",\n                examTip: \"Index out of bounds exceptions are common exam scenarios. Always validate before accessing.\"\n            },\n            {\n                number: 3,\n                difficulty: \"intermediate\",\n                question: \"What's wrong with this bulkification pattern?\",\n                code: \"for (Account acc : Trigger.new) {\\n    List<Contact> contacts = [SELECT Id FROM Contact WHERE AccountId = :acc.Id];\\n    // Process contacts\\n}\",\n                answer: \"SOQL query inside a loop - will hit governor limits\",\n                explanation: \"Putting SOQL queries inside loops is the most common bulkification anti-pattern. With 200 accounts, this creates 200 separate queries, quickly hitting the 100 SOQL query limit per transaction.\",\n                correctCode: \"Set<Id> accountIds = new Set<Id>();\\nfor (Account acc : Trigger.new) {\\n    accountIds.add(acc.Id);\\n}\\nList<Contact> allContacts = [SELECT Id, AccountId FROM Contact WHERE AccountId IN :accountIds];\",\n                keyLearning: \"Always collect IDs first, then query once outside the loop. This is fundamental to writing scalable Apex.\",\n                examTip: \"Governor limit violations due to queries in loops are heavily tested on certification exams.\"\n            },\n            {\n                number: 4,\n                difficulty: \"intermediate\",\n                question: \"When should you use a Map instead of a List?\",\n                answer: \"When you need fast lookups by key or need to group related data\",\n                explanation: \"Maps provide O(1) lookup performance vs O(n) for Lists. Use Maps when you frequently need to find items by a unique identifier, or when grouping related objects together.\",\n                correctCode: \"// Good: Map for fast account lookup\\nMap<Id, Account> accountMap = new Map<Id, Account>([SELECT Id, Name FROM Account]);\\nAccount found = accountMap.get(someId);  // O(1) lookup\\n\\n// Bad: List requires loop for lookup\\nList<Account> accounts = [SELECT Id, Name FROM Account];\\nfor (Account acc : accounts) {  // O(n) lookup\\n    if (acc.Id == someId) { found = acc; break; }\\n}\",\n                keyLearning: \"Maps excel at key-based lookups and grouping. Lists are better for ordered data and iteration.\",\n                examTip: \"Performance questions about data structures appear frequently on Apex certification exams.\"\n            },\n            {\n                number: 5,\n                difficulty: \"advanced\",\n                question: \"You have a List with 100,000 records and need to check if a specific ID exists. What's the performance concern and solution?\",\n                answer: \"Linear search O(n) performance issue. Convert to Set or Map for O(1) lookups.\",\n                explanation: \"Lists require scanning every element to find matches, which becomes expensive with large datasets. Sets and Maps provide hash-based lookups that are dramatically faster for existence checks.\",\n                correctCode: \"// Problem: O(n) lookup - slow with large lists\\nList<Id> accountIds = new List<Id>(/* 100,000 IDs */);\\nBoolean exists = false;\\nfor (Id accId : accountIds) {\\n    if (accId == targetId) { exists = true; break; }  // Potentially scans all 100K\\n}\\n\\n// Solution 1: Set for existence checks - O(1)\\nSet<Id> accountIdSet = new Set<Id>(accountIds);\\nBoolean exists = accountIdSet.contains(targetId);  // Fast lookup\\n\\n// Solution 2: Map if you need the data too - O(1)\\nMap<Id, Account> accountMap = new Map<Id, Account>([SELECT Id, Name FROM Account]);\\nBoolean exists = accountMap.containsKey(targetId);\\nAccount foundAccount = accountMap.get(targetId);\",\n                keyLearning: \"Performance scales with collection choice. Use the right data structure: List for order, Set for uniqueness, Map for key-value relationships.\",\n                examTip: \"Performance scenarios with large datasets are common interview questions. Always think about time complexity.\"\n            },\n            {\n                number: 6,\n                difficulty: \"beginner\",\n                question: \"Explain when you'd use List vs Set vs Map with real Salesforce scenarios.\",\n                answer: \"List for ordered processing, Set for duplicate prevention, Map for key-based relationships\",\n                explanation: \"Each collection type serves specific business needs in Salesforce. Understanding when to use each prevents performance issues and makes code more maintainable.\",\n                correctCode: \"// List: When order matters and duplicates are OK\\nList<Task> taskHistory = [SELECT Id, Subject FROM Task WHERE AccountId = :accId ORDER BY CreatedDate];\\nfor (Task t : taskHistory) {\\n    // Process in chronological order\\n}\\n\\n// Set: When you need unique values only\\nSet<String> uniqueIndustries = new Set<String>();\\nfor (Account acc : accounts) {\\n    uniqueIndustries.add(acc.Industry);  // Automatically prevents duplicates\\n}\\n\\n// Map: When you need fast lookups or grouping\\nMap<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\nfor (Contact con : contacts) {\\n    if (!contactsByAccount.containsKey(con.AccountId)) {\\n        contactsByAccount.put(con.AccountId, new List<Contact>());\\n    }\\n    contactsByAccount.get(con.AccountId).add(con);\\n}\",\n                keyLearning: \"Collection choice drives performance and functionality. List = order, Set = uniqueness, Map = relationships.\",\n                examTip: \"Scenario-based questions test practical understanding. Think about the business requirement first.\"\n            },\n            {\n                number: 7,\n                difficulty: \"advanced\",\n                question: \"Code review: 'for(Account a : accounts) { for(Contact c : contacts) { if(c.AccountId == a.Id) {...} } }' - what's wrong?\",\n                answer: \"O(n\\xb2) performance problem. Use Map for O(n) solution.\",\n                explanation: \"Nested loops create quadratic time complexity. With 200 accounts and 1000 contacts, this performs 200,000 comparisons instead of the 1,200 needed with proper data structures.\",\n                correctCode: \"// Wrong: O(n\\xb2) - 200 accounts \\xd7 1000 contacts = 200,000 operations\\nfor (Account a : accounts) {\\n    for (Contact c : contacts) {\\n        if (c.AccountId == a.Id) {\\n            // Process - but this is VERY slow\\n        }\\n    }\\n}\\n\\n// Right: O(n) - Group contacts first, then lookup\\nMap<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\nfor (Contact c : contacts) {  // O(n) - 1000 operations\\n    if (!contactsByAccount.containsKey(c.AccountId)) {\\n        contactsByAccount.put(c.AccountId, new List<Contact>());\\n    }\\n    contactsByAccount.get(c.AccountId).add(c);\\n}\\n\\nfor (Account a : accounts) {  // O(n) - 200 operations\\n    List<Contact> accountContacts = contactsByAccount.get(a.Id);\\n    if (accountContacts != null) {\\n        // Process contacts for this account\\n    }\\n}\",\n                keyLearning: \"Avoid nested loops with large datasets. Group data with Maps to convert O(n\\xb2) to O(n) operations.\",\n                examTip: \"Performance anti-patterns are heavily tested. Nested loops = red flag for optimization.\"\n            },\n            {\n                number: 8,\n                difficulty: \"intermediate\",\n                question: \"You need to group Contacts by AccountId efficiently. Walk me through your approach.\",\n                answer: \"Use Map<Id, List<Contact>> to group related records in a single pass\",\n                explanation: \"Grouping is a common pattern in Salesforce. The key is to iterate once and build the grouped structure, avoiding multiple lookups or nested loops.\",\n                correctCode: \"public Map<Id, List<Contact>> groupContactsByAccount(List<Contact> contacts) {\\n    Map<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\n\\n    for (Contact con : contacts) {\\n        // Skip contacts without AccountId\\n        if (con.AccountId == null) continue;\\n\\n        // Initialize list if first contact for this account\\n        if (!contactsByAccount.containsKey(con.AccountId)) {\\n            contactsByAccount.put(con.AccountId, new List<Contact>());\\n        }\\n\\n        // Add contact to the account's list\\n        contactsByAccount.get(con.AccountId).add(con);\\n    }\\n\\n    return contactsByAccount;\\n}\\n\\n// Usage example\\nMap<Id, List<Contact>> grouped = groupContactsByAccount(allContacts);\\nfor (Id accountId : grouped.keySet()) {\\n    List<Contact> accountContacts = grouped.get(accountId);\\n    System.debug('Account ' + accountId + ' has ' + accountContacts.size() + ' contacts');\\n}\",\n                keyLearning: \"Grouping pattern: Map<KeyType, List<ValueType>>. Iterate once, check if key exists, initialize list, add item.\",\n                examTip: \"Grouping questions are common. Master this pattern: it's used everywhere in Salesforce development.\"\n            },\n            {\n                number: 9,\n                difficulty: \"beginner\",\n                question: \"A List might contain nulls and duplicates. Write code to clean it up safely.\",\n                answer: \"Use Set for deduplication and null checks for cleaning\",\n                explanation: \"Real-world data often contains nulls and duplicates. Cleaning collections safely requires handling both issues without causing exceptions.\",\n                correctCode: \"public List<String> cleanStringList(List<String> inputList) {\\n    if (inputList == null || inputList.isEmpty()) {\\n        return new List<String>();\\n    }\\n\\n    Set<String> uniqueValues = new Set<String>();\\n\\n    for (String item : inputList) {\\n        // Skip null and blank values\\n        if (String.isNotBlank(item)) {\\n            // Set automatically handles duplicates\\n            uniqueValues.add(item.trim());\\n        }\\n    }\\n\\n    // Convert back to List if order matters for caller\\n    return new List<String>(uniqueValues);\\n}\\n\\n// Usage\\nList<String> dirtyList = new List<String>{'John', null, 'Jane', 'John', '  ', 'Bob'};\\nList<String> cleanList = cleanStringList(dirtyList);\\n// Result: ['John', 'Jane', 'Bob'] - no nulls, no duplicates, trimmed\",\n                keyLearning: \"Collection cleaning: null checks prevent exceptions, Sets remove duplicates automatically.\",\n                examTip: \"Data validation scenarios are frequent. Always handle null input gracefully.\"\n            },\n            {\n                number: 10,\n                difficulty: \"intermediate\",\n                question: \"You're processing Opportunity data and need fast lookups by Stage. What collection strategy do you use?\",\n                answer: \"Map<String, List<Opportunity>> to group by stage with fast access\",\n                explanation: \"Business reporting often requires grouping records by field values. Maps provide both fast access and logical grouping for analysis.\",\n                correctCode: \"public Map<String, List<Opportunity>> groupOpportunitiesByStage(List<Opportunity> opps) {\\n    Map<String, List<Opportunity>> oppsByStage = new Map<String, List<Opportunity>>();\\n\\n    for (Opportunity opp : opps) {\\n        String stage = opp.StageName ?? 'Unknown';  // Handle null stages\\n\\n        if (!oppsByStage.containsKey(stage)) {\\n            oppsByStage.put(stage, new List<Opportunity>());\\n        }\\n\\n        oppsByStage.get(stage).add(opp);\\n    }\\n\\n    return oppsByStage;\\n}\\n\\n// Business logic usage\\nMap<String, List<Opportunity>> oppsByStage = groupOpportunitiesByStage(opportunities);\\n\\n// Fast analysis\\nList<Opportunity> closedWon = oppsByStage.get('Closed Won');\\nList<Opportunity> negotiation = oppsByStage.get('Negotiation/Review');\\n\\nSystem.debug('Closed Won count: ' + (closedWon?.size() ?? 0));\\nSystem.debug('In Negotiation: ' + (negotiation?.size() ?? 0));\",\n                keyLearning: \"Grouping enables fast business analysis. Map structure mirrors business logic for intuitive access.\",\n                examTip: \"Business scenario questions test practical application. Think about how business users would want to access the data.\"\n            }\n        ]\n    },\n    \"control-flow-and-loops\": {\n        title: \"Control Flow and Loops\",\n        overview: 'Master decision-making in your code. Now that you have Variables (single values) and Collections (multiple values), learn to make DECISIONS about that data. Control flow is where business logic lives - every \"if this then that\" rule in Salesforce. This directly leads to Classes (organizing decision logic) and Triggers (automated decisions).',\n        codeExamples: [\n            {\n                title: \"Decision Making with Business Logic\",\n                code: \"public class ControlFlowDemo {\\n    // ✅ BUILDING ON: Collections from previous topic\\n    public void processLeads(List<Lead> leads) {\\n        // ✅ NEW CONCEPT: Decision making with collected data\\n        List<Lead> hotLeads = new List<Lead>();\\n        List<Lead> coldLeads = new List<Lead>();\\n\\n        // ✅ ENHANCED FOR LOOP: Process each item in collection\\n        for (Lead lead : leads) {\\n            // ✅ CONNECTION: Same for loop pattern you'll use everywhere\\n            // ✅ WHY enhanced for: Safer than index loops, no out-of-bounds\\n\\n            // ✅ CONDITIONAL LOGIC: Business decision making\\n            if (lead.AnnualRevenue != null && lead.AnnualRevenue > 1000000) {\\n                // ✅ NULL SAFETY: Always check null first (from Variables topic)\\n                // ✅ BUSINESS LOGIC: Categorize high-value prospects\\n                hotLeads.add(lead);\\n\\n                // ✅ NESTED CONDITIONS: More complex decision trees\\n                if (lead.Industry == 'Technology') {\\n                    lead.Rating = 'Hot';\\n                    // ✅ CONNECTION: This pattern crucial in Triggers topic\\n                }\\n            } else if (lead.AnnualRevenue != null && lead.AnnualRevenue > 100000) {\\n                // ✅ ELSE IF: Handle multiple conditions efficiently\\n                lead.Rating = 'Warm';\\n            } else {\\n                // ✅ ELSE: Catch-all for remaining cases\\n                coldLeads.add(lead);\\n            }\\n        }\\n\\n        // ✅ CONDITIONAL PROCESSING: Only act if data exists\\n        if (!hotLeads.isEmpty()) {\\n            // \\uD83D\\uDCA1 NEXT TOPIC: You'll organize this logic into Classes\\n            processHotLeads(hotLeads);\\n        }\\n    }\\n\\n    private void processHotLeads(List<Lead> leads) {\\n        for (Lead lead : leads) {\\n            lead.Status = 'Working - Contacted';\\n        }\\n    }\\n}\",\n                explanation: \"Always check for null before comparing values. Use explicit boolean comparisons (== true) for null-safe logic with Boolean fields that can be null.\"\n            },\n            {\n                title: \"Switch Statements and Advanced Patterns\",\n                code: \"public class SwitchPatterns {\\n    // ✅ SWITCH STATEMENT: Clean multiple exact comparisons\\n    public String categorizeBySource(Lead lead) {\\n        // ✅ WHEN TO USE: Multiple exact value comparisons (not ranges)\\n        switch on lead.LeadSource {\\n            when 'Web' {\\n                return 'Digital Marketing';\\n            }\\n            when 'Phone Inquiry', 'Cold Call' {\\n                // ✅ MULTIPLE VALUES: Comma-separated in single case\\n                return 'Direct Sales';\\n            }\\n            when 'Partner Referral' {\\n                return 'Channel Partners';\\n            }\\n            when else {\\n                // ✅ DEFAULT CASE: Handle unmatched values\\n                return 'Unknown Source';\\n            }\\n        }\\n        // \\uD83D\\uDCA1 NEXT TOPIC: This decision logic will be reused in Classes\\n    }\\n\\n    // ✅ EARLY EXIT PATTERNS: Improve performance\\n    public void processOpportunities(List<Opportunity> opps) {\\n        for (Opportunity opp : opps) {\\n            // ✅ GUARD CLAUSE: Early exit for invalid data\\n            if (opp.Amount == null || opp.Amount <= 0) {\\n                continue; // Skip to next iteration\\n            }\\n\\n            // ✅ BUSINESS LOGIC: Only process valid opportunities\\n            if (opp.StageName == 'Closed Won') {\\n                // Process won opportunity\\n                System.debug('Processing won opp: ' + opp.Amount);\\n\\n                // ✅ BREAK: Exit loop if we found what we need\\n                if (opp.Amount > 1000000) {\\n                    System.debug('Found large deal, stopping search');\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n}\",\n                explanation: \"Choose the right loop type: enhanced for when processing all elements, traditional for when you need indexes, while when the iteration count depends on conditions.\"\n            }\n        ],\n        practiceQuestions: [\n            {\n                number: 1,\n                difficulty: \"advanced\",\n                question: \"You see nested for loops processing 1000+ records in a trigger. What's the performance issue and how do you fix it?\",\n                answer: \"O(n\\xb2) complexity causing CPU timeout. Use Maps to flatten to O(n).\",\n                explanation: \"Nested loops create quadratic time complexity. With 1000 records, this means 1,000,000 operations. This quickly hits CPU timeout limits in Salesforce. The solution is to use Maps for grouping data.\",\n                correctCode: \"// Wrong: O(n\\xb2) - 1000 \\xd7 1000 = 1,000,000 operations\\nfor (Account acc : accounts) {\\n    for (Contact con : contacts) {\\n        if (con.AccountId == acc.Id) {\\n            // Process - but VERY slow\\n        }\\n    }\\n}\\n\\n// Right: O(n) - Group first, then process\\nMap<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\nfor (Contact con : contacts) {  // 1000 operations\\n    if (!contactsByAccount.containsKey(con.AccountId)) {\\n        contactsByAccount.put(con.AccountId, new List<Contact>());\\n    }\\n    contactsByAccount.get(con.AccountId).add(con);\\n}\\n\\nfor (Account acc : accounts) {  // 1000 more operations\\n    List<Contact> relatedContacts = contactsByAccount.get(acc.Id);\\n    // Process efficiently\\n}\",\n                keyLearning: \"Nested loops are a performance killer. Always flatten to single loops with Maps for grouping.\",\n                examTip: \"Performance optimization questions are common. Nested loops = immediate red flag for O(n\\xb2) complexity.\"\n            },\n            {\n                number: 2,\n                difficulty: \"intermediate\",\n                question: \"A developer uses `if (lead.Company.startsWith('Acme'))` - what could go wrong and how do you fix it?\",\n                answer: \"NullPointerException if Company is null. Use null-safe navigation.\",\n                explanation: \"Field values in Salesforce can be null. Calling methods directly on potentially null fields throws NullPointerException at runtime. Always check for null first or use safe navigation.\",\n                correctCode: \"// Wrong - throws NPE if Company is null\\nif (lead.Company.startsWith('Acme')) {\\n    // Process\\n}\\n\\n// Option 1: Traditional null check\\nif (lead.Company != null && lead.Company.startsWith('Acme')) {\\n    // Process safely\\n}\\n\\n// Option 2: Safe navigation (modern Apex)\\nif (lead.Company?.startsWith('Acme') == true) {\\n    // Process safely\\n}\\n\\n// Option 3: Null-coalescing for default\\nString company = lead.Company ?? '';\\nif (company.startsWith('Acme')) {\\n    // Process safely\\n}\",\n                keyLearning: \"Always assume Salesforce fields can be null. Use null checks or safe navigation before calling methods.\",\n                examTip: \"Null safety is heavily tested. Look for method calls on fields without null checks.\"\n            },\n            {\n                number: 3,\n                difficulty: \"beginner\",\n                question: \"When would you choose switch over if/else statements?\",\n                answer: \"Switch for multiple exact value comparisons, if/else for ranges or complex conditions\",\n                explanation: \"Switch statements are cleaner and more performant for comparing a single variable against multiple exact values. Use if/else for range comparisons, complex boolean logic, or when you need different variables in each condition.\",\n                correctCode: \"// Good use of switch: exact value matching\\nswitch on lead.Status {\\n    when 'Open - Not Contacted' {\\n        lead.Priority = 'High';\\n    }\\n    when 'Working - Contacted' {\\n        lead.Priority = 'Medium';\\n    }\\n    when 'Closed - Converted', 'Closed - Not Converted' {\\n        lead.Priority = 'Low';\\n    }\\n    when else {\\n        lead.Priority = 'Unknown';\\n    }\\n}\\n\\n// Better with if/else: range comparisons\\nif (lead.AnnualRevenue > 1000000) {\\n    lead.Rating = 'Hot';\\n} else if (lead.AnnualRevenue > 100000) {\\n    lead.Rating = 'Warm';\\n} else {\\n    lead.Rating = 'Cold';\\n}\",\n                keyLearning: \"Switch = exact values, if/else = ranges/complex logic. Choose based on what you're comparing.\",\n                examTip: \"Control structure choice questions test understanding of appropriate usage patterns.\"\n            },\n            {\n                number: 4,\n                difficulty: \"intermediate\",\n                question: \"Explain the difference between `break` and `continue` with examples.\",\n                answer: \"`break` exits the entire loop, `continue` skips to the next iteration\",\n                explanation: \"These control statements change loop execution flow. `break` immediately exits the loop entirely, while `continue` skips the remaining code in the current iteration and moves to the next iteration.\",\n                correctCode: \"List<Account> accounts = [SELECT Id, Name, AnnualRevenue FROM Account];\\n\\n// Using continue - skip invalid records\\nfor (Account acc : accounts) {\\n    if (acc.AnnualRevenue == null) {\\n        continue; // Skip this account, go to next iteration\\n    }\\n\\n    // This code only runs for accounts with revenue\\n    acc.Rating = acc.AnnualRevenue > 1000000 ? 'Hot' : 'Cold';\\n}\\n\\n// Using break - exit when found\\nfor (Account acc : accounts) {\\n    if (acc.Name == 'Target Account') {\\n        System.debug('Found target account');\\n        break; // Exit loop completely, don't process remaining accounts\\n    }\\n\\n    // This code runs until target is found\\n    System.debug('Still searching: ' + acc.Name);\\n}\",\n                keyLearning: \"continue = skip current iteration, break = exit entire loop. Use continue for filtering, break for early termination.\",\n                examTip: \"Loop control questions test understanding of flow modification. Remember: continue skips, break exits.\"\n            },\n            {\n                number: 5,\n                difficulty: \"beginner\",\n                question: \"You need to process only the first 50 records in a list. Show two approaches.\",\n                answer: \"Use LIMIT in SOQL query or traditional for loop with counter\",\n                explanation: \"When you only need a subset of records, it's more efficient to limit at the query level. If you already have the full list, use a traditional for loop with index control.\",\n                correctCode: \"// Approach 1: Limit at query level (BEST)\\nList<Lead> leads = [SELECT Id, Name FROM Lead ORDER BY CreatedDate LIMIT 50];\\nfor (Lead lead : leads) {\\n    // Process all 50 records\\n}\\n\\n// Approach 2: Limit during processing\\nList<Lead> allLeads = [SELECT Id, Name FROM Lead ORDER BY CreatedDate];\\nfor (Integer i = 0; i < Math.min(allLeads.size(), 50); i++) {\\n    Lead lead = allLeads.get(i);\\n    // Process only first 50\\n}\\n\\n// Approach 3: Enhanced for with counter\\nList<Lead> allLeads = [SELECT Id, Name FROM Lead ORDER BY CreatedDate];\\nInteger count = 0;\\nfor (Lead lead : allLeads) {\\n    if (count >= 50) break;\\n\\n    // Process record\\n    count++;\\n}\",\n                keyLearning: \"Always prefer limiting at the database level (SOQL LIMIT) rather than in Apex loops for better performance.\",\n                examTip: \"Query optimization questions favor database-level filtering over Apex-level filtering.\"\n            },\n            {\n                number: 6,\n                difficulty: \"intermediate\",\n                question: \"What's wrong with `if (stringValue == null || stringValue == '') {...}` and how do you improve it?\",\n                answer: \"Verbose and doesn't handle whitespace. Use String.isBlank() for comprehensive checking\",\n                explanation: \"Manual null and empty checking is verbose and error-prone. String.isBlank() handles null, empty string, and whitespace-only strings in one call, making code cleaner and more robust.\",\n                correctCode: \"String stringValue = getValueFromSomewhere();\\n\\n// Verbose and incomplete\\nif (stringValue == null || stringValue == '') {\\n    // Doesn't catch '   ' (whitespace only)\\n}\\n\\n// Better but still verbose\\nif (stringValue == null || stringValue.trim().length() == 0) {\\n    // Handles whitespace but verbose\\n}\\n\\n// Best: comprehensive and concise\\nif (String.isBlank(stringValue)) {\\n    // Handles null, empty, and whitespace-only\\n}\\n\\n// For processing with default\\nString processedValue = String.isBlank(stringValue) ? 'Default' : stringValue.trim();\",\n                keyLearning: \"Use String utility methods (isBlank, isNotBlank, isNotEmpty) instead of manual null/empty checks.\",\n                examTip: \"String validation questions favor utility methods over manual checking. Remember: isBlank includes whitespace.\"\n            },\n            {\n                number: 7,\n                difficulty: \"advanced\",\n                question: \"A loop is causing 'CPU timeout exceeded'. How do you optimize it?\",\n                answer: \"Move to asynchronous processing, reduce complexity, or use database operations instead of loops\",\n                explanation: \"CPU timeouts occur when synchronous Apex runs too long (10 seconds). Solutions include moving heavy processing to async context, optimizing algorithms, or replacing Apex loops with database operations.\",\n                correctCode: \"// Problem: Heavy processing in sync context\\npublic void processLargeDataset(List<Account> accounts) {\\n    for (Account acc : accounts) {\\n        // Complex calculations causing timeout\\n        for (Contact con : [SELECT Id FROM Contact WHERE AccountId = :acc.Id]) {\\n            // Nested query + processing = CPU killer\\n        }\\n    }\\n}\\n\\n// Solution 1: Move to async\\n@future\\npublic static void processLargeDatasetAsync(List<Id> accountIds) {\\n    // 60 second limit instead of 10 seconds\\n    List<Account> accounts = [SELECT Id FROM Account WHERE Id IN :accountIds];\\n    // Process with higher limits\\n}\\n\\n// Solution 2: Bulkify queries\\npublic void processLargeDatasetBulk(List<Account> accounts) {\\n    Set<Id> accountIds = new Set<Id>();\\n    for (Account acc : accounts) {\\n        accountIds.add(acc.Id);\\n    }\\n\\n    // Single query instead of loop queries\\n    Map<Id, List<Contact>> contactsByAccount = new Map<Id, List<Contact>>();\\n    for (Contact con : [SELECT Id, AccountId FROM Contact WHERE AccountId IN :accountIds]) {\\n        // Group efficiently\\n    }\\n}\",\n                keyLearning: \"CPU timeouts require architectural changes: async processing, query bulkification, or database operations.\",\n                examTip: \"Governor limit scenarios test understanding of Salesforce platform constraints and optimization strategies.\"\n            },\n            {\n                number: 8,\n                difficulty: \"beginner\",\n                question: \"You're processing Account records and need to skip inactive ones. Best approach?\",\n                answer: \"Use continue statement to skip inactive accounts in the loop\",\n                explanation: \"When you need to skip certain records during processing, the continue statement provides clean, readable code that moves to the next iteration without deeply nesting the main logic.\",\n                correctCode: \"public void processAccounts(List<Account> accounts) {\\n    for (Account acc : accounts) {\\n        // Guard clause: skip inactive accounts\\n        if (acc.Active__c != true) {\\n            continue; // Skip to next account\\n        }\\n\\n        // Main processing logic only runs for active accounts\\n        if (acc.AnnualRevenue > 1000000) {\\n            acc.Rating = 'Hot';\\n        }\\n\\n        acc.LastProcessed__c = System.now();\\n        System.debug('Processed active account: ' + acc.Name);\\n    }\\n}\\n\\n// Alternative: filter in query (even better)\\nList<Account> activeAccounts = [SELECT Id, Name, AnnualRevenue FROM Account WHERE Active__c = true];\\nfor (Account acc : activeAccounts) {\\n    // All accounts are already active\\n}\",\n                keyLearning: \"Use continue for clean guard clauses, but prefer filtering in SOQL queries when possible.\",\n                examTip: \"Early exit patterns improve code readability. Guard clauses with continue are preferred over deep nesting.\"\n            },\n            {\n                number: 9,\n                difficulty: \"intermediate\",\n                question: \"Explain when enhanced for loops are preferred over traditional for loops.\",\n                answer: \"Enhanced for when processing all elements, traditional for when you need index or skip elements\",\n                explanation: \"Enhanced for loops are safer (no index bounds issues) and cleaner for processing all elements. Traditional for loops give you index control for partial processing or when you need element position.\",\n                correctCode: \"List<Contact> contacts = [SELECT Id, Name, Email FROM Contact];\\n\\n// Enhanced for: Process all elements (PREFERRED)\\nfor (Contact con : contacts) {\\n    // Clean, safe, no index management\\n    if (String.isNotBlank(con.Email)) {\\n        sendEmail(con.Email);\\n    }\\n}\\n\\n// Traditional for: When you need the index\\nfor (Integer i = 0; i < contacts.size(); i++) {\\n    Contact con = contacts.get(i);\\n    System.debug('Processing contact #' + (i + 1) + ': ' + con.Name);\\n}\\n\\n// Traditional for: Process only first half\\nfor (Integer i = 0; i < contacts.size() / 2; i++) {\\n    Contact con = contacts.get(i);\\n    // Process subset\\n}\\n\\n// Traditional for: Skip every other element\\nfor (Integer i = 0; i < contacts.size(); i += 2) {\\n    Contact con = contacts.get(i);\\n    // Process every other contact\\n}\",\n                keyLearning: \"Enhanced for = all elements safely. Traditional for = index control and partial processing.\",\n                examTip: \"Loop choice questions test understanding of when index access is necessary vs. simple iteration.\"\n            },\n            {\n                number: 10,\n                difficulty: \"advanced\",\n                question: \"A business rule has 8 different conditions. How do you structure this cleanly?\",\n                answer: \"Use early returns, switch statements, or strategy pattern to avoid deep nesting\",\n                explanation: \"Multiple conditions can create deeply nested, hard-to-read code. Clean approaches include guard clauses with early returns, switch statements for exact matches, or organizing into separate methods.\",\n                correctCode: \"// Problem: Deep nesting with many conditions\\npublic String categorizeOpportunity(Opportunity opp) {\\n    if (opp.Amount != null) {\\n        if (opp.Amount > 1000000) {\\n            if (opp.Probability > 80) {\\n                if (opp.Type == 'New Customer') {\\n                    // Deep nesting continues...\\n                }\\n            }\\n        }\\n    }\\n    return 'Unknown';\\n}\\n\\n// Solution 1: Early returns (guard clauses)\\npublic String categorizeOpportunityClean(Opportunity opp) {\\n    // Handle invalid cases early\\n    if (opp.Amount == null) return 'No Amount';\\n    if (opp.Probability == null) return 'No Probability';\\n\\n    // Large deals\\n    if (opp.Amount > 1000000) {\\n        if (opp.Probability > 80) return 'Large Sure Deal';\\n        if (opp.Probability > 50) return 'Large Likely Deal';\\n        return 'Large Risky Deal';\\n    }\\n\\n    // Medium deals\\n    if (opp.Amount > 100000) {\\n        return opp.Probability > 70 ? 'Medium Sure Deal' : 'Medium Deal';\\n    }\\n\\n    return 'Small Deal';\\n}\\n\\n// Solution 2: Switch for exact matching\\npublic String categorizeByStage(Opportunity opp) {\\n    switch on opp.StageName {\\n        when 'Prospecting', 'Qualification' { return 'Early Stage'; }\\n        when 'Needs Analysis', 'Value Proposition' { return 'Mid Stage'; }\\n        when 'Id. Decision Makers', 'Perception Analysis' { return 'Late Stage'; }\\n        when 'Proposal/Price Quote', 'Negotiation/Review' { return 'Final Stage'; }\\n        when 'Closed Won' { return 'Won'; }\\n        when 'Closed Lost' { return 'Lost'; }\\n        when else { return 'Unknown Stage'; }\\n    }\\n}\",\n                keyLearning: \"Complex conditions need clean structure: early returns, switch statements, or separate methods to avoid nesting.\",\n                examTip: \"Code quality questions test ability to write maintainable logic. Deep nesting is an anti-pattern.\"\n            }\n        ]\n    },\n    \"classes-and-objects\": {\n        title: \"Classes and Objects\",\n        overview: \"Master object-oriented programming in Apex. Your control flow logic needs organization and reusability - Classes are containers for related functionality. Understanding classes is crucial because 30% of Salesforce development involves creating and using custom classes. This knowledge directly enables SOQL operations (organized data access) and Triggers (organized automation).\",\n        codeExamples: [\n            {\n                title: \"Class Structure\",\n                code: \"public class CustomerManager {\\n    // ✅ BUILDING ON: Control flow logic needs organization and reusability\\n    // ✅ NEW CONCEPT: Classes are containers for related functionality\\n\\n    // ✅ INSTANCE VARIABLES: Data that belongs to each object\\n    private String managerName;\\n    private Integer customersProcessed;\\n    private List<String> processedCustomerIds;\\n    // ✅ WHY private: Encapsulation - controlled access only\\n    // ✅ CONNECTION: Same variable principles from Variables topic\\n    // \\uD83D\\uDCA1 NEXT TOPIC: SOQL will populate these with real data\\n\\n    // ✅ STATIC VARIABLES: Shared across ALL objects of this class\\n    private static Integer totalCustomersProcessed = 0;\\n    // ✅ WHAT: One copy shared by all CustomerManager objects\\n    // ✅ WHY: Track global statistics across all instances\\n\\n    // ✅ CONSTANTS: Values that never change\\n    public static final Integer MAX_CUSTOMERS_PER_BATCH = 200;\\n    // ✅ WHY 200: Salesforce governor limits for bulk processing\\n\\n    // ✅ CONSTRUCTOR: Initialize object when created\\n    public CustomerManager(String name) {\\n        // ✅ WHAT: Runs automatically when object created with 'new'\\n        // ✅ WHY: Ensures object starts in valid state\\n        this.managerName = name;\\n        this.customersProcessed = 0;\\n        this.processedCustomerIds = new List<String>();\\n        // ✅ CONNECTION: List initialization from Collections topic\\n        // \\uD83D\\uDC80 EXAM TRAP: Forgetting to initialize collections = null errors\\n    }\\n\\n    // ✅ INSTANCE METHOD: Operates on specific object's data\\n    public void processCustomer(Account customer) {\\n        // ✅ VALIDATION: Same patterns from Control Flow topic\\n        if (customer == null || String.isBlank(customer.Name)) {\\n            System.debug('Invalid customer data provided');\\n            return; // Early exit pattern\\n        }\\n\\n        // ✅ BUSINESS LOGIC: Apply processing rules\\n        if (customer.AnnualRevenue != null && customer.AnnualRevenue > 100000) {\\n            customer.CustomerPriority__c = 'High';\\n            // ✅ CONNECTION: Conditional logic from Control Flow topic\\n        }\\n\\n        // ✅ STATE TRACKING: Update object's internal data\\n        this.customersProcessed++;\\n        this.processedCustomerIds.add(customer.Id);\\n        totalCustomersProcessed++; // Static variable\\n\\n        System.debug(this.managerName + ' processed: ' + customer.Name);\\n        // \\uD83D\\uDCA1 NEXT TOPIC: SOQL will provide customer data efficiently\\n    }\\n\\n    // ✅ STATIC METHOD: Utility function, no object needed\\n    public static Boolean isHighValueCustomer(Account customer) {\\n        // ✅ WHEN TO USE: Pure function that doesn't need object state\\n        // ✅ REUSABILITY: Can be called from anywhere\\n        if (customer?.AnnualRevenue == null) {\\n            return false;\\n        }\\n        return customer.AnnualRevenue > 500000;\\n        // ✅ CONNECTION: Null safety from Variables topic\\n    }\\n\\n    // ✅ GETTER METHOD: Controlled access to private data\\n    public Integer getCustomersProcessed() {\\n        return this.customersProcessed;\\n        // ✅ ENCAPSULATION: Read-only access to internal state\\n    }\\n}\\n\\n// ✅ USAGE EXAMPLE: How classes work together\\npublic class BusinessLogicExample {\\n    public void demonstrateClassUsage() {\\n        // ✅ OBJECT CREATION: Constructor runs automatically\\n        CustomerManager salesManager = new CustomerManager('John Smith');\\n        CustomerManager supportManager = new CustomerManager('Jane Doe');\\n        // ✅ MULTIPLE OBJECTS: Each has its own state\\n\\n        // ✅ STATIC METHOD: Called on class, not object\\n        List<Account> accounts = [SELECT Id, Name, AnnualRevenue FROM Account LIMIT 10];\\n\\n        for (Account acc : accounts) {\\n            // ✅ DECISION LOGIC: From Control Flow topic\\n            if (CustomerManager.isHighValueCustomer(acc)) {\\n                salesManager.processCustomer(acc);\\n                // ✅ INSTANCE METHOD: Called on specific object\\n            }\\n        }\\n\\n        System.debug('Sales processed: ' + salesManager.getCustomersProcessed());\\n        // \\uD83D\\uDCA1 NEXT TOPIC: SOQL will get data more efficiently\\n    }\\n}\",\n                explanation: \"Classes encapsulate related data and behavior. Use instance variables for object state, constructors for initialization, instance methods for object operations, and static methods for utilities.\"\n            }\n        ],\n        practiceQuestions: [\n            {\n                number: 1,\n                difficulty: \"beginner\",\n                question: \"What's the difference between a class and an object in Apex?\",\n                answer: \"A class is a blueprint/template, an object is an instance created from that class\",\n                explanation: \"A class defines the structure (variables and methods) but doesn't exist in memory. An object is a specific instance of that class that actually holds data and can execute methods.\",\n                correctCode: \"public class Account {\\n    public String name;  // Class defines structure\\n    public void display() { System.debug(name); }\\n}\\n\\n// Object creation from class\\nAccount myAccount = new Account();  // Create object instance\\nmyAccount.name = 'Acme Corp';       // Set data in object\\nmyAccount.display();                // Call method on object\",\n                keyLearning: \"Class = blueprint, Object = actual instance. You need to instantiate a class with 'new' to create an object.\",\n                examTip: \"PD1 frequently tests understanding of classes vs objects. Remember: classes define, objects execute.\"\n            }\n        ]\n    },\n    \"soql-and-dml\": {\n        title: \"SOQL and DML\",\n        overview: \"Master Salesforce Object Query Language and database operations. SOQL retrieves records from Salesforce, DML operations modify them.\",\n        codeExamples: [\n            {\n                title: \"Basic SOQL Queries\",\n                code: \"public class QueryDemo {\\n    public void basicQueries() {\\n        // ✅ WHAT: Basic SELECT with specific fields\\n        List<Account> accounts = [\\n            SELECT Id, Name, Type, Industry\\n            FROM Account\\n            WHERE Type = 'Customer'\\n            LIMIT 100\\n        ];\\n\\n        // ✅ WHAT: Query with relationships (lookup)\\n        List<Contact> contacts = [\\n            SELECT Id, Name, Email,\\n                   Account.Name, Account.Industry\\n            FROM Contact\\n            WHERE Account.Type = 'Customer'\\n        ];\\n\\n        // ✅ WHAT: Query with child relationships\\n        List<Account> accountsWithContacts = [\\n            SELECT Id, Name,\\n                   (SELECT Id, Name, Email FROM Contacts)\\n            FROM Account\\n            WHERE Id IN :accountIds\\n        ];\\n    }\\n}\",\n                explanation: \"SOQL syntax is similar to SQL but with Salesforce-specific features like relationship queries. Always specify needed fields explicitly and use LIMIT to prevent governor limit issues.\"\n            }\n        ],\n        practiceQuestions: []\n    },\n    \"triggers-and-automation\": {\n        title: \"Triggers and Automation\",\n        overview: \"Master Apex triggers and automation patterns. Triggers execute automatically when records are inserted, updated, or deleted.\",\n        codeExamples: [\n            {\n                title: \"Trigger Structure\",\n                code: \"trigger AccountTrigger on Account (before insert, before update, after insert, after update) {\\n    // ✅ WHAT: Single trigger handles multiple events\\n    // ✅ WHY: Better organization and predictable execution order\\n\\n    if (Trigger.isBefore) {\\n        if (Trigger.isInsert || Trigger.isUpdate) {\\n            AccountTriggerHandler.validateAccounts(Trigger.new);\\n        }\\n    }\\n\\n    if (Trigger.isAfter) {\\n        if (Trigger.isInsert) {\\n            AccountTriggerHandler.createDefaultContacts(Trigger.new);\\n        }\\n\\n        if (Trigger.isUpdate) {\\n            AccountTriggerHandler.updateRelatedOpportunities(\\n                Trigger.new,\\n                Trigger.oldMap\\n            );\\n        }\\n    }\\n}\",\n                explanation: \"Use a single trigger per object with multiple events. Delegate logic to handler classes for better organization and testability.\"\n            }\n        ],\n        practiceQuestions: []\n    },\n    \"asynchronous-apex\": {\n        title: \"Asynchronous Apex\",\n        overview: \"Master asynchronous processing with Future, Batch, Queueable, and Schedulable Apex for handling large data volumes.\",\n        codeExamples: [\n            {\n                title: \"Future Methods\",\n                code: \"public class AsyncDemo {\\n    // ✅ WHAT: Future method for async processing\\n    @future\\n    public static void processAccountsAsync(Set<Id> accountIds) {\\n        // ✅ WHAT: Query records in the async method\\n        List<Account> accounts = [\\n            SELECT Id, Name, Industry\\n            FROM Account\\n            WHERE Id IN :accountIds\\n        ];\\n\\n        for (Account acc : accounts) {\\n            // Long-running processing\\n            acc.Description = 'Processed async on ' + System.now();\\n        }\\n\\n        update accounts;\\n    }\\n}\",\n                explanation: \"Future methods run asynchronously and must be static. They can only accept primitive types and collections of primitives as parameters.\"\n            }\n        ],\n        practiceQuestions: []\n    },\n    \"testing-and-debugging\": {\n        title: \"Testing and Debugging\",\n        overview: \"Master unit testing, test data creation, and test automation in Apex. Proper testing ensures code quality and prevents regressions.\",\n        codeExamples: [\n            {\n                title: \"Basic Test Structure\",\n                code: \"@IsTest\\npublic class AccountProcessorTest {\\n\\n    @TestSetup\\n    static void createTestData() {\\n        // ✅ WHAT: Test data created once for all test methods\\n        List<Account> testAccounts = new List<Account>();\\n        for (Integer i = 0; i < 10; i++) {\\n            testAccounts.add(new Account(\\n                Name = 'Test Account ' + i,\\n                Type = 'Customer',\\n                Industry = 'Technology'\\n            ));\\n        }\\n        insert testAccounts;\\n    }\\n\\n    @IsTest\\n    static void testAccountProcessing() {\\n        // ✅ WHAT: Query test data\\n        List<Account> accounts = [SELECT Id, Name FROM Account];\\n\\n        Test.startTest();\\n        // ✅ WHAT: Execute code under test\\n        AccountProcessor processor = new AccountProcessor('Test Processor', 20);\\n        processor.processAccounts(accounts);\\n        Test.stopTest();\\n\\n        // ✅ WHAT: Verify results\\n        List<Account> processedAccounts = [\\n            SELECT Id, Last_Processed_Date__c\\n            FROM Account\\n        ];\\n\\n        for (Account acc : processedAccounts) {\\n            System.assertNotEquals(null, acc.Last_Processed_Date__c,\\n                'Account should have processing date');\\n        }\\n    }\\n}\",\n                explanation: \"Use @TestSetup for common test data, Test.startTest()/stopTest() to reset governor limits, and System.assert methods to verify results.\"\n            }\n        ],\n        practiceQuestions: []\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kYXRhL3RvcGljQ29udGVudC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBeUJPLE1BQU1BLGVBQTZDO0lBQ3hELDRCQUE0QjtRQUMxQkMsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkFvQlBDLGFBQWE7WUFDZjtZQUNBO2dCQUNFSixPQUFPO2dCQUNQRyxNQUFPO2dCQWtCUEMsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VKLE9BQU87Z0JBQ1BHLE1BQU87Z0JBcUJQQyxhQUFhO1lBQ2Y7U0FDRDtRQUNEQyxtQkFBbUI7WUFDakI7Z0JBQ0VDLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZMLE1BQU87Z0JBRVBNLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBRWRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQUVkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFNZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBQ2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQUdkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFHZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBU2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQU9kQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFRZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBUWRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQVlkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFvQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQWVkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFjZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBeUJkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFrQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXNCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBaUJkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkEwQ2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXdDZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1NBQ0Q7SUFDSDtJQUVBLHlCQUF5QjtRQUN2QlosT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkE4QlBDLGFBQWE7WUFDZjtZQUNBO2dCQUNFSixPQUFPO2dCQUNQRyxNQUFPO2dCQW1CUEMsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VKLE9BQU87Z0JBQ1BHLE1BQU87Z0JBcUJQQyxhQUFhO1lBQ2Y7U0FDRDtRQUNEQyxtQkFBbUI7WUFDakI7Z0JBQ0VDLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBRWRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQU1kQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkwsTUFBTztnQkFJUE0sUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFLZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBU2RDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQWVkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFvQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXdCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBeUJkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkF1QmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXlCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1NBQ0Q7SUFDSDtJQUVBLDBCQUEwQjtRQUN4QlosT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkE2Q1BDLGFBQWE7WUFDZjtZQUNBO2dCQUNFSixPQUFPO2dCQUNQRyxNQUFPO2dCQTZDUEMsYUFBYTtZQUNmO1NBQ0Q7UUFDREMsbUJBQW1CO1lBQ2pCO2dCQUNFQyxRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXNCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBb0JkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkF3QmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQXNCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBc0JkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFtQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQStCZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1lBQ0E7Z0JBQ0VOLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JMLGFBQWE7Z0JBQ2JNLGFBQWM7Z0JBc0JkQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFDQTtnQkFDRU4sUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkEyQmRDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtZQUNBO2dCQUNFTixRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSTCxhQUFhO2dCQUNiTSxhQUFjO2dCQStDZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1NBQ0Q7SUFDSDtJQUVBLHVCQUF1QjtRQUNyQlosT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkFnR1BDLGFBQWE7WUFDZjtTQUNEO1FBQ0RDLG1CQUFtQjtZQUNqQjtnQkFDRUMsUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkwsYUFBYTtnQkFDYk0sYUFBYztnQkFTZEMsYUFBYTtnQkFDYkMsU0FBUztZQUNYO1NBRUQ7SUFDSDtJQUVBLGdCQUFnQjtRQUNkWixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsY0FBYztZQUNaO2dCQUNFRixPQUFPO2dCQUNQRyxNQUFPO2dCQTJCUEMsYUFBYTtZQUNmO1NBQ0Q7UUFDREMsbUJBQW1CLEVBRWxCO0lBQ0g7SUFFQSwyQkFBMkI7UUFDekJMLE9BQU87UUFDUEMsVUFBVTtRQUNWQyxjQUFjO1lBQ1o7Z0JBQ0VGLE9BQU87Z0JBQ1BHLE1BQU87Z0JBdUJQQyxhQUFhO1lBQ2Y7U0FDRDtRQUNEQyxtQkFBbUIsRUFFbEI7SUFDSDtJQUVBLHFCQUFxQjtRQUNuQkwsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLGNBQWM7WUFDWjtnQkFDRUYsT0FBTztnQkFDUEcsTUFBTztnQkFtQlBDLGFBQWE7WUFDZjtTQUNEO1FBQ0RDLG1CQUFtQixFQUVsQjtJQUNIO0lBRUEseUJBQXlCO1FBQ3ZCTCxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsY0FBYztZQUNaO2dCQUNFRixPQUFPO2dCQUNQRyxNQUFPO2dCQXdDUEMsYUFBYTtZQUNmO1NBQ0Q7UUFDREMsbUJBQW1CLEVBRWxCO0lBQ0g7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9kYXRhL3RvcGljQ29udGVudC50cz8wOTlkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgQ29kZUV4YW1wbGUge1xuICB0aXRsZTogc3RyaW5nO1xuICBjb2RlOiBzdHJpbmc7XG4gIGV4cGxhbmF0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJhY3RpY2VRdWVzdGlvbiB7XG4gIG51bWJlcjogbnVtYmVyO1xuICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInIHwgJ2ludGVybWVkaWF0ZScgfCAnYWR2YW5jZWQnO1xuICBxdWVzdGlvbjogc3RyaW5nO1xuICBjb2RlPzogc3RyaW5nO1xuICBhbnN3ZXI6IHN0cmluZztcbiAgZXhwbGFuYXRpb246IHN0cmluZztcbiAgY29ycmVjdENvZGU/OiBzdHJpbmc7XG4gIGtleUxlYXJuaW5nOiBzdHJpbmc7XG4gIGV4YW1UaXA6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb3BpY0NvbnRlbnQge1xuICB0aXRsZTogc3RyaW5nO1xuICBvdmVydmlldzogc3RyaW5nO1xuICBjb2RlRXhhbXBsZXM6IENvZGVFeGFtcGxlW107XG4gIHByYWN0aWNlUXVlc3Rpb25zOiBQcmFjdGljZVF1ZXN0aW9uW107XG59XG5cbmV4cG9ydCBjb25zdCB0b3BpY0NvbnRlbnQ6IFJlY29yZDxzdHJpbmcsIFRvcGljQ29udGVudD4gPSB7XG4gICd2YXJpYWJsZXMtYW5kLWRhdGEtdHlwZXMnOiB7XG4gICAgdGl0bGU6ICdWYXJpYWJsZXMgYW5kIERhdGEgVHlwZXMnLFxuICAgIG92ZXJ2aWV3OiAnTWFzdGVyIEFwZXggdmFyaWFibGVzLCBwcmltaXRpdmUgZGF0YSB0eXBlcywgYW5kIHR5cGUgY29udmVyc2lvbi4gVmFyaWFibGVzIGFyZSB0aGUgZm91bmRhdGlvbiBvZiBldmVyeSBBcGV4IHByb2dyYW0gLSB0aGV5IHN0b3JlIGluZm9ybWF0aW9uIHlvdXIgY29kZSBuZWVkcy4gVW5kZXJzdGFuZGluZyB2YXJpYWJsZXMgaXMgY3J1Y2lhbCBiZWNhdXNlIEVWRVJZVEhJTkcgaW4gU2FsZXNmb3JjZSBkZXZlbG9wbWVudCBidWlsZHMgb24gdGhpczogZnJvbSBzaW1wbGUgZmllbGQgdXBkYXRlcyB0byBjb21wbGV4IGJ1c2luZXNzIGxvZ2ljLiBUaGlzIHRvcGljIHNldHMgdGhlIHN0YWdlIGZvciBDb2xsZWN0aW9ucyAobXVsdGlwbGUgdmFsdWVzKSwgQ29udHJvbCBGbG93IChkZWNpc2lvbnMgYWJvdXQgdmFsdWVzKSwgYW5kIGJleW9uZC4nLFxuICAgIGNvZGVFeGFtcGxlczogW1xuICAgICAge1xuICAgICAgICB0aXRsZTogJ0Jhc2ljIFZhcmlhYmxlIERlY2xhcmF0aW9uJyxcbiAgICAgICAgY29kZTogYHB1YmxpYyBjbGFzcyBWYXJpYWJsZUV4YW1wbGUge1xuICAgIC8vIOKchSBXSEFUOiBDbGFzcyBkZWNsYXJhdGlvbiB3aXRoIHB1YmxpYyBhY2Nlc3NcbiAgICAvLyDwn5KAIEVYQU0gVFJBUDogQ2xhc3MgbmFtZSBtdXN0IG1hdGNoIGZpbGVuYW1lIGV4YWN0bHlcblxuICAgIHByaXZhdGUgU3RyaW5nIGN1c3RvbWVyTmFtZTtcbiAgICAvLyDinIUgV0hBVDogSW5zdGFuY2UgdmFyaWFibGUgZm9yIHN0b3JpbmcgdGV4dFxuICAgIC8vIOKchSBXSFk6IHByaXZhdGUgPSBjb250cm9sbGVkIGFjY2VzcyAoZW5jYXBzdWxhdGlvbilcbiAgICAvLyDwn5KAIENPTU1PTiBNSVNUQUtFOiBWYXJpYWJsZXMgZGVmYXVsdCB0byBudWxsIChub3QgZW1wdHkpXG5cbiAgICBwcml2YXRlIEludGVnZXIgYWdlID0gMDtcbiAgICAvLyDinIUgV0hBVDogV2hvbGUgbnVtYmVyIHdpdGggc2FmZSBpbml0aWFsaXphdGlvblxuICAgIC8vIOKchSBXSFk6IFByZXZlbnRzIG51bGwgcG9pbnRlciBleGNlcHRpb25zXG4gICAgLy8g8J+SgCBFWEFNIFRSQVA6IFVzZSBJbnRlZ2VyIChub3QgaW50KSBpbiBBcGV4XG5cbiAgICBwdWJsaWMgVmFyaWFibGVFeGFtcGxlKFN0cmluZyBuYW1lKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tZXJOYW1lID0gbmFtZTtcbiAgICAgICAgLy8g4pyFIFdIQVQ6IHRoaXMgPSBjdXJyZW50IG9iamVjdCByZWZlcmVuY2VcbiAgICAgICAgLy8g4pyFIFdIWTogRGlzdGluZ3Vpc2hlcyBwYXJhbWV0ZXIgZnJvbSBmaWVsZFxuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0FwZXggdXNlcyB3cmFwcGVyIHR5cGVzIChJbnRlZ2VyLCBCb29sZWFuLCBTdHJpbmcpIGluc3RlYWQgb2YgSmF2YSBwcmltaXRpdmVzLiBBbGwgdmFyaWFibGVzIGNhbiBiZSBudWxsIGFuZCBoYXZlIG1ldGhvZHMuIEFsd2F5cyBpbml0aWFsaXplIHZhcmlhYmxlcyBvciBjaGVjayBmb3IgbnVsbCBiZWZvcmUgdXNpbmcgdGhlbS4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogJ1N0cmluZyBPcGVyYXRpb25zJyxcbiAgICAgICAgY29kZTogYHB1YmxpYyBjbGFzcyBTdHJpbmdEZW1vIHtcbiAgICBwdWJsaWMgdm9pZCBwcm9jZXNzTmFtZXMoKSB7XG4gICAgICAgIFN0cmluZyBmaXJzdE5hbWUgPSAnSm9obic7XG4gICAgICAgIC8vIPCfkoAgRVhBTSBUUkFQOiBTaW5nbGUgcXVvdGVzIChub3QgZG91YmxlKSBpbiBBcGV4XG5cbiAgICAgICAgU3RyaW5nIGxhc3ROYW1lID0gJ0RvZSc7XG4gICAgICAgIFN0cmluZyBmdWxsTmFtZSA9IGZpcnN0TmFtZSArICcgJyArIGxhc3ROYW1lO1xuICAgICAgICAvLyDinIUgUkVTVUxUOiAnSm9obiBEb2UnXG5cbiAgICAgICAgQm9vbGVhbiBoYXNDb250ZW50ID0gU3RyaW5nLmlzTm90QmxhbmsoZnVsbE5hbWUpO1xuICAgICAgICAvLyDinIUgU0FGRTogQ2hlY2tzIG51bGwgQU5EIGVtcHR5IEFORCB3aGl0ZXNwYWNlXG4gICAgICAgIC8vIOKchSBCRVRURVIgVEhBTjogZnVsbE5hbWUgIT0gbnVsbCAmJiBmdWxsTmFtZS5sZW5ndGgoKSA+IDBcblxuICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdOYW1lOiAnICsgZnVsbE5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG59YCxcbiAgICAgICAgZXhwbGFuYXRpb246ICdTdHJpbmcgb3BlcmF0aW9ucyBpbiBBcGV4IGFyZSBudWxsLXNhZmUgd2hlbiB1c2luZyBidWlsdC1pbiBtZXRob2RzIGxpa2UgaXNOb3RCbGFuaygpLiBBbHdheXMgdXNlIHRoZXNlIGluc3RlYWQgb2YgbWFudWFsIG51bGwgY2hlY2tzIGZvciByb2J1c3QgY29kZS4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogJ1R5cGUgQ29udmVyc2lvbicsXG4gICAgICAgIGNvZGU6IGBwdWJsaWMgY2xhc3MgQ29udmVyc2lvbkRlbW8ge1xuICAgIHB1YmxpYyB2b2lkIHNhZmVDb252ZXJzaW9uKCkge1xuICAgICAgICBTdHJpbmcgbnVtYmVyU3RyID0gJzEyMyc7XG4gICAgICAgIEludGVnZXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIOKchSBTQUZFOiBDaGVjayBiZWZvcmUgY29udmVydGluZ1xuICAgICAgICBpZiAobnVtYmVyU3RyLmlzTnVtZXJpYygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBJbnRlZ2VyLnZhbHVlT2YobnVtYmVyU3RyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IDA7IC8vIERlZmF1bHQgZmFsbGJhY2tcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOKchSBTQUZFOiBUcnktY2F0Y2ggZm9yIGNvbXBsZXggY29udmVyc2lvbnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIERlY2ltYWwgcHJpY2UgPSBEZWNpbWFsLnZhbHVlT2YoJzE5Ljk5Jyk7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ1ByaWNlOiAnICsgcHJpY2UpO1xuICAgICAgICB9IGNhdGNoIChUeXBlRXhjZXB0aW9uIGUpIHtcbiAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnSW52YWxpZCBudW1iZXIgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICB9XG59YCxcbiAgICAgICAgZXhwbGFuYXRpb246ICdBbHdheXMgdmFsaWRhdGUgaW5wdXQgYmVmb3JlIHR5cGUgY29udmVyc2lvbi4gVXNlIGlzTnVtZXJpYygpIGZvciBiYXNpYyBjaGVja3MgYW5kIHRyeS1jYXRjaCBmb3IgY29tcGxleCBzY2VuYXJpb3MuIFR5cGVFeGNlcHRpb24gaXMgdGhyb3duIGZvciBpbnZhbGlkIGNvbnZlcnNpb25zLidcbiAgICAgIH1cbiAgICBdLFxuICAgIHByYWN0aWNlUXVlc3Rpb25zOiBbXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCBpcyB3cm9uZyB3aXRoIHRoaXMgY29kZT9cIixcbiAgICAgICAgY29kZTogYFN0cmluZyBuYW1lO1xuSW50ZWdlciBsZW5ndGggPSBuYW1lLmxlbmd0aCgpO2AsXG4gICAgICAgIGFuc3dlcjogXCJOdWxsUG9pbnRlckV4Y2VwdGlvbiB3aWxsIGJlIHRocm93blwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJUaGUgdmFyaWFibGUgJ25hbWUnIGlzIGRlY2xhcmVkIGJ1dCBub3QgaW5pdGlhbGl6ZWQsIHNvIGl0IGRlZmF1bHRzIHRvIG51bGwuIENhbGxpbmcgLmxlbmd0aCgpIG9uIGEgbnVsbCBTdHJpbmcgdGhyb3dzIGEgTnVsbFBvaW50ZXJFeGNlcHRpb24gYXQgcnVudGltZS5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBTdHJpbmcgbmFtZSA9ICdKb2huJzsgIC8vIEluaXRpYWxpemUgdGhlIHZhcmlhYmxlXG5JbnRlZ2VyIGxlbmd0aCA9IG5hbWUubGVuZ3RoKCk7ICAvLyBOb3cgc2FmZSB0byBjYWxsYCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQWx3YXlzIGluaXRpYWxpemUgdmFyaWFibGVzIG9yIGNoZWNrIGZvciBudWxsIGJlZm9yZSB1c2luZyB0aGVtLiBVbmluaXRpYWxpemVkIHJlZmVyZW5jZSB2YXJpYWJsZXMgZGVmYXVsdCB0byBudWxsLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlRoaXMgaXMgYSB2ZXJ5IGNvbW1vbiBQRDEgY2VydGlmaWNhdGlvbiBxdWVzdGlvbiBwYXR0ZXJuLiBBbHdheXMgbG9vayBmb3IgdW5pbml0aWFsaXplZCB2YXJpYWJsZXMgaW4gY29kZSBzYW1wbGVzLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoaWNoIGRhdGEgdHlwZSBzaG91bGQgeW91IHVzZSBmb3Igc3RvcmluZyBjdXJyZW5jeSB2YWx1ZXMgaW4gU2FsZXNmb3JjZT9cIixcbiAgICAgICAgYW5zd2VyOiBcIkRlY2ltYWxcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiRGVjaW1hbCBpcyB0aGUgYmVzdCBjaG9pY2UgZm9yIGN1cnJlbmN5IGJlY2F1c2UgaXQgcHJvdmlkZXMgZXhhY3QgcHJlY2lzaW9uIHdpdGhvdXQgZmxvYXRpbmctcG9pbnQgcm91bmRpbmcgZXJyb3JzLiBEb3VibGUvRmxvYXQgY2FuIGludHJvZHVjZSByb3VuZGluZyBlcnJvcnMgdGhhdCBhcmUgdW5hY2NlcHRhYmxlIGZvciBmaW5hbmNpYWwgY2FsY3VsYXRpb25zLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYERlY2ltYWwgcHJpY2UgPSAxOS45OTtcbkRlY2ltYWwgdG90YWwgPSBwcmljZSAqIDEuMDg7ICAvLyBFeGFjdCBjYWxjdWxhdGlvbmAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlVzZSBEZWNpbWFsIGZvciBmaW5hbmNpYWwgY2FsY3VsYXRpb25zIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IHByZWNpc2lvbiBpc3N1ZXMuIEN1cnJlbmN5IGZpZWxkcyBpbiBTYWxlc2ZvcmNlIGFyZSBhbHNvIHN0b3JlZCBhcyBEZWNpbWFsLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlNhbGVzZm9yY2Ugc3Ryb25nbHkgcmVjb21tZW5kcyBEZWNpbWFsIGZvciBjdXJyZW5jeS4gVGhpcyBhcHBlYXJzIGluIFBEMSBxdWVzdGlvbnMgYWJvdXQgZGF0YSB0eXBlIHNlbGVjdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAzLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGF0IGhhcHBlbnMgd2hlbiB5b3UgZGVjbGFyZSAnSW50ZWdlciBjb3VudDsnIHdpdGhvdXQgaW5pdGlhbGl6YXRpb24/XCIsXG4gICAgICAgIGFuc3dlcjogXCJjb3VudCBkZWZhdWx0cyB0byBudWxsXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkluIEFwZXgsIHVuaW5pdGlhbGl6ZWQgcHJpbWl0aXZlIHdyYXBwZXIgdHlwZXMgKEludGVnZXIsIERvdWJsZSwgQm9vbGVhbiwgZXRjLikgZGVmYXVsdCB0byBudWxsLCBub3QgemVyby4gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBKYXZhIHdoZXJlIHByaW1pdGl2ZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBJbnRlZ2VyIGNvdW50ID0gMDsgIC8vIEV4cGxpY2l0bHkgaW5pdGlhbGl6ZVxuLy8gT1JcbkludGVnZXIgY291bnQ7XG5pZiAoY291bnQgPT0gbnVsbCkge1xuICAgIGNvdW50ID0gMDsgIC8vIEhhbmRsZSBudWxsIGNhc2Vcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJBcGV4IHByaW1pdGl2ZSB3cmFwcGVycyBkZWZhdWx0IHRvIG51bGwsIG5vdCB6ZXJvLiBBbHdheXMgaW5pdGlhbGl6ZSBvciBudWxsLWNoZWNrIGJlZm9yZSB1c2luZy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJQRDEgZXhhbSB0ZXN0cyB1bmRlcnN0YW5kaW5nIG9mIG51bGwgdnMgemVyby4gUmVtZW1iZXIgQXBleCB1c2VzIHdyYXBwZXIgdHlwZXMgKEludGVnZXIpIG5vdCBwcmltaXRpdmVzIChpbnQpLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDQsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkZpeCB0aGlzIGNvZGU6ICdib29sZWFuIGlzQWN0aXZlID0gdHJ1ZTsnXCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgQm9vbGVhbiAoY2FwaXRhbCBCKSBpbnN0ZWFkIG9mIGJvb2xlYW5cIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiQXBleCB1c2VzIHdyYXBwZXIgdHlwZXMsIG5vdCBKYXZhIHByaW1pdGl2ZXMuICdib29sZWFuJyAobG93ZXJjYXNlKSBkb2Vzbid0IGV4aXN0IGluIEFwZXggLSB1c2UgJ0Jvb2xlYW4nIChjYXBpdGFsIEIpLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYEJvb2xlYW4gaXNBY3RpdmUgPSB0cnVlOyAgLy8gQ29ycmVjdCB3cmFwcGVyIHR5cGVgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJBcGV4IG9ubHkgaGFzIHdyYXBwZXIgdHlwZXMgKEJvb2xlYW4sIEludGVnZXIsIERvdWJsZSksIG5vdCBKYXZhIHByaW1pdGl2ZXMgKGJvb2xlYW4sIGludCwgZG91YmxlKS5cIixcbiAgICAgICAgZXhhbVRpcDogXCJDYXNlIHNlbnNpdGl2aXR5IGlzIHRlc3RlZCBvbiBQRDEuIEFsd2F5cyB1c2UgY2FwaXRhbCBsZXR0ZXJzIGZvciBBcGV4IGRhdGEgdHlwZXMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoYXQncyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuICdJbnRlZ2VyJyBhbmQgJ2ludCcgaW4gQXBleD9cIixcbiAgICAgICAgYW5zd2VyOiBcIidpbnQnIGRvZXNuJ3QgZXhpc3QgaW4gQXBleCAtIG9ubHkgJ0ludGVnZXInIGlzIHZhbGlkXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIlVubGlrZSBKYXZhLCBBcGV4IG9ubHkgaGFzIHdyYXBwZXIgdHlwZXMuIFRoZXJlIGFyZSBubyBwcmltaXRpdmUgdHlwZXMgbGlrZSAnaW50JywgJ2Jvb2xlYW4nLCBvciAnZG91YmxlJyBpbiBBcGV4LiBBbGwgZGF0YSB0eXBlcyBhcmUgb2JqZWN0cyB0aGF0IGNhbiBiZSBudWxsLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYEludGVnZXIgY291bnQgPSAxMDsgICAgIC8vIENvcnJlY3RcbkJvb2xlYW4gZmxhZyA9IHRydWU7ICAgIC8vIENvcnJlY3RcbkRvdWJsZSByYXRlID0gMi41OyAgICAgIC8vIENvcnJlY3RgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJBcGV4IHNpbXBsaWZpZXMgSmF2YSBieSBvbmx5IGhhdmluZyB3cmFwcGVyIHR5cGVzLiBUaGlzIG1lYW5zIGFsbCB2YXJpYWJsZXMgY2FuIGJlIG51bGwgYW5kIGhhdmUgbWV0aG9kcy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJUaGlzIGZ1bmRhbWVudGFsIGRpZmZlcmVuY2UgZnJvbSBKYXZhIGlzIGZyZXF1ZW50bHkgdGVzdGVkLiBSZW1lbWJlcjogQXBleCA9IHdyYXBwZXIgdHlwZXMgb25seS5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA2LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCBoYXBwZW5zIHdpdGggdGhpcyBjb2RlOiBEZWNpbWFsIGQxID0gbnVsbDsgRGVjaW1hbCBkMiA9IDEwOyBEZWNpbWFsIHJlc3VsdCA9IGQxICsgZDI7XCIsXG4gICAgICAgIGFuc3dlcjogXCJOdWxsUG9pbnRlckV4Y2VwdGlvbiBpcyB0aHJvd25cIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiV2hlbiBwZXJmb3JtaW5nIGFyaXRobWV0aWMgb3BlcmF0aW9ucyB3aXRoIERlY2ltYWwgdmFyaWFibGVzLCBpZiBhbnkgb3BlcmFuZCBpcyBudWxsLCB0aGUgb3BlcmF0aW9uIHRocm93cyBhIE51bGxQb2ludGVyRXhjZXB0aW9uLiBVbmxpa2Ugc29tZSBsYW5ndWFnZXMgdGhhdCBtaWdodCB0cmVhdCBudWxsIGFzIHplcm8sIEFwZXggcmVxdWlyZXMgZXhwbGljaXQgbnVsbCBjaGVja2luZy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBEZWNpbWFsIGQxID0gbnVsbDtcbkRlY2ltYWwgZDIgPSAxMDtcbkRlY2ltYWwgcmVzdWx0ID0gKGQxICE9IG51bGwgPyBkMSA6IDApICsgZDI7ICAvLyBTYWZlIGFkZGl0aW9uYCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQWx3YXlzIG51bGwtY2hlY2sgRGVjaW1hbCB2YXJpYWJsZXMgYmVmb3JlIGFyaXRobWV0aWMgb3BlcmF0aW9ucy4gQXBleCBkb2Vzbid0IGF1dG8tY29udmVydCBudWxsIHRvIHplcm8uXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiTnVsbCBhcml0aG1ldGljIG9wZXJhdGlvbnMgYXJlIGZyZXF1ZW50bHkgdGVzdGVkIHNjZW5hcmlvcyBvbiBjZXJ0aWZpY2F0aW9uIGV4YW1zLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDcsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSdyZSByZXZpZXdpbmcgY29kZSBhbmQgc2VlICdTdHJpbmcgbmFtZTsgU3lzdGVtLmRlYnVnKG5hbWUudG9VcHBlckNhc2UoKSk7JyAtIHdoYXQgd2lsbCBoYXBwZW4gYW5kIGhvdyBkbyB5b3UgZml4IGl0P1wiLFxuICAgICAgICBhbnN3ZXI6IFwiTnVsbFBvaW50ZXJFeGNlcHRpb24gd2lsbCBiZSB0aHJvd24gYmVjYXVzZSAnbmFtZScgaXMgdW5pbml0aWFsaXplZCAobnVsbClcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiSW4gQXBleCwgZGVjbGFyaW5nIGEgdmFyaWFibGUgd2l0aG91dCBpbml0aWFsaXphdGlvbiBzZXRzIGl0IHRvIG51bGwuIENhbGxpbmcgbWV0aG9kcyBvbiBudWxsIG9iamVjdHMgdGhyb3dzIE51bGxQb2ludGVyRXhjZXB0aW9uIGF0IHJ1bnRpbWUuIFRoaXMgaXMgYSBjb21tb24gbWlzdGFrZSBmb3IgZGV2ZWxvcGVycyBjb21pbmcgZnJvbSBsYW5ndWFnZXMgd2hlcmUgcHJpbWl0aXZlcyBoYXZlIGRlZmF1bHQgdmFsdWVzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYC8vIE9wdGlvbiAxOiBJbml0aWFsaXplIHdpdGggYSB2YWx1ZVxuU3RyaW5nIG5hbWUgPSAnSm9obic7XG5TeXN0ZW0uZGVidWcobmFtZS50b1VwcGVyQ2FzZSgpKTsgLy8gU2FmZVxuXG4vLyBPcHRpb24gMjogTnVsbC1jaGVjayBiZWZvcmUgdXNlXG5TdHJpbmcgbmFtZTtcbmlmIChTdHJpbmcuaXNOb3RCbGFuayhuYW1lKSkge1xuICAgIFN5c3RlbS5kZWJ1ZyhuYW1lLnRvVXBwZXJDYXNlKCkpO1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkFsd2F5cyBpbml0aWFsaXplIHZhcmlhYmxlcyBvciBudWxsLWNoZWNrIGJlZm9yZSBjYWxsaW5nIG1ldGhvZHMuIFVuaW5pdGlhbGl6ZWQgcmVmZXJlbmNlIHZhcmlhYmxlcyBkZWZhdWx0IHRvIG51bGwgaW4gQXBleC5cIixcbiAgICAgICAgZXhhbVRpcDogXCJUaGlzIGV4YWN0IHBhdHRlcm4gYXBwZWFycyBmcmVxdWVudGx5IG9uIGNlcnRpZmljYXRpb24gZXhhbXMuIEFsd2F5cyBsb29rIGZvciB1bmluaXRpYWxpemVkIHZhcmlhYmxlcyBpbiBjb2RlIHNhbXBsZXMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogOCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkEganVuaW9yIGRldmVsb3BlciBhc2tzIHdoeSAnaW50IGNvdW50ID0gMDsnIGRvZXNuJ3Qgd29yayBpbiBBcGV4LiBIb3cgZG8geW91IGV4cGxhaW4gaXQ/XCIsXG4gICAgICAgIGFuc3dlcjogXCJBcGV4IG9ubHkgaGFzIHdyYXBwZXIgdHlwZXMgbGlrZSAnSW50ZWdlcicsIG5vdCBwcmltaXRpdmVzIGxpa2UgJ2ludCdcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiVW5saWtlIEphdmEsIEFwZXggc2ltcGxpZmllZCB0aGUgdHlwZSBzeXN0ZW0gYnkgb25seSBwcm92aWRpbmcgd3JhcHBlciB0eXBlcyAoSW50ZWdlciwgQm9vbGVhbiwgRG91YmxlLCBldGMuKS4gVGhlcmUgYXJlIG5vIHByaW1pdGl2ZSB0eXBlcyAoaW50LCBib29sZWFuLCBkb3VibGUpIGluIEFwZXguIFRoaXMgbWVhbnMgYWxsIHZhcmlhYmxlcyBjYW4gYmUgbnVsbCBhbmQgaGF2ZSBtZXRob2RzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYEludGVnZXIgY291bnQgPSAwOyAgICAgICAgLy8gQ29ycmVjdCAtIHdyYXBwZXIgdHlwZVxuQm9vbGVhbiBpc0FjdGl2ZSA9IHRydWU7ICAvLyBDb3JyZWN0IC0gd3JhcHBlciB0eXBlXG5Eb3VibGUgcmF0ZSA9IDIuNTsgICAgICAgIC8vIENvcnJlY3QgLSB3cmFwcGVyIHR5cGVcblxuLy8gVGhlc2UgZG9uJ3QgZXhpc3QgaW4gQXBleDpcbi8vIGludCBjb3VudCA9IDA7ICAgICAgICAvLyBDb21waWxhdGlvbiBlcnJvclxuLy8gYm9vbGVhbiBmbGFnID0gdHJ1ZTsgIC8vIENvbXBpbGF0aW9uIGVycm9yYCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQXBleCA9IHdyYXBwZXIgdHlwZXMgb25seS4gVGhpcyBzaW1wbGlmaWVzIHRoZSBsYW5ndWFnZSBidXQgbWVhbnMgYWxsIHZhcmlhYmxlcyBjYW4gYmUgbnVsbC5cIixcbiAgICAgICAgZXhhbVRpcDogXCJUeXBlIHN5c3RlbSBxdWVzdGlvbnMgYXJlIGNvbW1vbi4gUmVtZW1iZXI6IEFwZXggd3JhcHBlciB0eXBlcyAoSW50ZWdlcikgdnMgSmF2YSBwcmltaXRpdmVzIChpbnQpIC0gb25seSB3cmFwcGVycyBleGlzdCBpbiBBcGV4LlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDksXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJZb3UgbmVlZCB0byBzdG9yZSBtb25ldGFyeSB2YWx1ZXMgd2l0aCBwcmVjaXNpb24uIFdoYXQgZGF0YSB0eXBlIGRvIHlvdSBjaG9vc2UgYW5kIHdoeT9cIixcbiAgICAgICAgYW5zd2VyOiBcIkRlY2ltYWwgLSBpdCBwcm92aWRlcyBleGFjdCBwcmVjaXNpb24gd2l0aG91dCBmbG9hdGluZy1wb2ludCByb3VuZGluZyBlcnJvcnNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiRm9yIGZpbmFuY2lhbCBjYWxjdWxhdGlvbnMsIERlY2ltYWwgaXMgdGhlIG9ubHkgc2FmZSBjaG9pY2UgYmVjYXVzZSBpdCBhdm9pZHMgZmxvYXRpbmctcG9pbnQgYXJpdGhtZXRpYyBlcnJvcnMgdGhhdCBjYW4gb2NjdXIgd2l0aCBEb3VibGUuIEN1cnJlbmN5IGZpZWxkcyBpbiBTYWxlc2ZvcmNlIGFyZSBzdG9yZWQgYXMgRGVjaW1hbCwgbWFraW5nIHRoaXMgdGhlIG5hdHVyYWwgY2hvaWNlIGZvciBtb25ldGFyeSBjYWxjdWxhdGlvbnMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gQ29ycmVjdCBmb3IgY3VycmVuY3lcbkRlY2ltYWwgcHJpY2UgPSAxOS45OTtcbkRlY2ltYWwgdGF4ID0gcHJpY2UgKiAwLjA4O1xuRGVjaW1hbCB0b3RhbCA9IHByaWNlICsgdGF4OyAgLy8gRXhhY3QgY2FsY3VsYXRpb25cblxuLy8gV3JvbmcgZm9yIGN1cnJlbmN5IC0gY2FuIGhhdmUgcm91bmRpbmcgZXJyb3JzXG5Eb3VibGUgcHJpY2UgPSAxOS45OTtcbkRvdWJsZSB0YXggPSBwcmljZSAqIDAuMDg7ICAgIC8vIFBvdGVudGlhbCBwcmVjaXNpb24gbG9zc2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlVzZSBEZWNpbWFsIGZvciBhbGwgZmluYW5jaWFsIGNhbGN1bGF0aW9ucyB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBwcmVjaXNpb24gaXNzdWVzLiBDdXJyZW5jeSBmaWVsZHMgaW4gU2FsZXNmb3JjZSB1c2UgRGVjaW1hbC5cIixcbiAgICAgICAgZXhhbVRpcDogXCJDdXJyZW5jeSBkYXRhIHR5cGUgcXVlc3Rpb25zIGFwcGVhciBmcmVxdWVudGx5LiBSZW1lbWJlcjogRGVjaW1hbCBmb3IgbW9uZXksIERvdWJsZS9GbG9hdCBmb3Igc2NpZW50aWZpYyBjYWxjdWxhdGlvbnMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTAsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkNvZGUgcmV2aWV3OiAnQm9vbGVhbiBpc0FjdGl2ZTsnIC0gd2hhdCdzIHRoZSBwb3RlbnRpYWwgaXNzdWUgYW5kIGhvdyBkbyB5b3UgaW1wcm92ZSBpdD9cIixcbiAgICAgICAgYW5zd2VyOiBcIlVuaW5pdGlhbGl6ZWQgQm9vbGVhbiBkZWZhdWx0cyB0byBudWxsLCBub3QgZmFsc2UsIHdoaWNoIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkluIEFwZXgsIEJvb2xlYW4gdmFyaWFibGVzIGRlZmF1bHQgdG8gbnVsbCB3aGVuIHVuaW5pdGlhbGl6ZWQsIG5vdCBmYWxzZS4gVGhpcyBjYW4gY2F1c2UgaXNzdWVzIGluIGNvbmRpdGlvbmFsIGxvZ2ljIHdoZXJlIHlvdSBtaWdodCBleHBlY3QgZmFsc2UgYmVoYXZpb3IuIEV4cGxpY2l0IGluaXRpYWxpemF0aW9uIHByZXZlbnRzIGNvbmZ1c2lvbiBhbmQgcG90ZW50aWFsIE5QRXMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gQmV0dGVyOiBFeHBsaWNpdCBpbml0aWFsaXphdGlvblxuQm9vbGVhbiBpc0FjdGl2ZSA9IGZhbHNlOyAgLy8gQ2xlYXIgaW50ZW50LCBubyBudWxsIGlzc3Vlc1xuXG4vLyBPciBoYW5kbGUgbnVsbCBleHBsaWNpdGx5XG5Cb29sZWFuIGlzQWN0aXZlO1xuaWYgKGlzQWN0aXZlID09IHRydWUpIHsgICAgLy8gRXhwbGljaXQgbnVsbC1zYWZlIGNvbXBhcmlzb25cbiAgICBTeXN0ZW0uZGVidWcoJ0FjdGl2ZScpO1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkJvb2xlYW4gdmFyaWFibGVzIGRlZmF1bHQgdG8gbnVsbCwgbm90IGZhbHNlLiBBbHdheXMgaW5pdGlhbGl6ZSBvciB1c2UgZXhwbGljaXQgbnVsbC1zYWZlIGNvbXBhcmlzb25zLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkJvb2xlYW4gbnVsbCBiZWhhdmlvciBpcyB0ZXN0ZWQgZnJlcXVlbnRseS4gUmVtZW1iZXI6IG51bGwgIT0gZmFsc2UgaW4gQXBleCBCb29sZWFuIGxvZ2ljLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDExLFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiQSBtZXRob2QgcmVjZWl2ZXMgYSBTdHJpbmcgcGFyYW1ldGVyIHRoYXQgbWlnaHQgYmUgbnVsbCwgZW1wdHksIG9yIHdoaXRlc3BhY2UuIFdyaXRlIHRoZSBzYWZlc3QgdmFsaWRhdGlvbi5cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBTdHJpbmcuaXNOb3RCbGFuaygpIGZvciBjb21wcmVoZW5zaXZlIHZhbGlkYXRpb25cIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiU3RyaW5nLmlzTm90QmxhbmsoKSBpcyB0aGUgbW9zdCBjb21wcmVoZW5zaXZlIGNoZWNrIGFzIGl0IHZhbGlkYXRlcyBhZ2FpbnN0IG51bGwsIGVtcHR5IHN0cmluZywgYW5kIHN0cmluZ3MgY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycy4gVGhpcyBpcyBzYWZlciB0aGFuIG1hbnVhbCBudWxsIGNoZWNrcyBvciBpc0VtcHR5KCkuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIHZvaWQgcHJvY2Vzc05hbWUoU3RyaW5nIG5hbWUpIHtcbiAgICAvLyBCZXN0OiBIYW5kbGVzIG51bGwsIGVtcHR5LCBhbmQgd2hpdGVzcGFjZVxuICAgIGlmIChTdHJpbmcuaXNOb3RCbGFuayhuYW1lKSkge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ1ZhbGlkIG5hbWU6ICcgKyBuYW1lLnRyaW0oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgU3lzdGVtLmRlYnVnKCdJbnZhbGlkIG5hbWUgcHJvdmlkZWQnKTtcbiAgICB9XG59XG5cbi8vIEFsdGVybmF0aXZlIGZvciBzcGVjaWZpYyBjYXNlczpcbmlmIChTdHJpbmcuaXNOb3RFbXB0eShuYW1lKSkgeyB9IC8vIG51bGwgYW5kIGVtcHR5IG9ubHlcbmlmIChuYW1lICE9IG51bGwgJiYgbmFtZS5sZW5ndGgoKSA+IDApIHsgfSAvLyBNYW51YWwsIG1vcmUgdmVyYm9zZWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlN0cmluZy5pc05vdEJsYW5rKCkgaXMgeW91ciBiZXN0IGZyaWVuZCBmb3Igc3RyaW5nIHZhbGlkYXRpb24uIEl0IGhhbmRsZXMgYWxsIGVkZ2UgY2FzZXMgaW4gb25lIGNhbGwuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiU3RyaW5nIHZhbGlkYXRpb24gcXVlc3Rpb25zIGFyZSBjb21tb24uIEtub3cgdGhlIGRpZmZlcmVuY2U6IGlzTm90QmxhbmsgKG51bGwvZW1wdHkvd2hpdGVzcGFjZSksIGlzTm90RW1wdHkgKG51bGwvZW1wdHkgb25seSkuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTIsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhZHZhbmNlZCcsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkV4cGxhaW4gd2hlbiB5b3UnZCB1c2UgJ2ZpbmFsJyBrZXl3b3JkIHdpdGggdmFyaWFibGVzIGFuZCBnaXZlIGEgcHJhY3RpY2FsIGV4YW1wbGUuXCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgJ2ZpbmFsJyBmb3IgY29uc3RhbnRzIGFuZCB2YXJpYWJsZXMgdGhhdCBzaG91bGRuJ3QgYmUgcmVhc3NpZ25lZCBhZnRlciBpbml0aWFsaXphdGlvblwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJUaGUgJ2ZpbmFsJyBrZXl3b3JkIHByZXZlbnRzIHZhcmlhYmxlIHJlYXNzaWdubWVudCBhZnRlciBpbml0aWFsaXphdGlvbiwgbWFraW5nIGNvZGUgbW9yZSBwcmVkaWN0YWJsZSBhbmQgY2F0Y2hpbmcgYWNjaWRlbnRhbCBtb2RpZmljYXRpb25zLiBJdCdzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBjb25zdGFudHMsIGNvbmZpZ3VyYXRpb24gdmFsdWVzLCBhbmQgcHJvdGVjdGluZyBpbXBvcnRhbnQgcmVmZXJlbmNlcy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgY2xhc3MgQ29uZmlndXJhdGlvbk1hbmFnZXIge1xuICAgIC8vIENsYXNzIGNvbnN0YW50IC0gY29tcGlsZS10aW1lIGNvbnN0YW50XG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluYWwgSW50ZWdlciBNQVhfUkVUUklFUyA9IDM7XG5cbiAgICAvLyBJbnN0YW5jZSBjb25zdGFudCAtIHJ1bnRpbWUgY29uc3RhbnRcbiAgICBwcml2YXRlIGZpbmFsIFN0cmluZyBvcmdhbml6YXRpb25JZDtcblxuICAgIHB1YmxpYyBDb25maWd1cmF0aW9uTWFuYWdlcigpIHtcbiAgICAgICAgLy8gQ2FuIG9ubHkgYmUgc2V0IG9uY2UgZHVyaW5nIGNvbnN0cnVjdGlvblxuICAgICAgICB0aGlzLm9yZ2FuaXphdGlvbklkID0gVXNlckluZm8uZ2V0T3JnYW5pemF0aW9uSWQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdm9pZCBwcm9jZXNzRGF0YShMaXN0PEFjY291bnQ+IGFjY291bnRzKSB7XG4gICAgICAgIC8vIE1ldGhvZC1sZXZlbCBjb25zdGFudFxuICAgICAgICBmaW5hbCBJbnRlZ2VyIEJBVENIX1NJWkUgPSAyMDA7XG5cbiAgICAgICAgLy8gb3JnYW5pemF0aW9uSWQgPSAnbmV3LWlkJzsgIC8vIENvbXBpbGF0aW9uIGVycm9yXG4gICAgICAgIC8vIEJBVENIX1NJWkUgPSAzMDA7ICAgICAgICAgICAvLyBDb21waWxhdGlvbiBlcnJvclxuICAgIH1cbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCInZmluYWwnIHByZXZlbnRzIHJlYXNzaWdubWVudCBhbmQgZG9jdW1lbnRzIGludGVudC4gVXNlIGZvciBjb25zdGFudHMsIGNvbmZpZ3VyYXRpb24sIGFuZCBwcm90ZWN0aW5nIGltcG9ydGFudCByZWZlcmVuY2VzLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkZpbmFsIGtleXdvcmQgcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiBpbW11dGFiaWxpdHkuIFJlbWVtYmVyOiBwcmV2ZW50cyByZWFzc2lnbm1lbnQsIG5vdCBvYmplY3QgbW9kaWZpY2F0aW9uLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDEzLFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiWW91IHNlZSAnT2JqZWN0IGRhdGEgPSBzb21lTWV0aG9kKCk7JyAtIHdoYXQgYXJlIHRoZSByaXNrcyBhbmQgaG93IGRvIHlvdSBoYW5kbGUgdGhlbSBzYWZlbHk/XCIsXG4gICAgICAgIGFuc3dlcjogXCJSaXNrIG9mIENsYXNzQ2FzdEV4Y2VwdGlvbiBhbmQgbG9zcyBvZiB0eXBlIHNhZmV0eS4gVXNlIGluc3RhbmNlb2YgY2hlY2tzIGFuZCBleHBsaWNpdCBjYXN0aW5nXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIk9iamVjdCBpcyB0aGUgbW9zdCBnZW5lcmljIHR5cGUgaW4gQXBleC4gVXNpbmcgaXQgbG9zZXMgY29tcGlsZS10aW1lIHR5cGUgY2hlY2tpbmcgYW5kIHJlcXVpcmVzIHJ1bnRpbWUgdHlwZSB2ZXJpZmljYXRpb24uIFRoaXMgY2FuIGxlYWQgdG8gQ2xhc3NDYXN0RXhjZXB0aW9uIGlmIHlvdSBjYXN0IHRvIHRoZSB3cm9uZyB0eXBlLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYE9iamVjdCBkYXRhID0gc29tZU1ldGhvZCgpO1xuXG4vLyBTYWZlIGFwcHJvYWNoIHdpdGggaW5zdGFuY2VvZlxuaWYgKGRhdGEgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICBTdHJpbmcgc3RyaW5nRGF0YSA9IChTdHJpbmcpIGRhdGE7XG4gICAgU3lzdGVtLmRlYnVnKCdTdHJpbmcgdmFsdWU6ICcgKyBzdHJpbmdEYXRhKTtcbn0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEludGVnZXIpIHtcbiAgICBJbnRlZ2VyIGludERhdGEgPSAoSW50ZWdlcikgZGF0YTtcbiAgICBTeXN0ZW0uZGVidWcoJ0ludGVnZXIgdmFsdWU6ICcgKyBpbnREYXRhKTtcbn0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3Q8T2JqZWN0Pikge1xuICAgIExpc3Q8T2JqZWN0PiBsaXN0RGF0YSA9IChMaXN0PE9iamVjdD4pIGRhdGE7XG4gICAgU3lzdGVtLmRlYnVnKCdMaXN0IHNpemU6ICcgKyBsaXN0RGF0YS5zaXplKCkpO1xufSBlbHNlIHtcbiAgICBTeXN0ZW0uZGVidWcoJ1Vua25vd24gZGF0YSB0eXBlOiAnICsgKGRhdGEgIT0gbnVsbCA/IGRhdGEuZ2V0Q2xhc3MoKSA6ICdudWxsJykpO1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIk9iamVjdCB0eXBlIGxvc2VzIHR5cGUgc2FmZXR5LiBBbHdheXMgdXNlIGluc3RhbmNlb2YgYmVmb3JlIGNhc3RpbmcgdG8gcHJldmVudCBDbGFzc0Nhc3RFeGNlcHRpb24uXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiT2JqZWN0IGNhc3RpbmcgcXVlc3Rpb25zIHRlc3QgdHlwZSBzYWZldHkgdW5kZXJzdGFuZGluZy4gUmVtZW1iZXI6IGluc3RhbmNlb2YgYmVmb3JlIGNhc3RpbmcsIGhhbmRsZSBudWxsIGNhc2UuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTQsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkEgZGV2ZWxvcGVyIHVzZXMgJ0RvdWJsZScgZm9yIGN1cnJlbmN5IGNhbGN1bGF0aW9ucy4gV2hhdCBwcm9ibGVtcyBjb3VsZCB0aGlzIGNhdXNlP1wiLFxuICAgICAgICBhbnN3ZXI6IFwiRmxvYXRpbmctcG9pbnQgcHJlY2lzaW9uIGVycm9ycyB0aGF0IGNhbiBjYXVzZSBpbmNvcnJlY3QgbW9uZXRhcnkgY2FsY3VsYXRpb25zXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkRvdWJsZSB1c2VzIGZsb2F0aW5nLXBvaW50IGFyaXRobWV0aWMgd2hpY2ggY2FuJ3QgZXhhY3RseSByZXByZXNlbnQgbWFueSBkZWNpbWFsIG51bWJlcnMsIGxlYWRpbmcgdG8gcm91bmRpbmcgZXJyb3JzLiBGb3IgZmluYW5jaWFsIGNhbGN1bGF0aW9ucywgZXZlbiB0aW55IGVycm9ycyBjb21wb3VuZCBhbmQgY2FuIGNhdXNlIHNpZ25pZmljYW50IGlzc3VlcyBpbiBhY2NvdW50aW5nIGFuZCByZXBvcnRpbmcuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gV3JvbmcgLSBwb3RlbnRpYWwgcHJlY2lzaW9uIGVycm9yc1xuRG91YmxlIHByaWNlID0gMC4xO1xuRG91YmxlIHRheCA9IDAuMjtcbkRvdWJsZSB0b3RhbCA9IHByaWNlICsgdGF4OyAgLy8gTWlnaHQgbm90IGVxdWFsIGV4YWN0bHkgMC4zXG5cbi8vIENvcnJlY3QgLSBleGFjdCBkZWNpbWFsIGFyaXRobWV0aWNcbkRlY2ltYWwgcHJpY2UgPSAwLjE7XG5EZWNpbWFsIHRheCA9IDAuMjtcbkRlY2ltYWwgdG90YWwgPSBwcmljZSArIHRheDsgIC8vIEV4YWN0bHkgMC4zXG5cbi8vIFJlYWwgZXhhbXBsZVxuRGVjaW1hbCBpdGVtUHJpY2UgPSAxOS45OTtcbkRlY2ltYWwgdGF4UmF0ZSA9IDAuMDgyNTsgICAgLy8gOC4yNSVcbkRlY2ltYWwgdG90YWxQcmljZSA9IGl0ZW1QcmljZSAqICgxICsgdGF4UmF0ZSk7YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiTmV2ZXIgdXNlIERvdWJsZSBmb3IgY3VycmVuY3kuIERlY2ltYWwgcHJvdmlkZXMgZXhhY3QgcHJlY2lzaW9uIGZvciBmaW5hbmNpYWwgY2FsY3VsYXRpb25zLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkN1cnJlbmN5IHByZWNpc2lvbiBxdWVzdGlvbnMgYXJlIGZyZXF1ZW50LiBSZW1lbWJlcjogRGVjaW1hbCBmb3IgbW9uZXksIERvdWJsZSBmb3Igc2NpZW50aWZpYyBtZWFzdXJlbWVudHMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTUsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJXcml0ZSBjb2RlIHRvIHNhZmVseSBjb252ZXJ0IHVzZXIgaW5wdXQgZnJvbSBTdHJpbmcgdG8gSW50ZWdlciB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZy5cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSB0cnktY2F0Y2ggd2l0aCBJbnRlZ2VyLnZhbHVlT2YoKSBhbmQgdmFsaWRhdGUgaW5wdXQgZmlyc3RcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiU3RyaW5nIHRvIEludGVnZXIgY29udmVyc2lvbiBjYW4gZmFpbCBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vbi1udW1lcmljIGNoYXJhY3RlcnMuIEFsd2F5cyB2YWxpZGF0ZSBpbnB1dCBhbmQgaGFuZGxlIFR5cGVFeGNlcHRpb24gdG8gcHJvdmlkZSBtZWFuaW5nZnVsIGVycm9yIG1lc3NhZ2VzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBJbnRlZ2VyIHNhZmVTdHJpbmdUb0ludGVnZXIoU3RyaW5nIGlucHV0LCBJbnRlZ2VyIGRlZmF1bHRWYWx1ZSkge1xuICAgIC8vIEVhcmx5IHZhbGlkYXRpb25cbiAgICBpZiAoU3RyaW5nLmlzQmxhbmsoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VcbiAgICBpbnB1dCA9IGlucHV0LnRyaW0oKTtcblxuICAgIC8vIENoZWNrIGlmIHB1cmVseSBudW1lcmljIChvcHRpb25hbCBvcHRpbWl6YXRpb24pXG4gICAgaWYgKCFpbnB1dC5pc051bWVyaWMoKSkge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ05vbi1udW1lcmljIGlucHV0OiAnICsgaW5wdXQpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLnZhbHVlT2YoaW5wdXQpO1xuICAgIH0gY2F0Y2ggKFR5cGVFeGNlcHRpb24gZSkge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ0NvbnZlcnNpb24gZXJyb3IgZm9yIGlucHV0IFwiJyArIGlucHV0ICsgJ1wiOiAnICsgZS5nZXRNZXNzYWdlKCkpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbn1cblxuLy8gVXNhZ2UgZXhhbXBsZVxuSW50ZWdlciB1c2VyQWdlID0gc2FmZVN0cmluZ1RvSW50ZWdlcih1c2VySW5wdXQsIDApO2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkFsd2F5cyB2YWxpZGF0ZSBzdHJpbmcgaW5wdXQgYmVmb3JlIHR5cGUgY29udmVyc2lvbi4gVXNlIHRyeS1jYXRjaCBmb3IgVHlwZUV4Y2VwdGlvbiBhbmQgcHJvdmlkZSBtZWFuaW5nZnVsIGRlZmF1bHRzLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlR5cGUgY29udmVyc2lvbiBxdWVzdGlvbnMgdGVzdCBlcnJvciBoYW5kbGluZyBza2lsbHMuIFJlbWVtYmVyOiB2YWxpZGF0ZSwgdHJ5LWNhdGNoLCBwcm92aWRlIGRlZmF1bHRzLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDE2LFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJZb3UgbmVlZCB0byBjb21wYXJlIHR3byBTdHJpbmcgdmFyaWFibGVzIGZvciBlcXVhbGl0eS4gV2hhdCBhcmUgdGhlIGRpZmZlcmVudCBhcHByb2FjaGVzIGFuZCB0aGVpciBpbXBsaWNhdGlvbnM/XCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgLmVxdWFscygpIG1ldGhvZCBmb3IgY29udGVudCBjb21wYXJpc29uLCBuZXZlciA9PSBvcGVyYXRvclwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJJbiBBcGV4IChsaWtlIEphdmEpLCB0aGUgPT0gb3BlcmF0b3IgY29tcGFyZXMgb2JqZWN0IHJlZmVyZW5jZXMsIG5vdCBjb250ZW50LiBGb3Igc3RyaW5nIGNvbnRlbnQgY29tcGFyaXNvbiwgYWx3YXlzIHVzZSAuZXF1YWxzKCkgbWV0aG9kLiBUaGlzIGlzIGEgY29tbW9uIHNvdXJjZSBvZiBidWdzIGZvciBkZXZlbG9wZXJzIG5ldyB0byBBcGV4LlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYFN0cmluZyBuYW1lMSA9ICdKb2huJztcblN0cmluZyBuYW1lMiA9IGdldE5hbWUoKTsgLy8gUmV0dXJucyAnSm9obidcblxuLy8gV3JvbmcgLSBjb21wYXJlcyByZWZlcmVuY2VzIChtaWdodCBiZSBmYWxzZSBldmVuIHdpdGggc2FtZSBjb250ZW50KVxuaWYgKG5hbWUxID09IG5hbWUyKSB7IH1cblxuLy8gQ29ycmVjdCAtIGNvbXBhcmVzIGNvbnRlbnRcbmlmIChuYW1lMS5lcXVhbHMobmFtZTIpKSB7IH1cblxuLy8gQmV0dGVyIC0gbnVsbC1zYWZlIGNvbXBhcmlzb25cbmlmIChuYW1lMT8uZXF1YWxzKG5hbWUyKSA9PSB0cnVlKSB7IH1cblxuLy8gQmVzdCAtIHVzaW5nIFN0cmluZyB1dGlsaXR5IChoYW5kbGVzIG51bGxzKVxuaWYgKFN0cmluZy5pc0VtcHR5KG5hbWUxKSAmJiBTdHJpbmcuaXNFbXB0eShuYW1lMikpIHtcbiAgICAvLyBCb3RoIGVtcHR5L251bGxcbn0gZWxzZSBpZiAobmFtZTE/LmVxdWFscyhuYW1lMikgPT0gdHJ1ZSkge1xuICAgIC8vIENvbnRlbnQgbWF0Y2hlc1xufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlN0cmluZyBjb21wYXJpc29uOiA9PSBjb21wYXJlcyByZWZlcmVuY2VzLCAuZXF1YWxzKCkgY29tcGFyZXMgY29udGVudC4gQWx3YXlzIHVzZSAuZXF1YWxzKCkgZm9yIHN0cmluZyBjb21wYXJpc29uLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlN0cmluZyBjb21wYXJpc29uIGlzIGhlYXZpbHkgdGVzdGVkLiBSZW1lbWJlcjogPT0gZm9yIHByaW1pdGl2ZXMvcmVmZXJlbmNlcywgLmVxdWFscygpIGZvciBjb250ZW50IGNvbXBhcmlzb24uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMTcsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJBIGZpZWxkIG1pZ2h0IGNvbnRhaW4gbnVsbCBvciBhY3R1YWwgZGF0YS4gV3JpdGUgZGVmZW5zaXZlIGNvZGUgdG8gaGFuZGxlIGJvdGggY2FzZXMuXCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgbnVsbC1jb2FsZXNjaW5nIG9wZXJhdG9ycyBhbmQgc2FmZSBuYXZpZ2F0aW9uIGZvciByb2J1c3QgaGFuZGxpbmdcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiQXBleCBwcm92aWRlcyBzZXZlcmFsIG1lY2hhbmlzbXMgZm9yIHNhZmUgbnVsbCBoYW5kbGluZzogbnVsbC1jb2FsZXNjaW5nICg/OiksIHNhZmUgbmF2aWdhdGlvbiAoPy4pLCBhbmQgdHJhZGl0aW9uYWwgbnVsbCBjaGVja3MuIENvbWJpbmluZyB0aGVzZSBjcmVhdGVzIHJvYnVzdCwgcmVhZGFibGUgY29kZS5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgdm9pZCBwcm9jZXNzQWNjb3VudERhdGEoQWNjb3VudCBhY2MpIHtcbiAgICAvLyBOdWxsLWNvYWxlc2NpbmcgLSBwcm92aWRlIGRlZmF1bHQgaWYgbnVsbFxuICAgIFN0cmluZyBhY2NvdW50TmFtZSA9IGFjYy5OYW1lID8/ICdVbmtub3duIEFjY291bnQnO1xuXG4gICAgLy8gU2FmZSBuYXZpZ2F0aW9uIC0gb25seSBjYWxsIGlmIG5vdCBudWxsXG4gICAgSW50ZWdlciBuYW1lTGVuZ3RoID0gYWNjLk5hbWU/Lmxlbmd0aCgpO1xuXG4gICAgLy8gVHJhZGl0aW9uYWwgbnVsbCBjaGVjayBmb3IgY29tcGxleCBsb2dpY1xuICAgIGlmIChhY2MuQW5udWFsUmV2ZW51ZSAhPSBudWxsKSB7XG4gICAgICAgIERlY2ltYWwgbW9udGhseVJldmVudWUgPSBhY2MuQW5udWFsUmV2ZW51ZSAvIDEyO1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ01vbnRobHkgcmV2ZW51ZTogJyArIG1vbnRobHlSZXZlbnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ0FubnVhbCByZXZlbnVlIG5vdCBzZXQnKTtcbiAgICB9XG5cbiAgICAvLyBDb21iaW5pbmcgYXBwcm9hY2hlc1xuICAgIFN0cmluZyBkaXNwbGF5VGV4dCA9IGFjYy5EZXNjcmlwdGlvbj8uYWJicmV2aWF0ZSg1MCkgPz8gJ05vIGRlc2NyaXB0aW9uIGF2YWlsYWJsZSc7XG5cbiAgICAvLyBTYWZlIGZpZWxkIGFjY2VzcyB3aXRoIGRlZmF1bHRcbiAgICBTdHJpbmcgaW5kdXN0cnkgPSBhY2MuSW5kdXN0cnkgPz8gJ05vdCBTcGVjaWZpZWQnO1xuICAgIFN0cmluZyB0eXBlID0gYWNjLlR5cGUgPz8gJ1N0YW5kYXJkJztcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJVc2UgbnVsbC1jb2FsZXNjaW5nICg/PykgZm9yIGRlZmF1bHRzLCBzYWZlIG5hdmlnYXRpb24gKD8uKSBmb3IgbWV0aG9kIGNhbGxzLCBleHBsaWNpdCBjaGVja3MgZm9yIGNvbXBsZXggbG9naWMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiTnVsbCBoYW5kbGluZyBpcyBjcml0aWNhbCBmb3Igcm9idXN0IGNvZGUuIEtub3cgYWxsIHRocmVlIGFwcHJvYWNoZXM6ID8/LCA/LiwgYW5kIGV4cGxpY2l0IG51bGwgY2hlY2tzLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDE4LFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJFeHBsYWluIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJ1N0cmluZyBzID0gbnVsbDsnIGFuZCAnU3RyaW5nIHMgPSBcXFwiXFxcIjsnIGFuZCB3aGVuIGVhY2ggbWF0dGVycy5cIixcbiAgICAgICAgYW5zd2VyOiBcIm51bGwgbWVhbnMgbm8gb2JqZWN0IGV4aXN0cywgZW1wdHkgc3RyaW5nIG1lYW5zIG9iamVjdCBleGlzdHMgYnV0IGNvbnRhaW5zIG5vIGNoYXJhY3RlcnNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiVGhpcyBkaXN0aW5jdGlvbiBpcyBjcnVjaWFsIGZvciB2YWxpZGF0aW9uIGFuZCBidXNpbmVzcyBsb2dpYy4gbnVsbCB0eXBpY2FsbHkgbWVhbnMgJ25vIHZhbHVlIHByb3ZpZGVkJyB3aGlsZSBlbXB0eSBzdHJpbmcgbWVhbnMgJ3ZhbHVlIHByb3ZpZGVkIGJ1dCBlbXB0eScuIERpZmZlcmVudCB2YWxpZGF0aW9uIG1ldGhvZHMgaGFuZGxlIHRoZXNlIGNhc2VzIGRpZmZlcmVudGx5LlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYFN0cmluZyBudWxsU3RyaW5nID0gbnVsbDsgICAgICAvLyBObyBvYmplY3RcblN0cmluZyBlbXB0eVN0cmluZyA9ICcnOyAgICAgICAvLyBPYmplY3QgZXhpc3RzLCBubyBjb250ZW50XG5TdHJpbmcgYmxhbmtTdHJpbmcgPSAnICAgJzsgICAgLy8gT2JqZWN0IGV4aXN0cywgd2hpdGVzcGFjZSBvbmx5XG5cbi8vIERpZmZlcmVudCB2YWxpZGF0aW9uIHJlc3VsdHM6XG5TeXN0ZW0uZGVidWcoU3RyaW5nLmlzRW1wdHkobnVsbFN0cmluZykpOyAgICAgLy8gdHJ1ZVxuU3lzdGVtLmRlYnVnKFN0cmluZy5pc0VtcHR5KGVtcHR5U3RyaW5nKSk7ICAgIC8vIHRydWVcblN5c3RlbS5kZWJ1ZyhTdHJpbmcuaXNFbXB0eShibGFua1N0cmluZykpOyAgICAvLyBmYWxzZVxuXG5TeXN0ZW0uZGVidWcoU3RyaW5nLmlzQmxhbmsobnVsbFN0cmluZykpOyAgICAgLy8gdHJ1ZVxuU3lzdGVtLmRlYnVnKFN0cmluZy5pc0JsYW5rKGVtcHR5U3RyaW5nKSk7ICAgIC8vIHRydWVcblN5c3RlbS5kZWJ1ZyhTdHJpbmcuaXNCbGFuayhibGFua1N0cmluZykpOyAgICAvLyB0cnVlXG5cbi8vIE51bGwtc2FmZSBvcGVyYXRpb25zOlxuU3lzdGVtLmRlYnVnKG51bGxTdHJpbmc/Lmxlbmd0aCgpKTsgICAgICAgICAgIC8vIG51bGxcblN5c3RlbS5kZWJ1ZyhlbXB0eVN0cmluZz8ubGVuZ3RoKCkpOyAgICAgICAgICAvLyAwXG5TeXN0ZW0uZGVidWcoYmxhbmtTdHJpbmc/Lmxlbmd0aCgpKTsgICAgICAgICAgLy8gM2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIm51bGwgPSBubyBvYmplY3QsIGVtcHR5ID0gb2JqZWN0IHdpdGggbm8gY29udGVudC4gVXNlIGFwcHJvcHJpYXRlIHZhbGlkYXRpb24gbWV0aG9kIGJhc2VkIG9uIGJ1c2luZXNzIG5lZWRzLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlN0cmluZyBzdGF0ZSBxdWVzdGlvbnMgYXJlIGNvbW1vbi4gS25vdzogbnVsbCAobm8gb2JqZWN0KSwgZW1wdHkgKG5vIGNvbnRlbnQpLCBibGFuayAobm8gbWVhbmluZ2Z1bCBjb250ZW50KS5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxOSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcbiAgICAgICAgcXVlc3Rpb246IFwiWW91J3JlIHByb2Nlc3NpbmcgZm9ybSBkYXRhIHdoZXJlIG51bWJlcnMgY29tZSBhcyBzdHJpbmdzLiBTaG93IHRoZSBjb21wbGV0ZSBzYWZlIGNvbnZlcnNpb24gcGF0dGVybi5cIixcbiAgICAgICAgYW5zd2VyOiBcIkNvbXByZWhlbnNpdmUgdmFsaWRhdGlvbiB3aXRoIG11bHRpcGxlIGZhbGxiYWNrIHN0cmF0ZWdpZXNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiUmVhbC13b3JsZCBmb3JtIHByb2Nlc3NpbmcgcmVxdWlyZXMgaGFuZGxpbmcgdmFyaW91cyBlZGdlIGNhc2VzOiBudWxsIHZhbHVlcywgZW1wdHkgc3RyaW5ncywgbm9uLW51bWVyaWMgY29udGVudCwgZGVjaW1hbCB2cyBpbnRlZ2VyLCBuZWdhdGl2ZSB2YWx1ZXMsIGFuZCByYW5nZSB2YWxpZGF0aW9uLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBjbGFzcyBGb3JtRGF0YVByb2Nlc3NvciB7XG4gICAgcHVibGljIHN0YXRpYyBEZWNpbWFsIHBhcnNlRGVjaW1hbEZpZWxkKFN0cmluZyBpbnB1dCwgU3RyaW5nIGZpZWxkTmFtZSwgRGVjaW1hbCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgLy8gU3RlcCAxOiBIYW5kbGUgbnVsbC9lbXB0eVxuICAgICAgICBpZiAoU3RyaW5nLmlzQmxhbmsoaW5wdXQpKSB7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoZmllbGROYW1lICsgJyBpcyBibGFuaywgdXNpbmcgZGVmYXVsdDogJyArIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RlcCAyOiBDbGVhbiB0aGUgaW5wdXRcbiAgICAgICAgU3RyaW5nIGNsZWFuZWQgPSBpbnB1dC50cmltKCkucmVwbGFjZSgnLCcsICcnKTsgLy8gUmVtb3ZlIGNvbW1hc1xuXG4gICAgICAgIC8vIFN0ZXAgMzogQmFzaWMgbnVtZXJpYyB2YWxpZGF0aW9uXG4gICAgICAgIFN0cmluZyBudW1lcmljUGF0dGVybiA9ICdeLT9cXFxcZCpcXFxcLj9cXFxcZCskJztcbiAgICAgICAgaWYgKCFQYXR0ZXJuLm1hdGNoZXMobnVtZXJpY1BhdHRlcm4sIGNsZWFuZWQpKSB7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ0ludmFsaWQgbnVtZXJpYyBmb3JtYXQgZm9yICcgKyBmaWVsZE5hbWUgKyAnOiAnICsgaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0ZXAgNDogU2FmZSBjb252ZXJzaW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBEZWNpbWFsIHJlc3VsdCA9IERlY2ltYWwudmFsdWVPZihjbGVhbmVkKTtcblxuICAgICAgICAgICAgLy8gU3RlcCA1OiBSYW5nZSB2YWxpZGF0aW9uIChleGFtcGxlKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZS5jb250YWlucygnUHJpY2UnKSAmJiByZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdOZWdhdGl2ZSBwcmljZSBub3QgYWxsb3dlZDogJyArIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKFR5cGVFeGNlcHRpb24gZSkge1xuICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdDb252ZXJzaW9uIGZhaWxlZCBmb3IgJyArIGZpZWxkTmFtZSArICc6ICcgKyBlLmdldE1lc3NhZ2UoKSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXNhZ2UgZXhhbXBsZVxuICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBwcm9jZXNzT3JkZXJGb3JtKE1hcDxTdHJpbmcsIFN0cmluZz4gZm9ybURhdGEpIHtcbiAgICAgICAgRGVjaW1hbCBwcmljZSA9IHBhcnNlRGVjaW1hbEZpZWxkKGZvcm1EYXRhLmdldCgncHJpY2UnKSwgJ1ByaWNlJywgMC4wMCk7XG4gICAgICAgIERlY2ltYWwgcXVhbnRpdHkgPSBwYXJzZURlY2ltYWxGaWVsZChmb3JtRGF0YS5nZXQoJ3F0eScpLCAnUXVhbnRpdHknLCAxLjAwKTtcbiAgICAgICAgRGVjaW1hbCB0b3RhbCA9IHByaWNlICogcXVhbnRpdHk7XG4gICAgfVxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlByb2R1Y3Rpb24gZm9ybSBwcm9jZXNzaW5nIG5lZWRzIGNvbXByZWhlbnNpdmUgdmFsaWRhdGlvbjogbnVsbCBoYW5kbGluZywgY2xlYW5pbmcsIGZvcm1hdCBjaGVja2luZywgdHlwZSBjb252ZXJzaW9uLCBhbmQgYnVzaW5lc3MgcnVsZXMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiQ29tcGxleCB2YWxpZGF0aW9uIHNjZW5hcmlvcyB0ZXN0IHJlYWwtd29ybGQgc2tpbGxzLiBUaGluazogdmFsaWRhdGUg4oaSIGNsZWFuIOKGkiBjb252ZXJ0IOKGkiBidXNpbmVzcyBydWxlcy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAyMCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcbiAgICAgICAgcXVlc3Rpb246IFwiWW91J3JlIG1lbnRvcmluZyBzb21lb25lIG9uIHZhcmlhYmxlIG5hbWluZy4gV2hhdCBhcmUgdGhlIGtleSBwcmluY2lwbGVzIHdpdGggZXhhbXBsZXM/XCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgZGVzY3JpcHRpdmUgbmFtZXMsIGNvbnNpc3RlbnQgY29udmVudGlvbnMsIGFuZCBjb250ZXh0LWFwcHJvcHJpYXRlIHNjb3BlIGluZGljYXRvcnNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiR29vZCB2YXJpYWJsZSBuYW1pbmcgaW1wcm92ZXMgY29kZSByZWFkYWJpbGl0eSBhbmQgbWFpbnRhaW5hYmlsaXR5LiBGb2xsb3cgY29udmVudGlvbnMgdGhhdCBtYWtlIGludGVudCBjbGVhciwgc2NvcGUgb2J2aW91cywgYW5kIHB1cnBvc2UgZXhwbGljaXQuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgcHVibGljIGNsYXNzIFZhcmlhYmxlTmFtaW5nQmVzdFByYWN0aWNlcyB7XG4gICAgLy8gQ29uc3RhbnRzOiBTQ1JFQU1JTkdfU05BS0VfQ0FTRVxuICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIEludGVnZXIgTUFYX1JFVFJZX0FUVEVNUFRTID0gMztcbiAgICBwcml2YXRlIHN0YXRpYyBmaW5hbCBTdHJpbmcgREVGQVVMVF9DT1VOVFJZX0NPREUgPSAnVVMnO1xuXG4gICAgLy8gSW5zdGFuY2UgdmFyaWFibGVzOiBjYW1lbENhc2Ugd2l0aCBkZXNjcmlwdGl2ZSBuYW1lc1xuICAgIHByaXZhdGUgU3RyaW5nIGN1c3RvbWVyRW1haWxBZGRyZXNzO1xuICAgIHByaXZhdGUgRGVjaW1hbCBtb250aGx5UmVjdXJyaW5nUmV2ZW51ZTtcbiAgICBwcml2YXRlIERhdGUgbGFzdExvZ2luVGltZXN0YW1wO1xuXG4gICAgLy8gTWV0aG9kIHBhcmFtZXRlcnM6IGNhbWVsQ2FzZSwgY29udGV4dC1jbGVhclxuICAgIHB1YmxpYyB2b2lkIHVwZGF0ZUN1c3RvbWVyUHJvZmlsZShTdHJpbmcgbmV3RW1haWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQm9vbGVhbiBpc0VtYWlsVmVyaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRlIHByb2ZpbGVMYXN0TW9kaWZpZWQpIHtcblxuICAgICAgICAvLyBMb2NhbCB2YXJpYWJsZXM6IGRlc2NyaXB0aXZlIHdpdGhpbiBzY29wZVxuICAgICAgICBTdHJpbmcgbm9ybWFsaXplZEVtYWlsID0gbmV3RW1haWxBZGRyZXNzLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBCb29sZWFuIGlzVmFsaWRFbWFpbEZvcm1hdCA9IHZhbGlkYXRlRW1haWxGb3JtYXQobm9ybWFsaXplZEVtYWlsKTtcblxuICAgICAgICAvLyBMb29wIHZhcmlhYmxlczogc2hvcnQgbmFtZXMgT0sgZm9yIHNob3J0IHNjb3Blc1xuICAgICAgICBmb3IgKEludGVnZXIgaSA9IDA7IGkgPCBNQVhfUkVUUllfQVRURU1QVFM7IGkrKykge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB3aXRoIGNsZWFyIGludGVudFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29sbGVjdGlvbiB2YXJpYWJsZXM6IHBsdXJhbCBub3Vuc1xuICAgICAgICBMaXN0PENvbnRhY3Q+IGN1c3RvbWVyQ29udGFjdHMgPSBuZXcgTGlzdDxDb250YWN0PigpO1xuICAgICAgICBNYXA8SWQsIEFjY291bnQ+IGFjY291bnRzQnlJZCA9IG5ldyBNYXA8SWQsIEFjY291bnQ+KCk7XG5cbiAgICAgICAgLy8gQm9vbGVhbiB2YXJpYWJsZXM6IGlzL2hhcy9jYW4vc2hvdWxkIHByZWZpeGVzXG4gICAgICAgIEJvb2xlYW4gaGFzVmFsaWRMaWNlbnNlID0gY2hlY2tMaWNlbnNlU3RhdHVzKCk7XG4gICAgICAgIEJvb2xlYW4gY2FuUHJvY2Vzc1BheW1lbnQgPSB2YWxpZGF0ZVBheW1lbnRNZXRob2QoKTtcbiAgICAgICAgQm9vbGVhbiBzaG91bGRTZW5kTm90aWZpY2F0aW9uID0gZGV0ZXJtaW5lTm90aWZpY2F0aW9uUHJlZmVyZW5jZSgpO1xuICAgIH1cbn1cblxuLy8gQmFkIGV4YW1wbGVzIHRvIGF2b2lkOlxuLy8gU3RyaW5nIHMsIHN0ciwgdGVtcCwgZGF0YSAgICAgICAgICAvLyBUb28gZ2VuZXJpY1xuLy8gSW50ZWdlciBudW0xLCBudW0yICAgICAgICAgICAgICAgICAvLyBVbmNsZWFyIHB1cnBvc2Vcbi8vIEJvb2xlYW4gZmxhZywgY2hlY2sgICAgICAgICAgICAgICAgLy8gV2hhdCBraW5kIG9mIGZsYWcvY2hlY2s/XG4vLyBMaXN0PE9iamVjdD4gbGlzdCAgICAgICAgICAgICAgICAgIC8vIFdoYXQgZG9lcyBpdCBjb250YWluP2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkdvb2QgbmFtZXMgYXJlIHNlbGYtZG9jdW1lbnRpbmcuIFVzZTogZGVzY3JpcHRpdmUgbm91bnMsIGFjdGlvbiB2ZXJicywgY29uc2lzdGVudCBjb252ZW50aW9ucywgYXBwcm9wcmlhdGUgc2NvcGUgbGVuZ3RoLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkNvZGUgcXVhbGl0eSBxdWVzdGlvbnMgaW5jbHVkZSBuYW1pbmcgY29udmVudGlvbnMuIFJlbWVtYmVyOiBjb25zdGFudHMgKENBUFMpLCB2YXJpYWJsZXMgKGNhbWVsQ2FzZSksIGJvb2xlYW5zIChpcy9oYXMvY2FuKS5cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcblxuICAnY29sbGVjdGlvbnMtZGVlcC1kaXZlJzoge1xuICAgIHRpdGxlOiAnQ29sbGVjdGlvbnMgRGVlcCBEaXZlJyxcbiAgICBvdmVydmlldzogJ01hc3RlciBMaXN0cywgU2V0cywgTWFwcyBhbmQgYnVsa2lmaWNhdGlvbiBwYXR0ZXJucy4gTm93IHRoYXQgeW91IHVuZGVyc3RhbmQgc2luZ2xlIHZhbHVlcyAoVmFyaWFibGVzKSwgbGVhcm4gdG8gaGFuZGxlIE1VTFRJUExFIHZhbHVlcyBlZmZpY2llbnRseS4gQ29sbGVjdGlvbnMgYXJlIGVzc2VudGlhbCBmb3IgU2FsZXNmb3JjZSBidWxrIHByb2Nlc3NpbmcgYW5kIHByZXZlbnQgZ292ZXJub3IgbGltaXQgdmlvbGF0aW9ucy4gVGhpcyBrbm93bGVkZ2UgZGlyZWN0bHkgZW5hYmxlcyBDb250cm9sIEZsb3cgKHByb2Nlc3NpbmcgY29sbGVjdGlvbnMpIGFuZCB0cmlnZ2VycyAoaGFuZGxpbmcgYnVsayBkYXRhIGNoYW5nZXMpLicsXG4gICAgY29kZUV4YW1wbGVzOiBbXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnTGlzdCBGdW5kYW1lbnRhbHMnLFxuICAgICAgICBjb2RlOiBgcHVibGljIGNsYXNzIExpc3REZW1vIHtcbiAgICBwdWJsaWMgdm9pZCBwcm9jZXNzTGlzdCgpIHtcbiAgICAgICAgLy8g4pyFIEJVSUxESU5HIE9OOiBWYXJpYWJsZXMgaG9sZCBPTkUgdmFsdWUgKFN0cmluZyBuYW1lID0gJ0pvaG4nKVxuICAgICAgICAvLyDinIUgTkVXIENPTkNFUFQ6IExpc3RzIGhvbGQgTVVMVElQTEUgdmFsdWVzIG9mIHNhbWUgdHlwZVxuICAgICAgICBMaXN0PFN0cmluZz4gbmFtZXMgPSBuZXcgTGlzdDxTdHJpbmc+KCk7XG4gICAgICAgIC8vIOKchSBDT05ORUNUSU9OOiBTYW1lIFN0cmluZyB0eXBlIGZyb20gVmFyaWFibGVzIHRvcGljLCBidXQgbm93IGEgY29udGFpbmVyXG4gICAgICAgIC8vIOKchSBXSFk6IFByb2Nlc3NpbmcgbXVsdGlwbGUgcmVjb3JkcyByZXF1aXJlcyBjb2xsZWN0aW9uc1xuICAgICAgICAvLyDwn5KhIE5FWFQgVE9QSUM6IFlvdSdsbCB1c2UgbG9vcHMgKENvbnRyb2wgRmxvdykgdG8gcHJvY2VzcyB0aGVzZSBlZmZpY2llbnRseVxuXG4gICAgICAgIG5hbWVzLmFkZCgnSm9obicpO1xuICAgICAgICBuYW1lcy5hZGQoJ0phbmUnKTtcbiAgICAgICAgbmFtZXMuYWRkKCdKb2huJyk7IC8vIOKchSBMaXN0cyBhbGxvdyBkdXBsaWNhdGVzICh1bmxpa2UgU2V0cylcblxuICAgICAgICAvLyDinIUgQlVJTERJTkcgRk9SV0FSRDogVGhpcyB2YWxpZGF0aW9uIHBhdHRlcm4gY3J1Y2lhbCBpbiBUcmlnZ2Vyc1xuICAgICAgICBpZiAoIW5hbWVzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgU3RyaW5nIGZpcnN0ID0gbmFtZXMuZ2V0KDApO1xuICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdGaXJzdCBuYW1lOiAnICsgZmlyc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g4pyFIEVOSEFOQ0VEIEZPUiBMT09QOiBQcm9jZXNzIGVhY2ggaXRlbVxuICAgICAgICAvLyDwn5KhIE5FWFQgVE9QSUM6IFRoaXMgbG9vcCBzeW50YXggY29tZXMgZnJvbSBDb250cm9sIEZsb3dcbiAgICAgICAgZm9yIChTdHJpbmcgbmFtZSA6IG5hbWVzKSB7XG4gICAgICAgICAgICAvLyDinIUgQ09OTkVDVElPTjogU3RyaW5nIHZhbGlkYXRpb24gZnJvbSBWYXJpYWJsZXMgdG9waWNcbiAgICAgICAgICAgIGlmIChTdHJpbmcuaXNOb3RCbGFuayhuYW1lKSkge1xuICAgICAgICAgICAgICAgIFN5c3RlbS5kZWJ1ZygnUHJvY2Vzc2luZyB2YWxpZCBuYW1lOiAnICsgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g8J+SoSBCVUlMRElORyBGT1JXQVJEOiBUaGlzIHBhdHRlcm4gc2NhbGVzIHRvIHByb2Nlc3MgMjAwIHJlY29yZHMgaW4gVHJpZ2dlcnNcbiAgICB9XG59YCxcbiAgICAgICAgZXhwbGFuYXRpb246ICdMaXN0cyBhcmUgb3JkZXJlZCBjb2xsZWN0aW9ucyB0aGF0IGFsbG93IGR1cGxpY2F0ZXMuIEFsd2F5cyBjaGVjayBpc0VtcHR5KCkgYmVmb3JlIGFjY2Vzc2luZyBlbGVtZW50cyB0byBhdm9pZCBMaXN0RXhjZXB0aW9uLiBVc2UgZW5oYW5jZWQgZm9yIGxvb3BzIGZvciBjbGVhbmVyIGl0ZXJhdGlvbi4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogJ1NldCBPcGVyYXRpb25zJyxcbiAgICAgICAgY29kZTogYHB1YmxpYyBjbGFzcyBTZXREZW1vIHtcbiAgICBwdWJsaWMgdm9pZCBkZW1vbnN0cmF0ZVNldHMoKSB7XG4gICAgICAgIC8vIOKchSBXSEFUOiBDb250YWluZXIgZm9yIHVuaXF1ZSB2YWx1ZXMgb25seVxuICAgICAgICBTZXQ8U3RyaW5nPiB1bmlxdWVFbWFpbHMgPSBuZXcgU2V0PFN0cmluZz4oKTtcbiAgICAgICAgLy8g4pyFIFdIWTogU2V0cyBhdXRvbWF0aWNhbGx5IHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICAvLyDinIUgUEVSRk9STUFOQ0U6IGNvbnRhaW5zKCkgaXMgTygxKSB2cyBMaXN0IE8obilcblxuICAgICAgICB1bmlxdWVFbWFpbHMuYWRkKCdqb2huQGV4YW1wbGUuY29tJyk7XG4gICAgICAgIHVuaXF1ZUVtYWlscy5hZGQoJ2phbmVAZXhhbXBsZS5jb20nKTtcbiAgICAgICAgdW5pcXVlRW1haWxzLmFkZCgnam9obkBleGFtcGxlLmNvbScpOyAvLyBJZ25vcmVkIC0gZHVwbGljYXRlXG5cbiAgICAgICAgU3lzdGVtLmRlYnVnKCdTaXplOiAnICsgdW5pcXVlRW1haWxzLnNpemUoKSk7IC8vIDIsIG5vdCAzXG5cbiAgICAgICAgLy8g4pyFIEZBU1QgTE9PS1VQOiBVc2UgZm9yIGV4aXN0ZW5jZSBjaGVja3NcbiAgICAgICAgaWYgKHVuaXF1ZUVtYWlscy5jb250YWlucygnam9obkBleGFtcGxlLmNvbScpKSB7XG4gICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ0VtYWlsIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG59YCxcbiAgICAgICAgZXhwbGFuYXRpb246ICdTZXRzIGVuZm9yY2UgdW5pcXVlbmVzcyBhbmQgcHJvdmlkZSBPKDEpIGxvb2t1cCBwZXJmb3JtYW5jZS4gVXNlIFNldHMgd2hlbiB5b3UgbmVlZCB0byBwcmV2ZW50IGR1cGxpY2F0ZXMgb3IgcGVyZm9ybSBmYXN0IGV4aXN0ZW5jZSBjaGVja3MuJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdNYXAgVXNhZ2UnLFxuICAgICAgICBjb2RlOiBgcHVibGljIGNsYXNzIE1hcERlbW8ge1xuICAgIHB1YmxpYyB2b2lkIHByb2Nlc3NBY2NvdW50cygpIHtcbiAgICAgICAgLy8g4pyFIFdIQVQ6IEtleS12YWx1ZSBzdG9yYWdlIGZvciBmYXN0IGxvb2t1cHNcbiAgICAgICAgTWFwPElkLCBBY2NvdW50PiBhY2NvdW50TWFwID0gbmV3IE1hcDxJZCwgQWNjb3VudD4oKTtcbiAgICAgICAgLy8g4pyFIFdIWTogR2V0IHJlY29yZHMgYnkgSUQgd2l0aG91dCBsb29wc1xuXG4gICAgICAgIExpc3Q8QWNjb3VudD4gYWNjb3VudHMgPSBbU0VMRUNUIElkLCBOYW1lIEZST00gQWNjb3VudCBMSU1JVCAxMF07XG5cbiAgICAgICAgLy8g4pyFIFBPUFVMQVRFOiBBZGQgcmVjb3JkcyB0byBtYXBcbiAgICAgICAgZm9yIChBY2NvdW50IGFjYyA6IGFjY291bnRzKSB7XG4gICAgICAgICAgICBhY2NvdW50TWFwLnB1dChhY2MuSWQsIGFjYyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDinIUgU0FGRSBBQ0NFU1M6IENoZWNrIGtleSBleGlzdHNcbiAgICAgICAgSWQgc2VhcmNoSWQgPSBhY2NvdW50c1swXS5JZDtcbiAgICAgICAgaWYgKGFjY291bnRNYXAuY29udGFpbnNLZXkoc2VhcmNoSWQpKSB7XG4gICAgICAgICAgICBBY2NvdW50IGZvdW5kID0gYWNjb3VudE1hcC5nZXQoc2VhcmNoSWQpO1xuICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdGb3VuZDogJyArIGZvdW5kLk5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufWAsXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnTWFwcyBwcm92aWRlIGtleS12YWx1ZSBzdG9yYWdlIHdpdGggTygxKSBsb29rdXAgcGVyZm9ybWFuY2UuIEFsd2F5cyB1c2UgY29udGFpbnNLZXkoKSBiZWZvcmUgZ2V0KCkgdG8gYXZvaWQgbnVsbCBpc3N1ZXMuIEVzc2VudGlhbCBmb3IgYnVsa2lmaWNhdGlvbiBwYXR0ZXJucy4nXG4gICAgICB9XG4gICAgXSxcbiAgICBwcmFjdGljZVF1ZXN0aW9uczogW1xuICAgICAge1xuICAgICAgICBudW1iZXI6IDEsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoYXQncyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgTGlzdCBhbmQgYSBTZXQgaW4gQXBleD9cIixcbiAgICAgICAgYW5zd2VyOiBcIkxpc3RzIGFsbG93IGR1cGxpY2F0ZXMgYW5kIG1haW50YWluIG9yZGVyLCBTZXRzIHByZXZlbnQgZHVwbGljYXRlcyBhbmQgZG9uJ3QgZ3VhcmFudGVlIG9yZGVyXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkxpc3RzIGFyZSBpbmRleGVkIGNvbGxlY3Rpb25zIHRoYXQgY2FuIGNvbnRhaW4gZHVwbGljYXRlIHZhbHVlcyBhbmQgbWFpbnRhaW4gaW5zZXJ0aW9uIG9yZGVyLiBTZXRzIGF1dG9tYXRpY2FsbHkgZW5mb3JjZSB1bmlxdWVuZXNzIC0gYXR0ZW1wdGluZyB0byBhZGQgYSBkdXBsaWNhdGUgdmFsdWUgaXMgaWdub3JlZCwgYW5kIGVsZW1lbnRzIGFyZSBub3Qgc3RvcmVkIGluIGFueSBwYXJ0aWN1bGFyIG9yZGVyLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYExpc3Q8U3RyaW5nPiBuYW1lcyA9IG5ldyBMaXN0PFN0cmluZz57J0pvaG4nLCAnSmFuZScsICdKb2huJ307ICAvLyAzIGl0ZW1zXG5TZXQ8U3RyaW5nPiB1bmlxdWVOYW1lcyA9IG5ldyBTZXQ8U3RyaW5nPnsnSm9obicsICdKYW5lJywgJ0pvaG4nfTsgIC8vIDIgaXRlbXNgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJDaG9vc2UgTGlzdHMgd2hlbiBvcmRlciBtYXR0ZXJzIGFuZCBkdXBsaWNhdGVzIGFyZSBhbGxvd2VkLiBDaG9vc2UgU2V0cyB3aGVuIHlvdSBuZWVkIHRvIGVuc3VyZSB1bmlxdWVuZXNzIGFuZCBmYXN0IGxvb2t1cHMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiUEQxIGZyZXF1ZW50bHkgdGVzdHMgTGlzdCB2cyBTZXQgZGlmZmVyZW5jZXMuIFJlbWVtYmVyOiBMaXN0cyA9IG9yZGVyICsgZHVwbGljYXRlcywgU2V0cyA9IHVuaXF1ZW5lc3MgKyBmYXN0IGNvbnRhaW5zKCkuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMixcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiSG93IGRvIHlvdSBzYWZlbHkgYWNjZXNzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGEgTGlzdD9cIixcbiAgICAgICAgYW5zd2VyOiBcIkNoZWNrIGlmIHRoZSBsaXN0IGlzIG5vdCBlbXB0eSBmaXJzdDogaWYgKCFteUxpc3QuaXNFbXB0eSgpKSB7IGZpcnN0RWxlbWVudCA9IG15TGlzdC5nZXQoMCk7IH1cIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiQWx3YXlzIGNoZWNrIGlmIGEgTGlzdCBoYXMgZWxlbWVudHMgYmVmb3JlIGFjY2Vzc2luZyBieSBpbmRleCB0byBhdm9pZCBTeXN0ZW0uTGlzdEV4Y2VwdGlvbi4gVXNpbmcgaXNFbXB0eSgpIGlzIG1vcmUgcmVhZGFibGUgdGhhbiBjaGVja2luZyBzaXplKCkgPiAwLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYExpc3Q8U3RyaW5nPiBuYW1lcyA9IG5ldyBMaXN0PFN0cmluZz4oKTtcbmlmICghbmFtZXMuaXNFbXB0eSgpKSB7XG4gICAgU3RyaW5nIGZpcnN0ID0gbmFtZXMuZ2V0KDApOyAgLy8gU2FmZSBhY2Nlc3Ncbn0gZWxzZSB7XG4gICAgU3lzdGVtLmRlYnVnKCdMaXN0IGlzIGVtcHR5Jyk7XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiTmV2ZXIgYXNzdW1lIGEgTGlzdCBoYXMgZWxlbWVudHMuIEFsd2F5cyBjaGVjayBpc0VtcHR5KCkgb3Igc2l6ZSgpIGJlZm9yZSB1c2luZyBnZXQoaW5kZXgpLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkluZGV4IG91dCBvZiBib3VuZHMgZXhjZXB0aW9ucyBhcmUgY29tbW9uIGV4YW0gc2NlbmFyaW9zLiBBbHdheXMgdmFsaWRhdGUgYmVmb3JlIGFjY2Vzc2luZy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAzLFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCdzIHdyb25nIHdpdGggdGhpcyBidWxraWZpY2F0aW9uIHBhdHRlcm4/XCIsXG4gICAgICAgIGNvZGU6IGBmb3IgKEFjY291bnQgYWNjIDogVHJpZ2dlci5uZXcpIHtcbiAgICBMaXN0PENvbnRhY3Q+IGNvbnRhY3RzID0gW1NFTEVDVCBJZCBGUk9NIENvbnRhY3QgV0hFUkUgQWNjb3VudElkID0gOmFjYy5JZF07XG4gICAgLy8gUHJvY2VzcyBjb250YWN0c1xufWAsXG4gICAgICAgIGFuc3dlcjogXCJTT1FMIHF1ZXJ5IGluc2lkZSBhIGxvb3AgLSB3aWxsIGhpdCBnb3Zlcm5vciBsaW1pdHNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiUHV0dGluZyBTT1FMIHF1ZXJpZXMgaW5zaWRlIGxvb3BzIGlzIHRoZSBtb3N0IGNvbW1vbiBidWxraWZpY2F0aW9uIGFudGktcGF0dGVybi4gV2l0aCAyMDAgYWNjb3VudHMsIHRoaXMgY3JlYXRlcyAyMDAgc2VwYXJhdGUgcXVlcmllcywgcXVpY2tseSBoaXR0aW5nIHRoZSAxMDAgU09RTCBxdWVyeSBsaW1pdCBwZXIgdHJhbnNhY3Rpb24uXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgU2V0PElkPiBhY2NvdW50SWRzID0gbmV3IFNldDxJZD4oKTtcbmZvciAoQWNjb3VudCBhY2MgOiBUcmlnZ2VyLm5ldykge1xuICAgIGFjY291bnRJZHMuYWRkKGFjYy5JZCk7XG59XG5MaXN0PENvbnRhY3Q+IGFsbENvbnRhY3RzID0gW1NFTEVDVCBJZCwgQWNjb3VudElkIEZST00gQ29udGFjdCBXSEVSRSBBY2NvdW50SWQgSU4gOmFjY291bnRJZHNdO2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkFsd2F5cyBjb2xsZWN0IElEcyBmaXJzdCwgdGhlbiBxdWVyeSBvbmNlIG91dHNpZGUgdGhlIGxvb3AuIFRoaXMgaXMgZnVuZGFtZW50YWwgdG8gd3JpdGluZyBzY2FsYWJsZSBBcGV4LlwiLFxuICAgICAgICBleGFtVGlwOiBcIkdvdmVybm9yIGxpbWl0IHZpb2xhdGlvbnMgZHVlIHRvIHF1ZXJpZXMgaW4gbG9vcHMgYXJlIGhlYXZpbHkgdGVzdGVkIG9uIGNlcnRpZmljYXRpb24gZXhhbXMuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoZW4gc2hvdWxkIHlvdSB1c2UgYSBNYXAgaW5zdGVhZCBvZiBhIExpc3Q/XCIsXG4gICAgICAgIGFuc3dlcjogXCJXaGVuIHlvdSBuZWVkIGZhc3QgbG9va3VwcyBieSBrZXkgb3IgbmVlZCB0byBncm91cCByZWxhdGVkIGRhdGFcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiTWFwcyBwcm92aWRlIE8oMSkgbG9va3VwIHBlcmZvcm1hbmNlIHZzIE8obikgZm9yIExpc3RzLiBVc2UgTWFwcyB3aGVuIHlvdSBmcmVxdWVudGx5IG5lZWQgdG8gZmluZCBpdGVtcyBieSBhIHVuaXF1ZSBpZGVudGlmaWVyLCBvciB3aGVuIGdyb3VwaW5nIHJlbGF0ZWQgb2JqZWN0cyB0b2dldGhlci5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBHb29kOiBNYXAgZm9yIGZhc3QgYWNjb3VudCBsb29rdXBcbk1hcDxJZCwgQWNjb3VudD4gYWNjb3VudE1hcCA9IG5ldyBNYXA8SWQsIEFjY291bnQ+KFtTRUxFQ1QgSWQsIE5hbWUgRlJPTSBBY2NvdW50XSk7XG5BY2NvdW50IGZvdW5kID0gYWNjb3VudE1hcC5nZXQoc29tZUlkKTsgIC8vIE8oMSkgbG9va3VwXG5cbi8vIEJhZDogTGlzdCByZXF1aXJlcyBsb29wIGZvciBsb29rdXBcbkxpc3Q8QWNjb3VudD4gYWNjb3VudHMgPSBbU0VMRUNUIElkLCBOYW1lIEZST00gQWNjb3VudF07XG5mb3IgKEFjY291bnQgYWNjIDogYWNjb3VudHMpIHsgIC8vIE8obikgbG9va3VwXG4gICAgaWYgKGFjYy5JZCA9PSBzb21lSWQpIHsgZm91bmQgPSBhY2M7IGJyZWFrOyB9XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiTWFwcyBleGNlbCBhdCBrZXktYmFzZWQgbG9va3VwcyBhbmQgZ3JvdXBpbmcuIExpc3RzIGFyZSBiZXR0ZXIgZm9yIG9yZGVyZWQgZGF0YSBhbmQgaXRlcmF0aW9uLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlBlcmZvcm1hbmNlIHF1ZXN0aW9ucyBhYm91dCBkYXRhIHN0cnVjdHVyZXMgYXBwZWFyIGZyZXF1ZW50bHkgb24gQXBleCBjZXJ0aWZpY2F0aW9uIGV4YW1zLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDUsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhZHZhbmNlZCcsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSBoYXZlIGEgTGlzdCB3aXRoIDEwMCwwMDAgcmVjb3JkcyBhbmQgbmVlZCB0byBjaGVjayBpZiBhIHNwZWNpZmljIElEIGV4aXN0cy4gV2hhdCdzIHRoZSBwZXJmb3JtYW5jZSBjb25jZXJuIGFuZCBzb2x1dGlvbj9cIixcbiAgICAgICAgYW5zd2VyOiBcIkxpbmVhciBzZWFyY2ggTyhuKSBwZXJmb3JtYW5jZSBpc3N1ZS4gQ29udmVydCB0byBTZXQgb3IgTWFwIGZvciBPKDEpIGxvb2t1cHMuXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkxpc3RzIHJlcXVpcmUgc2Nhbm5pbmcgZXZlcnkgZWxlbWVudCB0byBmaW5kIG1hdGNoZXMsIHdoaWNoIGJlY29tZXMgZXhwZW5zaXZlIHdpdGggbGFyZ2UgZGF0YXNldHMuIFNldHMgYW5kIE1hcHMgcHJvdmlkZSBoYXNoLWJhc2VkIGxvb2t1cHMgdGhhdCBhcmUgZHJhbWF0aWNhbGx5IGZhc3RlciBmb3IgZXhpc3RlbmNlIGNoZWNrcy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBQcm9ibGVtOiBPKG4pIGxvb2t1cCAtIHNsb3cgd2l0aCBsYXJnZSBsaXN0c1xuTGlzdDxJZD4gYWNjb3VudElkcyA9IG5ldyBMaXN0PElkPigvKiAxMDAsMDAwIElEcyAqLyk7XG5Cb29sZWFuIGV4aXN0cyA9IGZhbHNlO1xuZm9yIChJZCBhY2NJZCA6IGFjY291bnRJZHMpIHtcbiAgICBpZiAoYWNjSWQgPT0gdGFyZ2V0SWQpIHsgZXhpc3RzID0gdHJ1ZTsgYnJlYWs7IH0gIC8vIFBvdGVudGlhbGx5IHNjYW5zIGFsbCAxMDBLXG59XG5cbi8vIFNvbHV0aW9uIDE6IFNldCBmb3IgZXhpc3RlbmNlIGNoZWNrcyAtIE8oMSlcblNldDxJZD4gYWNjb3VudElkU2V0ID0gbmV3IFNldDxJZD4oYWNjb3VudElkcyk7XG5Cb29sZWFuIGV4aXN0cyA9IGFjY291bnRJZFNldC5jb250YWlucyh0YXJnZXRJZCk7ICAvLyBGYXN0IGxvb2t1cFxuXG4vLyBTb2x1dGlvbiAyOiBNYXAgaWYgeW91IG5lZWQgdGhlIGRhdGEgdG9vIC0gTygxKVxuTWFwPElkLCBBY2NvdW50PiBhY2NvdW50TWFwID0gbmV3IE1hcDxJZCwgQWNjb3VudD4oW1NFTEVDVCBJZCwgTmFtZSBGUk9NIEFjY291bnRdKTtcbkJvb2xlYW4gZXhpc3RzID0gYWNjb3VudE1hcC5jb250YWluc0tleSh0YXJnZXRJZCk7XG5BY2NvdW50IGZvdW5kQWNjb3VudCA9IGFjY291bnRNYXAuZ2V0KHRhcmdldElkKTtgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJQZXJmb3JtYW5jZSBzY2FsZXMgd2l0aCBjb2xsZWN0aW9uIGNob2ljZS4gVXNlIHRoZSByaWdodCBkYXRhIHN0cnVjdHVyZTogTGlzdCBmb3Igb3JkZXIsIFNldCBmb3IgdW5pcXVlbmVzcywgTWFwIGZvciBrZXktdmFsdWUgcmVsYXRpb25zaGlwcy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJQZXJmb3JtYW5jZSBzY2VuYXJpb3Mgd2l0aCBsYXJnZSBkYXRhc2V0cyBhcmUgY29tbW9uIGludGVydmlldyBxdWVzdGlvbnMuIEFsd2F5cyB0aGluayBhYm91dCB0aW1lIGNvbXBsZXhpdHkuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNixcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiRXhwbGFpbiB3aGVuIHlvdSdkIHVzZSBMaXN0IHZzIFNldCB2cyBNYXAgd2l0aCByZWFsIFNhbGVzZm9yY2Ugc2NlbmFyaW9zLlwiLFxuICAgICAgICBhbnN3ZXI6IFwiTGlzdCBmb3Igb3JkZXJlZCBwcm9jZXNzaW5nLCBTZXQgZm9yIGR1cGxpY2F0ZSBwcmV2ZW50aW9uLCBNYXAgZm9yIGtleS1iYXNlZCByZWxhdGlvbnNoaXBzXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkVhY2ggY29sbGVjdGlvbiB0eXBlIHNlcnZlcyBzcGVjaWZpYyBidXNpbmVzcyBuZWVkcyBpbiBTYWxlc2ZvcmNlLiBVbmRlcnN0YW5kaW5nIHdoZW4gdG8gdXNlIGVhY2ggcHJldmVudHMgcGVyZm9ybWFuY2UgaXNzdWVzIGFuZCBtYWtlcyBjb2RlIG1vcmUgbWFpbnRhaW5hYmxlLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYC8vIExpc3Q6IFdoZW4gb3JkZXIgbWF0dGVycyBhbmQgZHVwbGljYXRlcyBhcmUgT0tcbkxpc3Q8VGFzaz4gdGFza0hpc3RvcnkgPSBbU0VMRUNUIElkLCBTdWJqZWN0IEZST00gVGFzayBXSEVSRSBBY2NvdW50SWQgPSA6YWNjSWQgT1JERVIgQlkgQ3JlYXRlZERhdGVdO1xuZm9yIChUYXNrIHQgOiB0YXNrSGlzdG9yeSkge1xuICAgIC8vIFByb2Nlc3MgaW4gY2hyb25vbG9naWNhbCBvcmRlclxufVxuXG4vLyBTZXQ6IFdoZW4geW91IG5lZWQgdW5pcXVlIHZhbHVlcyBvbmx5XG5TZXQ8U3RyaW5nPiB1bmlxdWVJbmR1c3RyaWVzID0gbmV3IFNldDxTdHJpbmc+KCk7XG5mb3IgKEFjY291bnQgYWNjIDogYWNjb3VudHMpIHtcbiAgICB1bmlxdWVJbmR1c3RyaWVzLmFkZChhY2MuSW5kdXN0cnkpOyAgLy8gQXV0b21hdGljYWxseSBwcmV2ZW50cyBkdXBsaWNhdGVzXG59XG5cbi8vIE1hcDogV2hlbiB5b3UgbmVlZCBmYXN0IGxvb2t1cHMgb3IgZ3JvdXBpbmdcbk1hcDxJZCwgTGlzdDxDb250YWN0Pj4gY29udGFjdHNCeUFjY291bnQgPSBuZXcgTWFwPElkLCBMaXN0PENvbnRhY3Q+PigpO1xuZm9yIChDb250YWN0IGNvbiA6IGNvbnRhY3RzKSB7XG4gICAgaWYgKCFjb250YWN0c0J5QWNjb3VudC5jb250YWluc0tleShjb24uQWNjb3VudElkKSkge1xuICAgICAgICBjb250YWN0c0J5QWNjb3VudC5wdXQoY29uLkFjY291bnRJZCwgbmV3IExpc3Q8Q29udGFjdD4oKSk7XG4gICAgfVxuICAgIGNvbnRhY3RzQnlBY2NvdW50LmdldChjb24uQWNjb3VudElkKS5hZGQoY29uKTtcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJDb2xsZWN0aW9uIGNob2ljZSBkcml2ZXMgcGVyZm9ybWFuY2UgYW5kIGZ1bmN0aW9uYWxpdHkuIExpc3QgPSBvcmRlciwgU2V0ID0gdW5pcXVlbmVzcywgTWFwID0gcmVsYXRpb25zaGlwcy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJTY2VuYXJpby1iYXNlZCBxdWVzdGlvbnMgdGVzdCBwcmFjdGljYWwgdW5kZXJzdGFuZGluZy4gVGhpbmsgYWJvdXQgdGhlIGJ1c2luZXNzIHJlcXVpcmVtZW50IGZpcnN0LlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDcsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhZHZhbmNlZCcsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkNvZGUgcmV2aWV3OiAnZm9yKEFjY291bnQgYSA6IGFjY291bnRzKSB7IGZvcihDb250YWN0IGMgOiBjb250YWN0cykgeyBpZihjLkFjY291bnRJZCA9PSBhLklkKSB7Li4ufSB9IH0nIC0gd2hhdCdzIHdyb25nP1wiLFxuICAgICAgICBhbnN3ZXI6IFwiTyhuwrIpIHBlcmZvcm1hbmNlIHByb2JsZW0uIFVzZSBNYXAgZm9yIE8obikgc29sdXRpb24uXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIk5lc3RlZCBsb29wcyBjcmVhdGUgcXVhZHJhdGljIHRpbWUgY29tcGxleGl0eS4gV2l0aCAyMDAgYWNjb3VudHMgYW5kIDEwMDAgY29udGFjdHMsIHRoaXMgcGVyZm9ybXMgMjAwLDAwMCBjb21wYXJpc29ucyBpbnN0ZWFkIG9mIHRoZSAxLDIwMCBuZWVkZWQgd2l0aCBwcm9wZXIgZGF0YSBzdHJ1Y3R1cmVzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYC8vIFdyb25nOiBPKG7CsikgLSAyMDAgYWNjb3VudHMgw5cgMTAwMCBjb250YWN0cyA9IDIwMCwwMDAgb3BlcmF0aW9uc1xuZm9yIChBY2NvdW50IGEgOiBhY2NvdW50cykge1xuICAgIGZvciAoQ29udGFjdCBjIDogY29udGFjdHMpIHtcbiAgICAgICAgaWYgKGMuQWNjb3VudElkID09IGEuSWQpIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgLSBidXQgdGhpcyBpcyBWRVJZIHNsb3dcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gUmlnaHQ6IE8obikgLSBHcm91cCBjb250YWN0cyBmaXJzdCwgdGhlbiBsb29rdXBcbk1hcDxJZCwgTGlzdDxDb250YWN0Pj4gY29udGFjdHNCeUFjY291bnQgPSBuZXcgTWFwPElkLCBMaXN0PENvbnRhY3Q+PigpO1xuZm9yIChDb250YWN0IGMgOiBjb250YWN0cykgeyAgLy8gTyhuKSAtIDEwMDAgb3BlcmF0aW9uc1xuICAgIGlmICghY29udGFjdHNCeUFjY291bnQuY29udGFpbnNLZXkoYy5BY2NvdW50SWQpKSB7XG4gICAgICAgIGNvbnRhY3RzQnlBY2NvdW50LnB1dChjLkFjY291bnRJZCwgbmV3IExpc3Q8Q29udGFjdD4oKSk7XG4gICAgfVxuICAgIGNvbnRhY3RzQnlBY2NvdW50LmdldChjLkFjY291bnRJZCkuYWRkKGMpO1xufVxuXG5mb3IgKEFjY291bnQgYSA6IGFjY291bnRzKSB7ICAvLyBPKG4pIC0gMjAwIG9wZXJhdGlvbnNcbiAgICBMaXN0PENvbnRhY3Q+IGFjY291bnRDb250YWN0cyA9IGNvbnRhY3RzQnlBY2NvdW50LmdldChhLklkKTtcbiAgICBpZiAoYWNjb3VudENvbnRhY3RzICE9IG51bGwpIHtcbiAgICAgICAgLy8gUHJvY2VzcyBjb250YWN0cyBmb3IgdGhpcyBhY2NvdW50XG4gICAgfVxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkF2b2lkIG5lc3RlZCBsb29wcyB3aXRoIGxhcmdlIGRhdGFzZXRzLiBHcm91cCBkYXRhIHdpdGggTWFwcyB0byBjb252ZXJ0IE8obsKyKSB0byBPKG4pIG9wZXJhdGlvbnMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiUGVyZm9ybWFuY2UgYW50aS1wYXR0ZXJucyBhcmUgaGVhdmlseSB0ZXN0ZWQuIE5lc3RlZCBsb29wcyA9IHJlZCBmbGFnIGZvciBvcHRpbWl6YXRpb24uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogOCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSBuZWVkIHRvIGdyb3VwIENvbnRhY3RzIGJ5IEFjY291bnRJZCBlZmZpY2llbnRseS4gV2FsayBtZSB0aHJvdWdoIHlvdXIgYXBwcm9hY2guXCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgTWFwPElkLCBMaXN0PENvbnRhY3Q+PiB0byBncm91cCByZWxhdGVkIHJlY29yZHMgaW4gYSBzaW5nbGUgcGFzc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJHcm91cGluZyBpcyBhIGNvbW1vbiBwYXR0ZXJuIGluIFNhbGVzZm9yY2UuIFRoZSBrZXkgaXMgdG8gaXRlcmF0ZSBvbmNlIGFuZCBidWlsZCB0aGUgZ3JvdXBlZCBzdHJ1Y3R1cmUsIGF2b2lkaW5nIG11bHRpcGxlIGxvb2t1cHMgb3IgbmVzdGVkIGxvb3BzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBNYXA8SWQsIExpc3Q8Q29udGFjdD4+IGdyb3VwQ29udGFjdHNCeUFjY291bnQoTGlzdDxDb250YWN0PiBjb250YWN0cykge1xuICAgIE1hcDxJZCwgTGlzdDxDb250YWN0Pj4gY29udGFjdHNCeUFjY291bnQgPSBuZXcgTWFwPElkLCBMaXN0PENvbnRhY3Q+PigpO1xuXG4gICAgZm9yIChDb250YWN0IGNvbiA6IGNvbnRhY3RzKSB7XG4gICAgICAgIC8vIFNraXAgY29udGFjdHMgd2l0aG91dCBBY2NvdW50SWRcbiAgICAgICAgaWYgKGNvbi5BY2NvdW50SWQgPT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBsaXN0IGlmIGZpcnN0IGNvbnRhY3QgZm9yIHRoaXMgYWNjb3VudFxuICAgICAgICBpZiAoIWNvbnRhY3RzQnlBY2NvdW50LmNvbnRhaW5zS2V5KGNvbi5BY2NvdW50SWQpKSB7XG4gICAgICAgICAgICBjb250YWN0c0J5QWNjb3VudC5wdXQoY29uLkFjY291bnRJZCwgbmV3IExpc3Q8Q29udGFjdD4oKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgY29udGFjdCB0byB0aGUgYWNjb3VudCdzIGxpc3RcbiAgICAgICAgY29udGFjdHNCeUFjY291bnQuZ2V0KGNvbi5BY2NvdW50SWQpLmFkZChjb24pO1xuICAgIH1cblxuICAgIHJldHVybiBjb250YWN0c0J5QWNjb3VudDtcbn1cblxuLy8gVXNhZ2UgZXhhbXBsZVxuTWFwPElkLCBMaXN0PENvbnRhY3Q+PiBncm91cGVkID0gZ3JvdXBDb250YWN0c0J5QWNjb3VudChhbGxDb250YWN0cyk7XG5mb3IgKElkIGFjY291bnRJZCA6IGdyb3VwZWQua2V5U2V0KCkpIHtcbiAgICBMaXN0PENvbnRhY3Q+IGFjY291bnRDb250YWN0cyA9IGdyb3VwZWQuZ2V0KGFjY291bnRJZCk7XG4gICAgU3lzdGVtLmRlYnVnKCdBY2NvdW50ICcgKyBhY2NvdW50SWQgKyAnIGhhcyAnICsgYWNjb3VudENvbnRhY3RzLnNpemUoKSArICcgY29udGFjdHMnKTtcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJHcm91cGluZyBwYXR0ZXJuOiBNYXA8S2V5VHlwZSwgTGlzdDxWYWx1ZVR5cGU+Pi4gSXRlcmF0ZSBvbmNlLCBjaGVjayBpZiBrZXkgZXhpc3RzLCBpbml0aWFsaXplIGxpc3QsIGFkZCBpdGVtLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkdyb3VwaW5nIHF1ZXN0aW9ucyBhcmUgY29tbW9uLiBNYXN0ZXIgdGhpcyBwYXR0ZXJuOiBpdCdzIHVzZWQgZXZlcnl3aGVyZSBpbiBTYWxlc2ZvcmNlIGRldmVsb3BtZW50LlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDksXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkEgTGlzdCBtaWdodCBjb250YWluIG51bGxzIGFuZCBkdXBsaWNhdGVzLiBXcml0ZSBjb2RlIHRvIGNsZWFuIGl0IHVwIHNhZmVseS5cIixcbiAgICAgICAgYW5zd2VyOiBcIlVzZSBTZXQgZm9yIGRlZHVwbGljYXRpb24gYW5kIG51bGwgY2hlY2tzIGZvciBjbGVhbmluZ1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJSZWFsLXdvcmxkIGRhdGEgb2Z0ZW4gY29udGFpbnMgbnVsbHMgYW5kIGR1cGxpY2F0ZXMuIENsZWFuaW5nIGNvbGxlY3Rpb25zIHNhZmVseSByZXF1aXJlcyBoYW5kbGluZyBib3RoIGlzc3VlcyB3aXRob3V0IGNhdXNpbmcgZXhjZXB0aW9ucy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgTGlzdDxTdHJpbmc+IGNsZWFuU3RyaW5nTGlzdChMaXN0PFN0cmluZz4gaW5wdXRMaXN0KSB7XG4gICAgaWYgKGlucHV0TGlzdCA9PSBudWxsIHx8IGlucHV0TGlzdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0PFN0cmluZz4oKTtcbiAgICB9XG5cbiAgICBTZXQ8U3RyaW5nPiB1bmlxdWVWYWx1ZXMgPSBuZXcgU2V0PFN0cmluZz4oKTtcblxuICAgIGZvciAoU3RyaW5nIGl0ZW0gOiBpbnB1dExpc3QpIHtcbiAgICAgICAgLy8gU2tpcCBudWxsIGFuZCBibGFuayB2YWx1ZXNcbiAgICAgICAgaWYgKFN0cmluZy5pc05vdEJsYW5rKGl0ZW0pKSB7XG4gICAgICAgICAgICAvLyBTZXQgYXV0b21hdGljYWxseSBoYW5kbGVzIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgIHVuaXF1ZVZhbHVlcy5hZGQoaXRlbS50cmltKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBiYWNrIHRvIExpc3QgaWYgb3JkZXIgbWF0dGVycyBmb3IgY2FsbGVyXG4gICAgcmV0dXJuIG5ldyBMaXN0PFN0cmluZz4odW5pcXVlVmFsdWVzKTtcbn1cblxuLy8gVXNhZ2Vcbkxpc3Q8U3RyaW5nPiBkaXJ0eUxpc3QgPSBuZXcgTGlzdDxTdHJpbmc+eydKb2huJywgbnVsbCwgJ0phbmUnLCAnSm9obicsICcgICcsICdCb2InfTtcbkxpc3Q8U3RyaW5nPiBjbGVhbkxpc3QgPSBjbGVhblN0cmluZ0xpc3QoZGlydHlMaXN0KTtcbi8vIFJlc3VsdDogWydKb2huJywgJ0phbmUnLCAnQm9iJ10gLSBubyBudWxscywgbm8gZHVwbGljYXRlcywgdHJpbW1lZGAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkNvbGxlY3Rpb24gY2xlYW5pbmc6IG51bGwgY2hlY2tzIHByZXZlbnQgZXhjZXB0aW9ucywgU2V0cyByZW1vdmUgZHVwbGljYXRlcyBhdXRvbWF0aWNhbGx5LlwiLFxuICAgICAgICBleGFtVGlwOiBcIkRhdGEgdmFsaWRhdGlvbiBzY2VuYXJpb3MgYXJlIGZyZXF1ZW50LiBBbHdheXMgaGFuZGxlIG51bGwgaW5wdXQgZ3JhY2VmdWxseS5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxMCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIllvdSdyZSBwcm9jZXNzaW5nIE9wcG9ydHVuaXR5IGRhdGEgYW5kIG5lZWQgZmFzdCBsb29rdXBzIGJ5IFN0YWdlLiBXaGF0IGNvbGxlY3Rpb24gc3RyYXRlZ3kgZG8geW91IHVzZT9cIixcbiAgICAgICAgYW5zd2VyOiBcIk1hcDxTdHJpbmcsIExpc3Q8T3Bwb3J0dW5pdHk+PiB0byBncm91cCBieSBzdGFnZSB3aXRoIGZhc3QgYWNjZXNzXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkJ1c2luZXNzIHJlcG9ydGluZyBvZnRlbiByZXF1aXJlcyBncm91cGluZyByZWNvcmRzIGJ5IGZpZWxkIHZhbHVlcy4gTWFwcyBwcm92aWRlIGJvdGggZmFzdCBhY2Nlc3MgYW5kIGxvZ2ljYWwgZ3JvdXBpbmcgZm9yIGFuYWx5c2lzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBNYXA8U3RyaW5nLCBMaXN0PE9wcG9ydHVuaXR5Pj4gZ3JvdXBPcHBvcnR1bml0aWVzQnlTdGFnZShMaXN0PE9wcG9ydHVuaXR5PiBvcHBzKSB7XG4gICAgTWFwPFN0cmluZywgTGlzdDxPcHBvcnR1bml0eT4+IG9wcHNCeVN0YWdlID0gbmV3IE1hcDxTdHJpbmcsIExpc3Q8T3Bwb3J0dW5pdHk+PigpO1xuXG4gICAgZm9yIChPcHBvcnR1bml0eSBvcHAgOiBvcHBzKSB7XG4gICAgICAgIFN0cmluZyBzdGFnZSA9IG9wcC5TdGFnZU5hbWUgPz8gJ1Vua25vd24nOyAgLy8gSGFuZGxlIG51bGwgc3RhZ2VzXG5cbiAgICAgICAgaWYgKCFvcHBzQnlTdGFnZS5jb250YWluc0tleShzdGFnZSkpIHtcbiAgICAgICAgICAgIG9wcHNCeVN0YWdlLnB1dChzdGFnZSwgbmV3IExpc3Q8T3Bwb3J0dW5pdHk+KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3Bwc0J5U3RhZ2UuZ2V0KHN0YWdlKS5hZGQob3BwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3Bwc0J5U3RhZ2U7XG59XG5cbi8vIEJ1c2luZXNzIGxvZ2ljIHVzYWdlXG5NYXA8U3RyaW5nLCBMaXN0PE9wcG9ydHVuaXR5Pj4gb3Bwc0J5U3RhZ2UgPSBncm91cE9wcG9ydHVuaXRpZXNCeVN0YWdlKG9wcG9ydHVuaXRpZXMpO1xuXG4vLyBGYXN0IGFuYWx5c2lzXG5MaXN0PE9wcG9ydHVuaXR5PiBjbG9zZWRXb24gPSBvcHBzQnlTdGFnZS5nZXQoJ0Nsb3NlZCBXb24nKTtcbkxpc3Q8T3Bwb3J0dW5pdHk+IG5lZ290aWF0aW9uID0gb3Bwc0J5U3RhZ2UuZ2V0KCdOZWdvdGlhdGlvbi9SZXZpZXcnKTtcblxuU3lzdGVtLmRlYnVnKCdDbG9zZWQgV29uIGNvdW50OiAnICsgKGNsb3NlZFdvbj8uc2l6ZSgpID8/IDApKTtcblN5c3RlbS5kZWJ1ZygnSW4gTmVnb3RpYXRpb246ICcgKyAobmVnb3RpYXRpb24/LnNpemUoKSA/PyAwKSk7YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiR3JvdXBpbmcgZW5hYmxlcyBmYXN0IGJ1c2luZXNzIGFuYWx5c2lzLiBNYXAgc3RydWN0dXJlIG1pcnJvcnMgYnVzaW5lc3MgbG9naWMgZm9yIGludHVpdGl2ZSBhY2Nlc3MuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiQnVzaW5lc3Mgc2NlbmFyaW8gcXVlc3Rpb25zIHRlc3QgcHJhY3RpY2FsIGFwcGxpY2F0aW9uLiBUaGluayBhYm91dCBob3cgYnVzaW5lc3MgdXNlcnMgd291bGQgd2FudCB0byBhY2Nlc3MgdGhlIGRhdGEuXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG5cbiAgJ2NvbnRyb2wtZmxvdy1hbmQtbG9vcHMnOiB7XG4gICAgdGl0bGU6ICdDb250cm9sIEZsb3cgYW5kIExvb3BzJyxcbiAgICBvdmVydmlldzogJ01hc3RlciBkZWNpc2lvbi1tYWtpbmcgaW4geW91ciBjb2RlLiBOb3cgdGhhdCB5b3UgaGF2ZSBWYXJpYWJsZXMgKHNpbmdsZSB2YWx1ZXMpIGFuZCBDb2xsZWN0aW9ucyAobXVsdGlwbGUgdmFsdWVzKSwgbGVhcm4gdG8gbWFrZSBERUNJU0lPTlMgYWJvdXQgdGhhdCBkYXRhLiBDb250cm9sIGZsb3cgaXMgd2hlcmUgYnVzaW5lc3MgbG9naWMgbGl2ZXMgLSBldmVyeSBcImlmIHRoaXMgdGhlbiB0aGF0XCIgcnVsZSBpbiBTYWxlc2ZvcmNlLiBUaGlzIGRpcmVjdGx5IGxlYWRzIHRvIENsYXNzZXMgKG9yZ2FuaXppbmcgZGVjaXNpb24gbG9naWMpIGFuZCBUcmlnZ2VycyAoYXV0b21hdGVkIGRlY2lzaW9ucykuJyxcbiAgICBjb2RlRXhhbXBsZXM6IFtcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdEZWNpc2lvbiBNYWtpbmcgd2l0aCBCdXNpbmVzcyBMb2dpYycsXG4gICAgICAgIGNvZGU6IGBwdWJsaWMgY2xhc3MgQ29udHJvbEZsb3dEZW1vIHtcbiAgICAvLyDinIUgQlVJTERJTkcgT046IENvbGxlY3Rpb25zIGZyb20gcHJldmlvdXMgdG9waWNcbiAgICBwdWJsaWMgdm9pZCBwcm9jZXNzTGVhZHMoTGlzdDxMZWFkPiBsZWFkcykge1xuICAgICAgICAvLyDinIUgTkVXIENPTkNFUFQ6IERlY2lzaW9uIG1ha2luZyB3aXRoIGNvbGxlY3RlZCBkYXRhXG4gICAgICAgIExpc3Q8TGVhZD4gaG90TGVhZHMgPSBuZXcgTGlzdDxMZWFkPigpO1xuICAgICAgICBMaXN0PExlYWQ+IGNvbGRMZWFkcyA9IG5ldyBMaXN0PExlYWQ+KCk7XG5cbiAgICAgICAgLy8g4pyFIEVOSEFOQ0VEIEZPUiBMT09QOiBQcm9jZXNzIGVhY2ggaXRlbSBpbiBjb2xsZWN0aW9uXG4gICAgICAgIGZvciAoTGVhZCBsZWFkIDogbGVhZHMpIHtcbiAgICAgICAgICAgIC8vIOKchSBDT05ORUNUSU9OOiBTYW1lIGZvciBsb29wIHBhdHRlcm4geW91J2xsIHVzZSBldmVyeXdoZXJlXG4gICAgICAgICAgICAvLyDinIUgV0hZIGVuaGFuY2VkIGZvcjogU2FmZXIgdGhhbiBpbmRleCBsb29wcywgbm8gb3V0LW9mLWJvdW5kc1xuXG4gICAgICAgICAgICAvLyDinIUgQ09ORElUSU9OQUwgTE9HSUM6IEJ1c2luZXNzIGRlY2lzaW9uIG1ha2luZ1xuICAgICAgICAgICAgaWYgKGxlYWQuQW5udWFsUmV2ZW51ZSAhPSBudWxsICYmIGxlYWQuQW5udWFsUmV2ZW51ZSA+IDEwMDAwMDApIHtcbiAgICAgICAgICAgICAgICAvLyDinIUgTlVMTCBTQUZFVFk6IEFsd2F5cyBjaGVjayBudWxsIGZpcnN0IChmcm9tIFZhcmlhYmxlcyB0b3BpYylcbiAgICAgICAgICAgICAgICAvLyDinIUgQlVTSU5FU1MgTE9HSUM6IENhdGVnb3JpemUgaGlnaC12YWx1ZSBwcm9zcGVjdHNcbiAgICAgICAgICAgICAgICBob3RMZWFkcy5hZGQobGVhZCk7XG5cbiAgICAgICAgICAgICAgICAvLyDinIUgTkVTVEVEIENPTkRJVElPTlM6IE1vcmUgY29tcGxleCBkZWNpc2lvbiB0cmVlc1xuICAgICAgICAgICAgICAgIGlmIChsZWFkLkluZHVzdHJ5ID09ICdUZWNobm9sb2d5Jykge1xuICAgICAgICAgICAgICAgICAgICBsZWFkLlJhdGluZyA9ICdIb3QnO1xuICAgICAgICAgICAgICAgICAgICAvLyDinIUgQ09OTkVDVElPTjogVGhpcyBwYXR0ZXJuIGNydWNpYWwgaW4gVHJpZ2dlcnMgdG9waWNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlYWQuQW5udWFsUmV2ZW51ZSAhPSBudWxsICYmIGxlYWQuQW5udWFsUmV2ZW51ZSA+IDEwMDAwMCkge1xuICAgICAgICAgICAgICAgIC8vIOKchSBFTFNFIElGOiBIYW5kbGUgbXVsdGlwbGUgY29uZGl0aW9ucyBlZmZpY2llbnRseVxuICAgICAgICAgICAgICAgIGxlYWQuUmF0aW5nID0gJ1dhcm0nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyDinIUgRUxTRTogQ2F0Y2gtYWxsIGZvciByZW1haW5pbmcgY2FzZXNcbiAgICAgICAgICAgICAgICBjb2xkTGVhZHMuYWRkKGxlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g4pyFIENPTkRJVElPTkFMIFBST0NFU1NJTkc6IE9ubHkgYWN0IGlmIGRhdGEgZXhpc3RzXG4gICAgICAgIGlmICghaG90TGVhZHMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAvLyDwn5KhIE5FWFQgVE9QSUM6IFlvdSdsbCBvcmdhbml6ZSB0aGlzIGxvZ2ljIGludG8gQ2xhc3Nlc1xuICAgICAgICAgICAgcHJvY2Vzc0hvdExlYWRzKGhvdExlYWRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCBwcm9jZXNzSG90TGVhZHMoTGlzdDxMZWFkPiBsZWFkcykge1xuICAgICAgICBmb3IgKExlYWQgbGVhZCA6IGxlYWRzKSB7XG4gICAgICAgICAgICBsZWFkLlN0YXR1cyA9ICdXb3JraW5nIC0gQ29udGFjdGVkJztcbiAgICAgICAgfVxuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0Fsd2F5cyBjaGVjayBmb3IgbnVsbCBiZWZvcmUgY29tcGFyaW5nIHZhbHVlcy4gVXNlIGV4cGxpY2l0IGJvb2xlYW4gY29tcGFyaXNvbnMgKD09IHRydWUpIGZvciBudWxsLXNhZmUgbG9naWMgd2l0aCBCb29sZWFuIGZpZWxkcyB0aGF0IGNhbiBiZSBudWxsLidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnU3dpdGNoIFN0YXRlbWVudHMgYW5kIEFkdmFuY2VkIFBhdHRlcm5zJyxcbiAgICAgICAgY29kZTogYHB1YmxpYyBjbGFzcyBTd2l0Y2hQYXR0ZXJucyB7XG4gICAgLy8g4pyFIFNXSVRDSCBTVEFURU1FTlQ6IENsZWFuIG11bHRpcGxlIGV4YWN0IGNvbXBhcmlzb25zXG4gICAgcHVibGljIFN0cmluZyBjYXRlZ29yaXplQnlTb3VyY2UoTGVhZCBsZWFkKSB7XG4gICAgICAgIC8vIOKchSBXSEVOIFRPIFVTRTogTXVsdGlwbGUgZXhhY3QgdmFsdWUgY29tcGFyaXNvbnMgKG5vdCByYW5nZXMpXG4gICAgICAgIHN3aXRjaCBvbiBsZWFkLkxlYWRTb3VyY2Uge1xuICAgICAgICAgICAgd2hlbiAnV2ViJyB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdEaWdpdGFsIE1hcmtldGluZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGVuICdQaG9uZSBJbnF1aXJ5JywgJ0NvbGQgQ2FsbCcge1xuICAgICAgICAgICAgICAgIC8vIOKchSBNVUxUSVBMRSBWQUxVRVM6IENvbW1hLXNlcGFyYXRlZCBpbiBzaW5nbGUgY2FzZVxuICAgICAgICAgICAgICAgIHJldHVybiAnRGlyZWN0IFNhbGVzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoZW4gJ1BhcnRuZXIgUmVmZXJyYWwnIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0NoYW5uZWwgUGFydG5lcnMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hlbiBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyDinIUgREVGQVVMVCBDQVNFOiBIYW5kbGUgdW5tYXRjaGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHJldHVybiAnVW5rbm93biBTb3VyY2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIPCfkqEgTkVYVCBUT1BJQzogVGhpcyBkZWNpc2lvbiBsb2dpYyB3aWxsIGJlIHJldXNlZCBpbiBDbGFzc2VzXG4gICAgfVxuXG4gICAgLy8g4pyFIEVBUkxZIEVYSVQgUEFUVEVSTlM6IEltcHJvdmUgcGVyZm9ybWFuY2VcbiAgICBwdWJsaWMgdm9pZCBwcm9jZXNzT3Bwb3J0dW5pdGllcyhMaXN0PE9wcG9ydHVuaXR5PiBvcHBzKSB7XG4gICAgICAgIGZvciAoT3Bwb3J0dW5pdHkgb3BwIDogb3Bwcykge1xuICAgICAgICAgICAgLy8g4pyFIEdVQVJEIENMQVVTRTogRWFybHkgZXhpdCBmb3IgaW52YWxpZCBkYXRhXG4gICAgICAgICAgICBpZiAob3BwLkFtb3VudCA9PSBudWxsIHx8IG9wcC5BbW91bnQgPD0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOKchSBCVVNJTkVTUyBMT0dJQzogT25seSBwcm9jZXNzIHZhbGlkIG9wcG9ydHVuaXRpZXNcbiAgICAgICAgICAgIGlmIChvcHAuU3RhZ2VOYW1lID09ICdDbG9zZWQgV29uJykge1xuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3Mgd29uIG9wcG9ydHVuaXR5XG4gICAgICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdQcm9jZXNzaW5nIHdvbiBvcHA6ICcgKyBvcHAuQW1vdW50KTtcblxuICAgICAgICAgICAgICAgIC8vIOKchSBCUkVBSzogRXhpdCBsb29wIGlmIHdlIGZvdW5kIHdoYXQgd2UgbmVlZFxuICAgICAgICAgICAgICAgIGlmIChvcHAuQW1vdW50ID4gMTAwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBTeXN0ZW0uZGVidWcoJ0ZvdW5kIGxhcmdlIGRlYWwsIHN0b3BwaW5nIHNlYXJjaCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59YCxcbiAgICAgICAgZXhwbGFuYXRpb246ICdDaG9vc2UgdGhlIHJpZ2h0IGxvb3AgdHlwZTogZW5oYW5jZWQgZm9yIHdoZW4gcHJvY2Vzc2luZyBhbGwgZWxlbWVudHMsIHRyYWRpdGlvbmFsIGZvciB3aGVuIHlvdSBuZWVkIGluZGV4ZXMsIHdoaWxlIHdoZW4gdGhlIGl0ZXJhdGlvbiBjb3VudCBkZXBlbmRzIG9uIGNvbmRpdGlvbnMuJ1xuICAgICAgfVxuICAgIF0sXG4gICAgcHJhY3RpY2VRdWVzdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYWR2YW5jZWQnLFxuICAgICAgICBxdWVzdGlvbjogXCJZb3Ugc2VlIG5lc3RlZCBmb3IgbG9vcHMgcHJvY2Vzc2luZyAxMDAwKyByZWNvcmRzIGluIGEgdHJpZ2dlci4gV2hhdCdzIHRoZSBwZXJmb3JtYW5jZSBpc3N1ZSBhbmQgaG93IGRvIHlvdSBmaXggaXQ/XCIsXG4gICAgICAgIGFuc3dlcjogXCJPKG7CsikgY29tcGxleGl0eSBjYXVzaW5nIENQVSB0aW1lb3V0LiBVc2UgTWFwcyB0byBmbGF0dGVuIHRvIE8obikuXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIk5lc3RlZCBsb29wcyBjcmVhdGUgcXVhZHJhdGljIHRpbWUgY29tcGxleGl0eS4gV2l0aCAxMDAwIHJlY29yZHMsIHRoaXMgbWVhbnMgMSwwMDAsMDAwIG9wZXJhdGlvbnMuIFRoaXMgcXVpY2tseSBoaXRzIENQVSB0aW1lb3V0IGxpbWl0cyBpbiBTYWxlc2ZvcmNlLiBUaGUgc29sdXRpb24gaXMgdG8gdXNlIE1hcHMgZm9yIGdyb3VwaW5nIGRhdGEuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gV3Jvbmc6IE8obsKyKSAtIDEwMDAgw5cgMTAwMCA9IDEsMDAwLDAwMCBvcGVyYXRpb25zXG5mb3IgKEFjY291bnQgYWNjIDogYWNjb3VudHMpIHtcbiAgICBmb3IgKENvbnRhY3QgY29uIDogY29udGFjdHMpIHtcbiAgICAgICAgaWYgKGNvbi5BY2NvdW50SWQgPT0gYWNjLklkKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIC0gYnV0IFZFUlkgc2xvd1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBSaWdodDogTyhuKSAtIEdyb3VwIGZpcnN0LCB0aGVuIHByb2Nlc3Ncbk1hcDxJZCwgTGlzdDxDb250YWN0Pj4gY29udGFjdHNCeUFjY291bnQgPSBuZXcgTWFwPElkLCBMaXN0PENvbnRhY3Q+PigpO1xuZm9yIChDb250YWN0IGNvbiA6IGNvbnRhY3RzKSB7ICAvLyAxMDAwIG9wZXJhdGlvbnNcbiAgICBpZiAoIWNvbnRhY3RzQnlBY2NvdW50LmNvbnRhaW5zS2V5KGNvbi5BY2NvdW50SWQpKSB7XG4gICAgICAgIGNvbnRhY3RzQnlBY2NvdW50LnB1dChjb24uQWNjb3VudElkLCBuZXcgTGlzdDxDb250YWN0PigpKTtcbiAgICB9XG4gICAgY29udGFjdHNCeUFjY291bnQuZ2V0KGNvbi5BY2NvdW50SWQpLmFkZChjb24pO1xufVxuXG5mb3IgKEFjY291bnQgYWNjIDogYWNjb3VudHMpIHsgIC8vIDEwMDAgbW9yZSBvcGVyYXRpb25zXG4gICAgTGlzdDxDb250YWN0PiByZWxhdGVkQ29udGFjdHMgPSBjb250YWN0c0J5QWNjb3VudC5nZXQoYWNjLklkKTtcbiAgICAvLyBQcm9jZXNzIGVmZmljaWVudGx5XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiTmVzdGVkIGxvb3BzIGFyZSBhIHBlcmZvcm1hbmNlIGtpbGxlci4gQWx3YXlzIGZsYXR0ZW4gdG8gc2luZ2xlIGxvb3BzIHdpdGggTWFwcyBmb3IgZ3JvdXBpbmcuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHF1ZXN0aW9ucyBhcmUgY29tbW9uLiBOZXN0ZWQgbG9vcHMgPSBpbW1lZGlhdGUgcmVkIGZsYWcgZm9yIE8obsKyKSBjb21wbGV4aXR5LlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnLFxuICAgICAgICBxdWVzdGlvbjogXCJBIGRldmVsb3BlciB1c2VzIGBpZiAobGVhZC5Db21wYW55LnN0YXJ0c1dpdGgoJ0FjbWUnKSlgIC0gd2hhdCBjb3VsZCBnbyB3cm9uZyBhbmQgaG93IGRvIHlvdSBmaXggaXQ/XCIsXG4gICAgICAgIGFuc3dlcjogXCJOdWxsUG9pbnRlckV4Y2VwdGlvbiBpZiBDb21wYW55IGlzIG51bGwuIFVzZSBudWxsLXNhZmUgbmF2aWdhdGlvbi5cIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiRmllbGQgdmFsdWVzIGluIFNhbGVzZm9yY2UgY2FuIGJlIG51bGwuIENhbGxpbmcgbWV0aG9kcyBkaXJlY3RseSBvbiBwb3RlbnRpYWxseSBudWxsIGZpZWxkcyB0aHJvd3MgTnVsbFBvaW50ZXJFeGNlcHRpb24gYXQgcnVudGltZS4gQWx3YXlzIGNoZWNrIGZvciBudWxsIGZpcnN0IG9yIHVzZSBzYWZlIG5hdmlnYXRpb24uXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gV3JvbmcgLSB0aHJvd3MgTlBFIGlmIENvbXBhbnkgaXMgbnVsbFxuaWYgKGxlYWQuQ29tcGFueS5zdGFydHNXaXRoKCdBY21lJykpIHtcbiAgICAvLyBQcm9jZXNzXG59XG5cbi8vIE9wdGlvbiAxOiBUcmFkaXRpb25hbCBudWxsIGNoZWNrXG5pZiAobGVhZC5Db21wYW55ICE9IG51bGwgJiYgbGVhZC5Db21wYW55LnN0YXJ0c1dpdGgoJ0FjbWUnKSkge1xuICAgIC8vIFByb2Nlc3Mgc2FmZWx5XG59XG5cbi8vIE9wdGlvbiAyOiBTYWZlIG5hdmlnYXRpb24gKG1vZGVybiBBcGV4KVxuaWYgKGxlYWQuQ29tcGFueT8uc3RhcnRzV2l0aCgnQWNtZScpID09IHRydWUpIHtcbiAgICAvLyBQcm9jZXNzIHNhZmVseVxufVxuXG4vLyBPcHRpb24gMzogTnVsbC1jb2FsZXNjaW5nIGZvciBkZWZhdWx0XG5TdHJpbmcgY29tcGFueSA9IGxlYWQuQ29tcGFueSA/PyAnJztcbmlmIChjb21wYW55LnN0YXJ0c1dpdGgoJ0FjbWUnKSkge1xuICAgIC8vIFByb2Nlc3Mgc2FmZWx5XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQWx3YXlzIGFzc3VtZSBTYWxlc2ZvcmNlIGZpZWxkcyBjYW4gYmUgbnVsbC4gVXNlIG51bGwgY2hlY2tzIG9yIHNhZmUgbmF2aWdhdGlvbiBiZWZvcmUgY2FsbGluZyBtZXRob2RzLlwiLFxuICAgICAgICBleGFtVGlwOiBcIk51bGwgc2FmZXR5IGlzIGhlYXZpbHkgdGVzdGVkLiBMb29rIGZvciBtZXRob2QgY2FsbHMgb24gZmllbGRzIHdpdGhvdXQgbnVsbCBjaGVja3MuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hlbiB3b3VsZCB5b3UgY2hvb3NlIHN3aXRjaCBvdmVyIGlmL2Vsc2Ugc3RhdGVtZW50cz9cIixcbiAgICAgICAgYW5zd2VyOiBcIlN3aXRjaCBmb3IgbXVsdGlwbGUgZXhhY3QgdmFsdWUgY29tcGFyaXNvbnMsIGlmL2Vsc2UgZm9yIHJhbmdlcyBvciBjb21wbGV4IGNvbmRpdGlvbnNcIixcbiAgICAgICAgZXhwbGFuYXRpb246IFwiU3dpdGNoIHN0YXRlbWVudHMgYXJlIGNsZWFuZXIgYW5kIG1vcmUgcGVyZm9ybWFudCBmb3IgY29tcGFyaW5nIGEgc2luZ2xlIHZhcmlhYmxlIGFnYWluc3QgbXVsdGlwbGUgZXhhY3QgdmFsdWVzLiBVc2UgaWYvZWxzZSBmb3IgcmFuZ2UgY29tcGFyaXNvbnMsIGNvbXBsZXggYm9vbGVhbiBsb2dpYywgb3Igd2hlbiB5b3UgbmVlZCBkaWZmZXJlbnQgdmFyaWFibGVzIGluIGVhY2ggY29uZGl0aW9uLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYC8vIEdvb2QgdXNlIG9mIHN3aXRjaDogZXhhY3QgdmFsdWUgbWF0Y2hpbmdcbnN3aXRjaCBvbiBsZWFkLlN0YXR1cyB7XG4gICAgd2hlbiAnT3BlbiAtIE5vdCBDb250YWN0ZWQnIHtcbiAgICAgICAgbGVhZC5Qcmlvcml0eSA9ICdIaWdoJztcbiAgICB9XG4gICAgd2hlbiAnV29ya2luZyAtIENvbnRhY3RlZCcge1xuICAgICAgICBsZWFkLlByaW9yaXR5ID0gJ01lZGl1bSc7XG4gICAgfVxuICAgIHdoZW4gJ0Nsb3NlZCAtIENvbnZlcnRlZCcsICdDbG9zZWQgLSBOb3QgQ29udmVydGVkJyB7XG4gICAgICAgIGxlYWQuUHJpb3JpdHkgPSAnTG93JztcbiAgICB9XG4gICAgd2hlbiBlbHNlIHtcbiAgICAgICAgbGVhZC5Qcmlvcml0eSA9ICdVbmtub3duJztcbiAgICB9XG59XG5cbi8vIEJldHRlciB3aXRoIGlmL2Vsc2U6IHJhbmdlIGNvbXBhcmlzb25zXG5pZiAobGVhZC5Bbm51YWxSZXZlbnVlID4gMTAwMDAwMCkge1xuICAgIGxlYWQuUmF0aW5nID0gJ0hvdCc7XG59IGVsc2UgaWYgKGxlYWQuQW5udWFsUmV2ZW51ZSA+IDEwMDAwMCkge1xuICAgIGxlYWQuUmF0aW5nID0gJ1dhcm0nO1xufSBlbHNlIHtcbiAgICBsZWFkLlJhdGluZyA9ICdDb2xkJztcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJTd2l0Y2ggPSBleGFjdCB2YWx1ZXMsIGlmL2Vsc2UgPSByYW5nZXMvY29tcGxleCBsb2dpYy4gQ2hvb3NlIGJhc2VkIG9uIHdoYXQgeW91J3JlIGNvbXBhcmluZy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJDb250cm9sIHN0cnVjdHVyZSBjaG9pY2UgcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiBhcHByb3ByaWF0ZSB1c2FnZSBwYXR0ZXJucy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA0LFxuICAgICAgICBkaWZmaWN1bHR5OiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgICAgcXVlc3Rpb246IFwiRXhwbGFpbiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGBicmVha2AgYW5kIGBjb250aW51ZWAgd2l0aCBleGFtcGxlcy5cIixcbiAgICAgICAgYW5zd2VyOiBcImBicmVha2AgZXhpdHMgdGhlIGVudGlyZSBsb29wLCBgY29udGludWVgIHNraXBzIHRvIHRoZSBuZXh0IGl0ZXJhdGlvblwiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJUaGVzZSBjb250cm9sIHN0YXRlbWVudHMgY2hhbmdlIGxvb3AgZXhlY3V0aW9uIGZsb3cuIGBicmVha2AgaW1tZWRpYXRlbHkgZXhpdHMgdGhlIGxvb3AgZW50aXJlbHksIHdoaWxlIGBjb250aW51ZWAgc2tpcHMgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGl0ZXJhdGlvbiBhbmQgbW92ZXMgdG8gdGhlIG5leHQgaXRlcmF0aW9uLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYExpc3Q8QWNjb3VudD4gYWNjb3VudHMgPSBbU0VMRUNUIElkLCBOYW1lLCBBbm51YWxSZXZlbnVlIEZST00gQWNjb3VudF07XG5cbi8vIFVzaW5nIGNvbnRpbnVlIC0gc2tpcCBpbnZhbGlkIHJlY29yZHNcbmZvciAoQWNjb3VudCBhY2MgOiBhY2NvdW50cykge1xuICAgIGlmIChhY2MuQW5udWFsUmV2ZW51ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgYWNjb3VudCwgZ28gdG8gbmV4dCBpdGVyYXRpb25cbiAgICB9XG5cbiAgICAvLyBUaGlzIGNvZGUgb25seSBydW5zIGZvciBhY2NvdW50cyB3aXRoIHJldmVudWVcbiAgICBhY2MuUmF0aW5nID0gYWNjLkFubnVhbFJldmVudWUgPiAxMDAwMDAwID8gJ0hvdCcgOiAnQ29sZCc7XG59XG5cbi8vIFVzaW5nIGJyZWFrIC0gZXhpdCB3aGVuIGZvdW5kXG5mb3IgKEFjY291bnQgYWNjIDogYWNjb3VudHMpIHtcbiAgICBpZiAoYWNjLk5hbWUgPT0gJ1RhcmdldCBBY2NvdW50Jykge1xuICAgICAgICBTeXN0ZW0uZGVidWcoJ0ZvdW5kIHRhcmdldCBhY2NvdW50Jyk7XG4gICAgICAgIGJyZWFrOyAvLyBFeGl0IGxvb3AgY29tcGxldGVseSwgZG9uJ3QgcHJvY2VzcyByZW1haW5pbmcgYWNjb3VudHNcbiAgICB9XG5cbiAgICAvLyBUaGlzIGNvZGUgcnVucyB1bnRpbCB0YXJnZXQgaXMgZm91bmRcbiAgICBTeXN0ZW0uZGVidWcoJ1N0aWxsIHNlYXJjaGluZzogJyArIGFjYy5OYW1lKTtcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJjb250aW51ZSA9IHNraXAgY3VycmVudCBpdGVyYXRpb24sIGJyZWFrID0gZXhpdCBlbnRpcmUgbG9vcC4gVXNlIGNvbnRpbnVlIGZvciBmaWx0ZXJpbmcsIGJyZWFrIGZvciBlYXJseSB0ZXJtaW5hdGlvbi5cIixcbiAgICAgICAgZXhhbVRpcDogXCJMb29wIGNvbnRyb2wgcXVlc3Rpb25zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiBmbG93IG1vZGlmaWNhdGlvbi4gUmVtZW1iZXI6IGNvbnRpbnVlIHNraXBzLCBicmVhayBleGl0cy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA1LFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJZb3UgbmVlZCB0byBwcm9jZXNzIG9ubHkgdGhlIGZpcnN0IDUwIHJlY29yZHMgaW4gYSBsaXN0LiBTaG93IHR3byBhcHByb2FjaGVzLlwiLFxuICAgICAgICBhbnN3ZXI6IFwiVXNlIExJTUlUIGluIFNPUUwgcXVlcnkgb3IgdHJhZGl0aW9uYWwgZm9yIGxvb3Agd2l0aCBjb3VudGVyXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIldoZW4geW91IG9ubHkgbmVlZCBhIHN1YnNldCBvZiByZWNvcmRzLCBpdCdzIG1vcmUgZWZmaWNpZW50IHRvIGxpbWl0IGF0IHRoZSBxdWVyeSBsZXZlbC4gSWYgeW91IGFscmVhZHkgaGF2ZSB0aGUgZnVsbCBsaXN0LCB1c2UgYSB0cmFkaXRpb25hbCBmb3IgbG9vcCB3aXRoIGluZGV4IGNvbnRyb2wuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gQXBwcm9hY2ggMTogTGltaXQgYXQgcXVlcnkgbGV2ZWwgKEJFU1QpXG5MaXN0PExlYWQ+IGxlYWRzID0gW1NFTEVDVCBJZCwgTmFtZSBGUk9NIExlYWQgT1JERVIgQlkgQ3JlYXRlZERhdGUgTElNSVQgNTBdO1xuZm9yIChMZWFkIGxlYWQgOiBsZWFkcykge1xuICAgIC8vIFByb2Nlc3MgYWxsIDUwIHJlY29yZHNcbn1cblxuLy8gQXBwcm9hY2ggMjogTGltaXQgZHVyaW5nIHByb2Nlc3Npbmdcbkxpc3Q8TGVhZD4gYWxsTGVhZHMgPSBbU0VMRUNUIElkLCBOYW1lIEZST00gTGVhZCBPUkRFUiBCWSBDcmVhdGVkRGF0ZV07XG5mb3IgKEludGVnZXIgaSA9IDA7IGkgPCBNYXRoLm1pbihhbGxMZWFkcy5zaXplKCksIDUwKTsgaSsrKSB7XG4gICAgTGVhZCBsZWFkID0gYWxsTGVhZHMuZ2V0KGkpO1xuICAgIC8vIFByb2Nlc3Mgb25seSBmaXJzdCA1MFxufVxuXG4vLyBBcHByb2FjaCAzOiBFbmhhbmNlZCBmb3Igd2l0aCBjb3VudGVyXG5MaXN0PExlYWQ+IGFsbExlYWRzID0gW1NFTEVDVCBJZCwgTmFtZSBGUk9NIExlYWQgT1JERVIgQlkgQ3JlYXRlZERhdGVdO1xuSW50ZWdlciBjb3VudCA9IDA7XG5mb3IgKExlYWQgbGVhZCA6IGFsbExlYWRzKSB7XG4gICAgaWYgKGNvdW50ID49IDUwKSBicmVhaztcblxuICAgIC8vIFByb2Nlc3MgcmVjb3JkXG4gICAgY291bnQrKztcbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJBbHdheXMgcHJlZmVyIGxpbWl0aW5nIGF0IHRoZSBkYXRhYmFzZSBsZXZlbCAoU09RTCBMSU1JVCkgcmF0aGVyIHRoYW4gaW4gQXBleCBsb29wcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlwiLFxuICAgICAgICBleGFtVGlwOiBcIlF1ZXJ5IG9wdGltaXphdGlvbiBxdWVzdGlvbnMgZmF2b3IgZGF0YWJhc2UtbGV2ZWwgZmlsdGVyaW5nIG92ZXIgQXBleC1sZXZlbCBmaWx0ZXJpbmcuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNixcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoYXQncyB3cm9uZyB3aXRoIGBpZiAoc3RyaW5nVmFsdWUgPT0gbnVsbCB8fCBzdHJpbmdWYWx1ZSA9PSAnJykgey4uLn1gIGFuZCBob3cgZG8geW91IGltcHJvdmUgaXQ/XCIsXG4gICAgICAgIGFuc3dlcjogXCJWZXJib3NlIGFuZCBkb2Vzbid0IGhhbmRsZSB3aGl0ZXNwYWNlLiBVc2UgU3RyaW5nLmlzQmxhbmsoKSBmb3IgY29tcHJlaGVuc2l2ZSBjaGVja2luZ1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJNYW51YWwgbnVsbCBhbmQgZW1wdHkgY2hlY2tpbmcgaXMgdmVyYm9zZSBhbmQgZXJyb3ItcHJvbmUuIFN0cmluZy5pc0JsYW5rKCkgaGFuZGxlcyBudWxsLCBlbXB0eSBzdHJpbmcsIGFuZCB3aGl0ZXNwYWNlLW9ubHkgc3RyaW5ncyBpbiBvbmUgY2FsbCwgbWFraW5nIGNvZGUgY2xlYW5lciBhbmQgbW9yZSByb2J1c3QuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgU3RyaW5nIHN0cmluZ1ZhbHVlID0gZ2V0VmFsdWVGcm9tU29tZXdoZXJlKCk7XG5cbi8vIFZlcmJvc2UgYW5kIGluY29tcGxldGVcbmlmIChzdHJpbmdWYWx1ZSA9PSBudWxsIHx8IHN0cmluZ1ZhbHVlID09ICcnKSB7XG4gICAgLy8gRG9lc24ndCBjYXRjaCAnICAgJyAod2hpdGVzcGFjZSBvbmx5KVxufVxuXG4vLyBCZXR0ZXIgYnV0IHN0aWxsIHZlcmJvc2VcbmlmIChzdHJpbmdWYWx1ZSA9PSBudWxsIHx8IHN0cmluZ1ZhbHVlLnRyaW0oKS5sZW5ndGgoKSA9PSAwKSB7XG4gICAgLy8gSGFuZGxlcyB3aGl0ZXNwYWNlIGJ1dCB2ZXJib3NlXG59XG5cbi8vIEJlc3Q6IGNvbXByZWhlbnNpdmUgYW5kIGNvbmNpc2VcbmlmIChTdHJpbmcuaXNCbGFuayhzdHJpbmdWYWx1ZSkpIHtcbiAgICAvLyBIYW5kbGVzIG51bGwsIGVtcHR5LCBhbmQgd2hpdGVzcGFjZS1vbmx5XG59XG5cbi8vIEZvciBwcm9jZXNzaW5nIHdpdGggZGVmYXVsdFxuU3RyaW5nIHByb2Nlc3NlZFZhbHVlID0gU3RyaW5nLmlzQmxhbmsoc3RyaW5nVmFsdWUpID8gJ0RlZmF1bHQnIDogc3RyaW5nVmFsdWUudHJpbSgpO2AsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIlVzZSBTdHJpbmcgdXRpbGl0eSBtZXRob2RzIChpc0JsYW5rLCBpc05vdEJsYW5rLCBpc05vdEVtcHR5KSBpbnN0ZWFkIG9mIG1hbnVhbCBudWxsL2VtcHR5IGNoZWNrcy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJTdHJpbmcgdmFsaWRhdGlvbiBxdWVzdGlvbnMgZmF2b3IgdXRpbGl0eSBtZXRob2RzIG92ZXIgbWFudWFsIGNoZWNraW5nLiBSZW1lbWJlcjogaXNCbGFuayBpbmNsdWRlcyB3aGl0ZXNwYWNlLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDcsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhZHZhbmNlZCcsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkEgbG9vcCBpcyBjYXVzaW5nICdDUFUgdGltZW91dCBleGNlZWRlZCcuIEhvdyBkbyB5b3Ugb3B0aW1pemUgaXQ/XCIsXG4gICAgICAgIGFuc3dlcjogXCJNb3ZlIHRvIGFzeW5jaHJvbm91cyBwcm9jZXNzaW5nLCByZWR1Y2UgY29tcGxleGl0eSwgb3IgdXNlIGRhdGFiYXNlIG9wZXJhdGlvbnMgaW5zdGVhZCBvZiBsb29wc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJDUFUgdGltZW91dHMgb2NjdXIgd2hlbiBzeW5jaHJvbm91cyBBcGV4IHJ1bnMgdG9vIGxvbmcgKDEwIHNlY29uZHMpLiBTb2x1dGlvbnMgaW5jbHVkZSBtb3ZpbmcgaGVhdnkgcHJvY2Vzc2luZyB0byBhc3luYyBjb250ZXh0LCBvcHRpbWl6aW5nIGFsZ29yaXRobXMsIG9yIHJlcGxhY2luZyBBcGV4IGxvb3BzIHdpdGggZGF0YWJhc2Ugb3BlcmF0aW9ucy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGAvLyBQcm9ibGVtOiBIZWF2eSBwcm9jZXNzaW5nIGluIHN5bmMgY29udGV4dFxucHVibGljIHZvaWQgcHJvY2Vzc0xhcmdlRGF0YXNldChMaXN0PEFjY291bnQ+IGFjY291bnRzKSB7XG4gICAgZm9yIChBY2NvdW50IGFjYyA6IGFjY291bnRzKSB7XG4gICAgICAgIC8vIENvbXBsZXggY2FsY3VsYXRpb25zIGNhdXNpbmcgdGltZW91dFxuICAgICAgICBmb3IgKENvbnRhY3QgY29uIDogW1NFTEVDVCBJZCBGUk9NIENvbnRhY3QgV0hFUkUgQWNjb3VudElkID0gOmFjYy5JZF0pIHtcbiAgICAgICAgICAgIC8vIE5lc3RlZCBxdWVyeSArIHByb2Nlc3NpbmcgPSBDUFUga2lsbGVyXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFNvbHV0aW9uIDE6IE1vdmUgdG8gYXN5bmNcbkBmdXR1cmVcbnB1YmxpYyBzdGF0aWMgdm9pZCBwcm9jZXNzTGFyZ2VEYXRhc2V0QXN5bmMoTGlzdDxJZD4gYWNjb3VudElkcykge1xuICAgIC8vIDYwIHNlY29uZCBsaW1pdCBpbnN0ZWFkIG9mIDEwIHNlY29uZHNcbiAgICBMaXN0PEFjY291bnQ+IGFjY291bnRzID0gW1NFTEVDVCBJZCBGUk9NIEFjY291bnQgV0hFUkUgSWQgSU4gOmFjY291bnRJZHNdO1xuICAgIC8vIFByb2Nlc3Mgd2l0aCBoaWdoZXIgbGltaXRzXG59XG5cbi8vIFNvbHV0aW9uIDI6IEJ1bGtpZnkgcXVlcmllc1xucHVibGljIHZvaWQgcHJvY2Vzc0xhcmdlRGF0YXNldEJ1bGsoTGlzdDxBY2NvdW50PiBhY2NvdW50cykge1xuICAgIFNldDxJZD4gYWNjb3VudElkcyA9IG5ldyBTZXQ8SWQ+KCk7XG4gICAgZm9yIChBY2NvdW50IGFjYyA6IGFjY291bnRzKSB7XG4gICAgICAgIGFjY291bnRJZHMuYWRkKGFjYy5JZCk7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIHF1ZXJ5IGluc3RlYWQgb2YgbG9vcCBxdWVyaWVzXG4gICAgTWFwPElkLCBMaXN0PENvbnRhY3Q+PiBjb250YWN0c0J5QWNjb3VudCA9IG5ldyBNYXA8SWQsIExpc3Q8Q29udGFjdD4+KCk7XG4gICAgZm9yIChDb250YWN0IGNvbiA6IFtTRUxFQ1QgSWQsIEFjY291bnRJZCBGUk9NIENvbnRhY3QgV0hFUkUgQWNjb3VudElkIElOIDphY2NvdW50SWRzXSkge1xuICAgICAgICAvLyBHcm91cCBlZmZpY2llbnRseVxuICAgIH1cbn1gLFxuICAgICAgICBrZXlMZWFybmluZzogXCJDUFUgdGltZW91dHMgcmVxdWlyZSBhcmNoaXRlY3R1cmFsIGNoYW5nZXM6IGFzeW5jIHByb2Nlc3NpbmcsIHF1ZXJ5IGJ1bGtpZmljYXRpb24sIG9yIGRhdGFiYXNlIG9wZXJhdGlvbnMuXCIsXG4gICAgICAgIGV4YW1UaXA6IFwiR292ZXJub3IgbGltaXQgc2NlbmFyaW9zIHRlc3QgdW5kZXJzdGFuZGluZyBvZiBTYWxlc2ZvcmNlIHBsYXRmb3JtIGNvbnN0cmFpbnRzIGFuZCBvcHRpbWl6YXRpb24gc3RyYXRlZ2llcy5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA4LFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJZb3UncmUgcHJvY2Vzc2luZyBBY2NvdW50IHJlY29yZHMgYW5kIG5lZWQgdG8gc2tpcCBpbmFjdGl2ZSBvbmVzLiBCZXN0IGFwcHJvYWNoP1wiLFxuICAgICAgICBhbnN3ZXI6IFwiVXNlIGNvbnRpbnVlIHN0YXRlbWVudCB0byBza2lwIGluYWN0aXZlIGFjY291bnRzIGluIHRoZSBsb29wXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIldoZW4geW91IG5lZWQgdG8gc2tpcCBjZXJ0YWluIHJlY29yZHMgZHVyaW5nIHByb2Nlc3NpbmcsIHRoZSBjb250aW51ZSBzdGF0ZW1lbnQgcHJvdmlkZXMgY2xlYW4sIHJlYWRhYmxlIGNvZGUgdGhhdCBtb3ZlcyB0byB0aGUgbmV4dCBpdGVyYXRpb24gd2l0aG91dCBkZWVwbHkgbmVzdGluZyB0aGUgbWFpbiBsb2dpYy5cIixcbiAgICAgICAgY29ycmVjdENvZGU6IGBwdWJsaWMgdm9pZCBwcm9jZXNzQWNjb3VudHMoTGlzdDxBY2NvdW50PiBhY2NvdW50cykge1xuICAgIGZvciAoQWNjb3VudCBhY2MgOiBhY2NvdW50cykge1xuICAgICAgICAvLyBHdWFyZCBjbGF1c2U6IHNraXAgaW5hY3RpdmUgYWNjb3VudHNcbiAgICAgICAgaWYgKGFjYy5BY3RpdmVfX2MgIT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCBhY2NvdW50XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWluIHByb2Nlc3NpbmcgbG9naWMgb25seSBydW5zIGZvciBhY3RpdmUgYWNjb3VudHNcbiAgICAgICAgaWYgKGFjYy5Bbm51YWxSZXZlbnVlID4gMTAwMDAwMCkge1xuICAgICAgICAgICAgYWNjLlJhdGluZyA9ICdIb3QnO1xuICAgICAgICB9XG5cbiAgICAgICAgYWNjLkxhc3RQcm9jZXNzZWRfX2MgPSBTeXN0ZW0ubm93KCk7XG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnUHJvY2Vzc2VkIGFjdGl2ZSBhY2NvdW50OiAnICsgYWNjLk5hbWUpO1xuICAgIH1cbn1cblxuLy8gQWx0ZXJuYXRpdmU6IGZpbHRlciBpbiBxdWVyeSAoZXZlbiBiZXR0ZXIpXG5MaXN0PEFjY291bnQ+IGFjdGl2ZUFjY291bnRzID0gW1NFTEVDVCBJZCwgTmFtZSwgQW5udWFsUmV2ZW51ZSBGUk9NIEFjY291bnQgV0hFUkUgQWN0aXZlX19jID0gdHJ1ZV07XG5mb3IgKEFjY291bnQgYWNjIDogYWN0aXZlQWNjb3VudHMpIHtcbiAgICAvLyBBbGwgYWNjb3VudHMgYXJlIGFscmVhZHkgYWN0aXZlXG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiVXNlIGNvbnRpbnVlIGZvciBjbGVhbiBndWFyZCBjbGF1c2VzLCBidXQgcHJlZmVyIGZpbHRlcmluZyBpbiBTT1FMIHF1ZXJpZXMgd2hlbiBwb3NzaWJsZS5cIixcbiAgICAgICAgZXhhbVRpcDogXCJFYXJseSBleGl0IHBhdHRlcm5zIGltcHJvdmUgY29kZSByZWFkYWJpbGl0eS4gR3VhcmQgY2xhdXNlcyB3aXRoIGNvbnRpbnVlIGFyZSBwcmVmZXJyZWQgb3ZlciBkZWVwIG5lc3RpbmcuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogOSxcbiAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIkV4cGxhaW4gd2hlbiBlbmhhbmNlZCBmb3IgbG9vcHMgYXJlIHByZWZlcnJlZCBvdmVyIHRyYWRpdGlvbmFsIGZvciBsb29wcy5cIixcbiAgICAgICAgYW5zd2VyOiBcIkVuaGFuY2VkIGZvciB3aGVuIHByb2Nlc3NpbmcgYWxsIGVsZW1lbnRzLCB0cmFkaXRpb25hbCBmb3Igd2hlbiB5b3UgbmVlZCBpbmRleCBvciBza2lwIGVsZW1lbnRzXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIkVuaGFuY2VkIGZvciBsb29wcyBhcmUgc2FmZXIgKG5vIGluZGV4IGJvdW5kcyBpc3N1ZXMpIGFuZCBjbGVhbmVyIGZvciBwcm9jZXNzaW5nIGFsbCBlbGVtZW50cy4gVHJhZGl0aW9uYWwgZm9yIGxvb3BzIGdpdmUgeW91IGluZGV4IGNvbnRyb2wgZm9yIHBhcnRpYWwgcHJvY2Vzc2luZyBvciB3aGVuIHlvdSBuZWVkIGVsZW1lbnQgcG9zaXRpb24uXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgTGlzdDxDb250YWN0PiBjb250YWN0cyA9IFtTRUxFQ1QgSWQsIE5hbWUsIEVtYWlsIEZST00gQ29udGFjdF07XG5cbi8vIEVuaGFuY2VkIGZvcjogUHJvY2VzcyBhbGwgZWxlbWVudHMgKFBSRUZFUlJFRClcbmZvciAoQ29udGFjdCBjb24gOiBjb250YWN0cykge1xuICAgIC8vIENsZWFuLCBzYWZlLCBubyBpbmRleCBtYW5hZ2VtZW50XG4gICAgaWYgKFN0cmluZy5pc05vdEJsYW5rKGNvbi5FbWFpbCkpIHtcbiAgICAgICAgc2VuZEVtYWlsKGNvbi5FbWFpbCk7XG4gICAgfVxufVxuXG4vLyBUcmFkaXRpb25hbCBmb3I6IFdoZW4geW91IG5lZWQgdGhlIGluZGV4XG5mb3IgKEludGVnZXIgaSA9IDA7IGkgPCBjb250YWN0cy5zaXplKCk7IGkrKykge1xuICAgIENvbnRhY3QgY29uID0gY29udGFjdHMuZ2V0KGkpO1xuICAgIFN5c3RlbS5kZWJ1ZygnUHJvY2Vzc2luZyBjb250YWN0ICMnICsgKGkgKyAxKSArICc6ICcgKyBjb24uTmFtZSk7XG59XG5cbi8vIFRyYWRpdGlvbmFsIGZvcjogUHJvY2VzcyBvbmx5IGZpcnN0IGhhbGZcbmZvciAoSW50ZWdlciBpID0gMDsgaSA8IGNvbnRhY3RzLnNpemUoKSAvIDI7IGkrKykge1xuICAgIENvbnRhY3QgY29uID0gY29udGFjdHMuZ2V0KGkpO1xuICAgIC8vIFByb2Nlc3Mgc3Vic2V0XG59XG5cbi8vIFRyYWRpdGlvbmFsIGZvcjogU2tpcCBldmVyeSBvdGhlciBlbGVtZW50XG5mb3IgKEludGVnZXIgaSA9IDA7IGkgPCBjb250YWN0cy5zaXplKCk7IGkgKz0gMikge1xuICAgIENvbnRhY3QgY29uID0gY29udGFjdHMuZ2V0KGkpO1xuICAgIC8vIFByb2Nlc3MgZXZlcnkgb3RoZXIgY29udGFjdFxufWAsXG4gICAgICAgIGtleUxlYXJuaW5nOiBcIkVuaGFuY2VkIGZvciA9IGFsbCBlbGVtZW50cyBzYWZlbHkuIFRyYWRpdGlvbmFsIGZvciA9IGluZGV4IGNvbnRyb2wgYW5kIHBhcnRpYWwgcHJvY2Vzc2luZy5cIixcbiAgICAgICAgZXhhbVRpcDogXCJMb29wIGNob2ljZSBxdWVzdGlvbnMgdGVzdCB1bmRlcnN0YW5kaW5nIG9mIHdoZW4gaW5kZXggYWNjZXNzIGlzIG5lY2Vzc2FyeSB2cy4gc2ltcGxlIGl0ZXJhdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxMCxcbiAgICAgICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcbiAgICAgICAgcXVlc3Rpb246IFwiQSBidXNpbmVzcyBydWxlIGhhcyA4IGRpZmZlcmVudCBjb25kaXRpb25zLiBIb3cgZG8geW91IHN0cnVjdHVyZSB0aGlzIGNsZWFubHk/XCIsXG4gICAgICAgIGFuc3dlcjogXCJVc2UgZWFybHkgcmV0dXJucywgc3dpdGNoIHN0YXRlbWVudHMsIG9yIHN0cmF0ZWd5IHBhdHRlcm4gdG8gYXZvaWQgZGVlcCBuZXN0aW5nXCIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBcIk11bHRpcGxlIGNvbmRpdGlvbnMgY2FuIGNyZWF0ZSBkZWVwbHkgbmVzdGVkLCBoYXJkLXRvLXJlYWQgY29kZS4gQ2xlYW4gYXBwcm9hY2hlcyBpbmNsdWRlIGd1YXJkIGNsYXVzZXMgd2l0aCBlYXJseSByZXR1cm5zLCBzd2l0Y2ggc3RhdGVtZW50cyBmb3IgZXhhY3QgbWF0Y2hlcywgb3Igb3JnYW5pemluZyBpbnRvIHNlcGFyYXRlIG1ldGhvZHMuXCIsXG4gICAgICAgIGNvcnJlY3RDb2RlOiBgLy8gUHJvYmxlbTogRGVlcCBuZXN0aW5nIHdpdGggbWFueSBjb25kaXRpb25zXG5wdWJsaWMgU3RyaW5nIGNhdGVnb3JpemVPcHBvcnR1bml0eShPcHBvcnR1bml0eSBvcHApIHtcbiAgICBpZiAob3BwLkFtb3VudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChvcHAuQW1vdW50ID4gMTAwMDAwMCkge1xuICAgICAgICAgICAgaWYgKG9wcC5Qcm9iYWJpbGl0eSA+IDgwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wcC5UeXBlID09ICdOZXcgQ3VzdG9tZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZXAgbmVzdGluZyBjb250aW51ZXMuLi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duJztcbn1cblxuLy8gU29sdXRpb24gMTogRWFybHkgcmV0dXJucyAoZ3VhcmQgY2xhdXNlcylcbnB1YmxpYyBTdHJpbmcgY2F0ZWdvcml6ZU9wcG9ydHVuaXR5Q2xlYW4oT3Bwb3J0dW5pdHkgb3BwKSB7XG4gICAgLy8gSGFuZGxlIGludmFsaWQgY2FzZXMgZWFybHlcbiAgICBpZiAob3BwLkFtb3VudCA9PSBudWxsKSByZXR1cm4gJ05vIEFtb3VudCc7XG4gICAgaWYgKG9wcC5Qcm9iYWJpbGl0eSA9PSBudWxsKSByZXR1cm4gJ05vIFByb2JhYmlsaXR5JztcblxuICAgIC8vIExhcmdlIGRlYWxzXG4gICAgaWYgKG9wcC5BbW91bnQgPiAxMDAwMDAwKSB7XG4gICAgICAgIGlmIChvcHAuUHJvYmFiaWxpdHkgPiA4MCkgcmV0dXJuICdMYXJnZSBTdXJlIERlYWwnO1xuICAgICAgICBpZiAob3BwLlByb2JhYmlsaXR5ID4gNTApIHJldHVybiAnTGFyZ2UgTGlrZWx5IERlYWwnO1xuICAgICAgICByZXR1cm4gJ0xhcmdlIFJpc2t5IERlYWwnO1xuICAgIH1cblxuICAgIC8vIE1lZGl1bSBkZWFsc1xuICAgIGlmIChvcHAuQW1vdW50ID4gMTAwMDAwKSB7XG4gICAgICAgIHJldHVybiBvcHAuUHJvYmFiaWxpdHkgPiA3MCA/ICdNZWRpdW0gU3VyZSBEZWFsJyA6ICdNZWRpdW0gRGVhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdTbWFsbCBEZWFsJztcbn1cblxuLy8gU29sdXRpb24gMjogU3dpdGNoIGZvciBleGFjdCBtYXRjaGluZ1xucHVibGljIFN0cmluZyBjYXRlZ29yaXplQnlTdGFnZShPcHBvcnR1bml0eSBvcHApIHtcbiAgICBzd2l0Y2ggb24gb3BwLlN0YWdlTmFtZSB7XG4gICAgICAgIHdoZW4gJ1Byb3NwZWN0aW5nJywgJ1F1YWxpZmljYXRpb24nIHsgcmV0dXJuICdFYXJseSBTdGFnZSc7IH1cbiAgICAgICAgd2hlbiAnTmVlZHMgQW5hbHlzaXMnLCAnVmFsdWUgUHJvcG9zaXRpb24nIHsgcmV0dXJuICdNaWQgU3RhZ2UnOyB9XG4gICAgICAgIHdoZW4gJ0lkLiBEZWNpc2lvbiBNYWtlcnMnLCAnUGVyY2VwdGlvbiBBbmFseXNpcycgeyByZXR1cm4gJ0xhdGUgU3RhZ2UnOyB9XG4gICAgICAgIHdoZW4gJ1Byb3Bvc2FsL1ByaWNlIFF1b3RlJywgJ05lZ290aWF0aW9uL1JldmlldycgeyByZXR1cm4gJ0ZpbmFsIFN0YWdlJzsgfVxuICAgICAgICB3aGVuICdDbG9zZWQgV29uJyB7IHJldHVybiAnV29uJzsgfVxuICAgICAgICB3aGVuICdDbG9zZWQgTG9zdCcgeyByZXR1cm4gJ0xvc3QnOyB9XG4gICAgICAgIHdoZW4gZWxzZSB7IHJldHVybiAnVW5rbm93biBTdGFnZSc7IH1cbiAgICB9XG59YCxcbiAgICAgICAga2V5TGVhcm5pbmc6IFwiQ29tcGxleCBjb25kaXRpb25zIG5lZWQgY2xlYW4gc3RydWN0dXJlOiBlYXJseSByZXR1cm5zLCBzd2l0Y2ggc3RhdGVtZW50cywgb3Igc2VwYXJhdGUgbWV0aG9kcyB0byBhdm9pZCBuZXN0aW5nLlwiLFxuICAgICAgICBleGFtVGlwOiBcIkNvZGUgcXVhbGl0eSBxdWVzdGlvbnMgdGVzdCBhYmlsaXR5IHRvIHdyaXRlIG1haW50YWluYWJsZSBsb2dpYy4gRGVlcCBuZXN0aW5nIGlzIGFuIGFudGktcGF0dGVybi5cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcblxuICAnY2xhc3Nlcy1hbmQtb2JqZWN0cyc6IHtcbiAgICB0aXRsZTogJ0NsYXNzZXMgYW5kIE9iamVjdHMnLFxuICAgIG92ZXJ2aWV3OiAnTWFzdGVyIG9iamVjdC1vcmllbnRlZCBwcm9ncmFtbWluZyBpbiBBcGV4LiBZb3VyIGNvbnRyb2wgZmxvdyBsb2dpYyBuZWVkcyBvcmdhbml6YXRpb24gYW5kIHJldXNhYmlsaXR5IC0gQ2xhc3NlcyBhcmUgY29udGFpbmVycyBmb3IgcmVsYXRlZCBmdW5jdGlvbmFsaXR5LiBVbmRlcnN0YW5kaW5nIGNsYXNzZXMgaXMgY3J1Y2lhbCBiZWNhdXNlIDMwJSBvZiBTYWxlc2ZvcmNlIGRldmVsb3BtZW50IGludm9sdmVzIGNyZWF0aW5nIGFuZCB1c2luZyBjdXN0b20gY2xhc3Nlcy4gVGhpcyBrbm93bGVkZ2UgZGlyZWN0bHkgZW5hYmxlcyBTT1FMIG9wZXJhdGlvbnMgKG9yZ2FuaXplZCBkYXRhIGFjY2VzcykgYW5kIFRyaWdnZXJzIChvcmdhbml6ZWQgYXV0b21hdGlvbikuJyxcbiAgICBjb2RlRXhhbXBsZXM6IFtcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdDbGFzcyBTdHJ1Y3R1cmUnLFxuICAgICAgICBjb2RlOiBgcHVibGljIGNsYXNzIEN1c3RvbWVyTWFuYWdlciB7XG4gICAgLy8g4pyFIEJVSUxESU5HIE9OOiBDb250cm9sIGZsb3cgbG9naWMgbmVlZHMgb3JnYW5pemF0aW9uIGFuZCByZXVzYWJpbGl0eVxuICAgIC8vIOKchSBORVcgQ09OQ0VQVDogQ2xhc3NlcyBhcmUgY29udGFpbmVycyBmb3IgcmVsYXRlZCBmdW5jdGlvbmFsaXR5XG5cbiAgICAvLyDinIUgSU5TVEFOQ0UgVkFSSUFCTEVTOiBEYXRhIHRoYXQgYmVsb25ncyB0byBlYWNoIG9iamVjdFxuICAgIHByaXZhdGUgU3RyaW5nIG1hbmFnZXJOYW1lO1xuICAgIHByaXZhdGUgSW50ZWdlciBjdXN0b21lcnNQcm9jZXNzZWQ7XG4gICAgcHJpdmF0ZSBMaXN0PFN0cmluZz4gcHJvY2Vzc2VkQ3VzdG9tZXJJZHM7XG4gICAgLy8g4pyFIFdIWSBwcml2YXRlOiBFbmNhcHN1bGF0aW9uIC0gY29udHJvbGxlZCBhY2Nlc3Mgb25seVxuICAgIC8vIOKchSBDT05ORUNUSU9OOiBTYW1lIHZhcmlhYmxlIHByaW5jaXBsZXMgZnJvbSBWYXJpYWJsZXMgdG9waWNcbiAgICAvLyDwn5KhIE5FWFQgVE9QSUM6IFNPUUwgd2lsbCBwb3B1bGF0ZSB0aGVzZSB3aXRoIHJlYWwgZGF0YVxuXG4gICAgLy8g4pyFIFNUQVRJQyBWQVJJQUJMRVM6IFNoYXJlZCBhY3Jvc3MgQUxMIG9iamVjdHMgb2YgdGhpcyBjbGFzc1xuICAgIHByaXZhdGUgc3RhdGljIEludGVnZXIgdG90YWxDdXN0b21lcnNQcm9jZXNzZWQgPSAwO1xuICAgIC8vIOKchSBXSEFUOiBPbmUgY29weSBzaGFyZWQgYnkgYWxsIEN1c3RvbWVyTWFuYWdlciBvYmplY3RzXG4gICAgLy8g4pyFIFdIWTogVHJhY2sgZ2xvYmFsIHN0YXRpc3RpY3MgYWNyb3NzIGFsbCBpbnN0YW5jZXNcblxuICAgIC8vIOKchSBDT05TVEFOVFM6IFZhbHVlcyB0aGF0IG5ldmVyIGNoYW5nZVxuICAgIHB1YmxpYyBzdGF0aWMgZmluYWwgSW50ZWdlciBNQVhfQ1VTVE9NRVJTX1BFUl9CQVRDSCA9IDIwMDtcbiAgICAvLyDinIUgV0hZIDIwMDogU2FsZXNmb3JjZSBnb3Zlcm5vciBsaW1pdHMgZm9yIGJ1bGsgcHJvY2Vzc2luZ1xuXG4gICAgLy8g4pyFIENPTlNUUlVDVE9SOiBJbml0aWFsaXplIG9iamVjdCB3aGVuIGNyZWF0ZWRcbiAgICBwdWJsaWMgQ3VzdG9tZXJNYW5hZ2VyKFN0cmluZyBuYW1lKSB7XG4gICAgICAgIC8vIOKchSBXSEFUOiBSdW5zIGF1dG9tYXRpY2FsbHkgd2hlbiBvYmplY3QgY3JlYXRlZCB3aXRoICduZXcnXG4gICAgICAgIC8vIOKchSBXSFk6IEVuc3VyZXMgb2JqZWN0IHN0YXJ0cyBpbiB2YWxpZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXJOYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jdXN0b21lcnNQcm9jZXNzZWQgPSAwO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZEN1c3RvbWVySWRzID0gbmV3IExpc3Q8U3RyaW5nPigpO1xuICAgICAgICAvLyDinIUgQ09OTkVDVElPTjogTGlzdCBpbml0aWFsaXphdGlvbiBmcm9tIENvbGxlY3Rpb25zIHRvcGljXG4gICAgICAgIC8vIPCfkoAgRVhBTSBUUkFQOiBGb3JnZXR0aW5nIHRvIGluaXRpYWxpemUgY29sbGVjdGlvbnMgPSBudWxsIGVycm9yc1xuICAgIH1cblxuICAgIC8vIOKchSBJTlNUQU5DRSBNRVRIT0Q6IE9wZXJhdGVzIG9uIHNwZWNpZmljIG9iamVjdCdzIGRhdGFcbiAgICBwdWJsaWMgdm9pZCBwcm9jZXNzQ3VzdG9tZXIoQWNjb3VudCBjdXN0b21lcikge1xuICAgICAgICAvLyDinIUgVkFMSURBVElPTjogU2FtZSBwYXR0ZXJucyBmcm9tIENvbnRyb2wgRmxvdyB0b3BpY1xuICAgICAgICBpZiAoY3VzdG9tZXIgPT0gbnVsbCB8fCBTdHJpbmcuaXNCbGFuayhjdXN0b21lci5OYW1lKSkge1xuICAgICAgICAgICAgU3lzdGVtLmRlYnVnKCdJbnZhbGlkIGN1c3RvbWVyIGRhdGEgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgIHJldHVybjsgLy8gRWFybHkgZXhpdCBwYXR0ZXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyDinIUgQlVTSU5FU1MgTE9HSUM6IEFwcGx5IHByb2Nlc3NpbmcgcnVsZXNcbiAgICAgICAgaWYgKGN1c3RvbWVyLkFubnVhbFJldmVudWUgIT0gbnVsbCAmJiBjdXN0b21lci5Bbm51YWxSZXZlbnVlID4gMTAwMDAwKSB7XG4gICAgICAgICAgICBjdXN0b21lci5DdXN0b21lclByaW9yaXR5X19jID0gJ0hpZ2gnO1xuICAgICAgICAgICAgLy8g4pyFIENPTk5FQ1RJT046IENvbmRpdGlvbmFsIGxvZ2ljIGZyb20gQ29udHJvbCBGbG93IHRvcGljXG4gICAgICAgIH1cblxuICAgICAgICAvLyDinIUgU1RBVEUgVFJBQ0tJTkc6IFVwZGF0ZSBvYmplY3QncyBpbnRlcm5hbCBkYXRhXG4gICAgICAgIHRoaXMuY3VzdG9tZXJzUHJvY2Vzc2VkKys7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkQ3VzdG9tZXJJZHMuYWRkKGN1c3RvbWVyLklkKTtcbiAgICAgICAgdG90YWxDdXN0b21lcnNQcm9jZXNzZWQrKzsgLy8gU3RhdGljIHZhcmlhYmxlXG5cbiAgICAgICAgU3lzdGVtLmRlYnVnKHRoaXMubWFuYWdlck5hbWUgKyAnIHByb2Nlc3NlZDogJyArIGN1c3RvbWVyLk5hbWUpO1xuICAgICAgICAvLyDwn5KhIE5FWFQgVE9QSUM6IFNPUUwgd2lsbCBwcm92aWRlIGN1c3RvbWVyIGRhdGEgZWZmaWNpZW50bHlcbiAgICB9XG5cbiAgICAvLyDinIUgU1RBVElDIE1FVEhPRDogVXRpbGl0eSBmdW5jdGlvbiwgbm8gb2JqZWN0IG5lZWRlZFxuICAgIHB1YmxpYyBzdGF0aWMgQm9vbGVhbiBpc0hpZ2hWYWx1ZUN1c3RvbWVyKEFjY291bnQgY3VzdG9tZXIpIHtcbiAgICAgICAgLy8g4pyFIFdIRU4gVE8gVVNFOiBQdXJlIGZ1bmN0aW9uIHRoYXQgZG9lc24ndCBuZWVkIG9iamVjdCBzdGF0ZVxuICAgICAgICAvLyDinIUgUkVVU0FCSUxJVFk6IENhbiBiZSBjYWxsZWQgZnJvbSBhbnl3aGVyZVxuICAgICAgICBpZiAoY3VzdG9tZXI/LkFubnVhbFJldmVudWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXN0b21lci5Bbm51YWxSZXZlbnVlID4gNTAwMDAwO1xuICAgICAgICAvLyDinIUgQ09OTkVDVElPTjogTnVsbCBzYWZldHkgZnJvbSBWYXJpYWJsZXMgdG9waWNcbiAgICB9XG5cbiAgICAvLyDinIUgR0VUVEVSIE1FVEhPRDogQ29udHJvbGxlZCBhY2Nlc3MgdG8gcHJpdmF0ZSBkYXRhXG4gICAgcHVibGljIEludGVnZXIgZ2V0Q3VzdG9tZXJzUHJvY2Vzc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21lcnNQcm9jZXNzZWQ7XG4gICAgICAgIC8vIOKchSBFTkNBUFNVTEFUSU9OOiBSZWFkLW9ubHkgYWNjZXNzIHRvIGludGVybmFsIHN0YXRlXG4gICAgfVxufVxuXG4vLyDinIUgVVNBR0UgRVhBTVBMRTogSG93IGNsYXNzZXMgd29yayB0b2dldGhlclxucHVibGljIGNsYXNzIEJ1c2luZXNzTG9naWNFeGFtcGxlIHtcbiAgICBwdWJsaWMgdm9pZCBkZW1vbnN0cmF0ZUNsYXNzVXNhZ2UoKSB7XG4gICAgICAgIC8vIOKchSBPQkpFQ1QgQ1JFQVRJT046IENvbnN0cnVjdG9yIHJ1bnMgYXV0b21hdGljYWxseVxuICAgICAgICBDdXN0b21lck1hbmFnZXIgc2FsZXNNYW5hZ2VyID0gbmV3IEN1c3RvbWVyTWFuYWdlcignSm9obiBTbWl0aCcpO1xuICAgICAgICBDdXN0b21lck1hbmFnZXIgc3VwcG9ydE1hbmFnZXIgPSBuZXcgQ3VzdG9tZXJNYW5hZ2VyKCdKYW5lIERvZScpO1xuICAgICAgICAvLyDinIUgTVVMVElQTEUgT0JKRUNUUzogRWFjaCBoYXMgaXRzIG93biBzdGF0ZVxuXG4gICAgICAgIC8vIOKchSBTVEFUSUMgTUVUSE9EOiBDYWxsZWQgb24gY2xhc3MsIG5vdCBvYmplY3RcbiAgICAgICAgTGlzdDxBY2NvdW50PiBhY2NvdW50cyA9IFtTRUxFQ1QgSWQsIE5hbWUsIEFubnVhbFJldmVudWUgRlJPTSBBY2NvdW50IExJTUlUIDEwXTtcblxuICAgICAgICBmb3IgKEFjY291bnQgYWNjIDogYWNjb3VudHMpIHtcbiAgICAgICAgICAgIC8vIOKchSBERUNJU0lPTiBMT0dJQzogRnJvbSBDb250cm9sIEZsb3cgdG9waWNcbiAgICAgICAgICAgIGlmIChDdXN0b21lck1hbmFnZXIuaXNIaWdoVmFsdWVDdXN0b21lcihhY2MpKSB7XG4gICAgICAgICAgICAgICAgc2FsZXNNYW5hZ2VyLnByb2Nlc3NDdXN0b21lcihhY2MpO1xuICAgICAgICAgICAgICAgIC8vIOKchSBJTlNUQU5DRSBNRVRIT0Q6IENhbGxlZCBvbiBzcGVjaWZpYyBvYmplY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFN5c3RlbS5kZWJ1ZygnU2FsZXMgcHJvY2Vzc2VkOiAnICsgc2FsZXNNYW5hZ2VyLmdldEN1c3RvbWVyc1Byb2Nlc3NlZCgpKTtcbiAgICAgICAgLy8g8J+SoSBORVhUIFRPUElDOiBTT1FMIHdpbGwgZ2V0IGRhdGEgbW9yZSBlZmZpY2llbnRseVxuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0NsYXNzZXMgZW5jYXBzdWxhdGUgcmVsYXRlZCBkYXRhIGFuZCBiZWhhdmlvci4gVXNlIGluc3RhbmNlIHZhcmlhYmxlcyBmb3Igb2JqZWN0IHN0YXRlLCBjb25zdHJ1Y3RvcnMgZm9yIGluaXRpYWxpemF0aW9uLCBpbnN0YW5jZSBtZXRob2RzIGZvciBvYmplY3Qgb3BlcmF0aW9ucywgYW5kIHN0YXRpYyBtZXRob2RzIGZvciB1dGlsaXRpZXMuJ1xuICAgICAgfVxuICAgIF0sXG4gICAgcHJhY3RpY2VRdWVzdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGF0J3MgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhIGNsYXNzIGFuZCBhbiBvYmplY3QgaW4gQXBleD9cIixcbiAgICAgICAgYW5zd2VyOiBcIkEgY2xhc3MgaXMgYSBibHVlcHJpbnQvdGVtcGxhdGUsIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBjcmVhdGVkIGZyb20gdGhhdCBjbGFzc1wiLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJBIGNsYXNzIGRlZmluZXMgdGhlIHN0cnVjdHVyZSAodmFyaWFibGVzIGFuZCBtZXRob2RzKSBidXQgZG9lc24ndCBleGlzdCBpbiBtZW1vcnkuIEFuIG9iamVjdCBpcyBhIHNwZWNpZmljIGluc3RhbmNlIG9mIHRoYXQgY2xhc3MgdGhhdCBhY3R1YWxseSBob2xkcyBkYXRhIGFuZCBjYW4gZXhlY3V0ZSBtZXRob2RzLlwiLFxuICAgICAgICBjb3JyZWN0Q29kZTogYHB1YmxpYyBjbGFzcyBBY2NvdW50IHtcbiAgICBwdWJsaWMgU3RyaW5nIG5hbWU7ICAvLyBDbGFzcyBkZWZpbmVzIHN0cnVjdHVyZVxuICAgIHB1YmxpYyB2b2lkIGRpc3BsYXkoKSB7IFN5c3RlbS5kZWJ1ZyhuYW1lKTsgfVxufVxuXG4vLyBPYmplY3QgY3JlYXRpb24gZnJvbSBjbGFzc1xuQWNjb3VudCBteUFjY291bnQgPSBuZXcgQWNjb3VudCgpOyAgLy8gQ3JlYXRlIG9iamVjdCBpbnN0YW5jZVxubXlBY2NvdW50Lm5hbWUgPSAnQWNtZSBDb3JwJzsgICAgICAgLy8gU2V0IGRhdGEgaW4gb2JqZWN0XG5teUFjY291bnQuZGlzcGxheSgpOyAgICAgICAgICAgICAgICAvLyBDYWxsIG1ldGhvZCBvbiBvYmplY3RgLFxuICAgICAgICBrZXlMZWFybmluZzogXCJDbGFzcyA9IGJsdWVwcmludCwgT2JqZWN0ID0gYWN0dWFsIGluc3RhbmNlLiBZb3UgbmVlZCB0byBpbnN0YW50aWF0ZSBhIGNsYXNzIHdpdGggJ25ldycgdG8gY3JlYXRlIGFuIG9iamVjdC5cIixcbiAgICAgICAgZXhhbVRpcDogXCJQRDEgZnJlcXVlbnRseSB0ZXN0cyB1bmRlcnN0YW5kaW5nIG9mIGNsYXNzZXMgdnMgb2JqZWN0cy4gUmVtZW1iZXI6IGNsYXNzZXMgZGVmaW5lLCBvYmplY3RzIGV4ZWN1dGUuXCJcbiAgICAgIH1cbiAgICAgIC8vIE1vcmUgcHJhY3RpY2UgcXVlc3Rpb25zLi4uXG4gICAgXVxuICB9LFxuXG4gICdzb3FsLWFuZC1kbWwnOiB7XG4gICAgdGl0bGU6ICdTT1FMIGFuZCBETUwnLFxuICAgIG92ZXJ2aWV3OiAnTWFzdGVyIFNhbGVzZm9yY2UgT2JqZWN0IFF1ZXJ5IExhbmd1YWdlIGFuZCBkYXRhYmFzZSBvcGVyYXRpb25zLiBTT1FMIHJldHJpZXZlcyByZWNvcmRzIGZyb20gU2FsZXNmb3JjZSwgRE1MIG9wZXJhdGlvbnMgbW9kaWZ5IHRoZW0uJyxcbiAgICBjb2RlRXhhbXBsZXM6IFtcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdCYXNpYyBTT1FMIFF1ZXJpZXMnLFxuICAgICAgICBjb2RlOiBgcHVibGljIGNsYXNzIFF1ZXJ5RGVtbyB7XG4gICAgcHVibGljIHZvaWQgYmFzaWNRdWVyaWVzKCkge1xuICAgICAgICAvLyDinIUgV0hBVDogQmFzaWMgU0VMRUNUIHdpdGggc3BlY2lmaWMgZmllbGRzXG4gICAgICAgIExpc3Q8QWNjb3VudD4gYWNjb3VudHMgPSBbXG4gICAgICAgICAgICBTRUxFQ1QgSWQsIE5hbWUsIFR5cGUsIEluZHVzdHJ5XG4gICAgICAgICAgICBGUk9NIEFjY291bnRcbiAgICAgICAgICAgIFdIRVJFIFR5cGUgPSAnQ3VzdG9tZXInXG4gICAgICAgICAgICBMSU1JVCAxMDBcbiAgICAgICAgXTtcblxuICAgICAgICAvLyDinIUgV0hBVDogUXVlcnkgd2l0aCByZWxhdGlvbnNoaXBzIChsb29rdXApXG4gICAgICAgIExpc3Q8Q29udGFjdD4gY29udGFjdHMgPSBbXG4gICAgICAgICAgICBTRUxFQ1QgSWQsIE5hbWUsIEVtYWlsLFxuICAgICAgICAgICAgICAgICAgIEFjY291bnQuTmFtZSwgQWNjb3VudC5JbmR1c3RyeVxuICAgICAgICAgICAgRlJPTSBDb250YWN0XG4gICAgICAgICAgICBXSEVSRSBBY2NvdW50LlR5cGUgPSAnQ3VzdG9tZXInXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8g4pyFIFdIQVQ6IFF1ZXJ5IHdpdGggY2hpbGQgcmVsYXRpb25zaGlwc1xuICAgICAgICBMaXN0PEFjY291bnQ+IGFjY291bnRzV2l0aENvbnRhY3RzID0gW1xuICAgICAgICAgICAgU0VMRUNUIElkLCBOYW1lLFxuICAgICAgICAgICAgICAgICAgIChTRUxFQ1QgSWQsIE5hbWUsIEVtYWlsIEZST00gQ29udGFjdHMpXG4gICAgICAgICAgICBGUk9NIEFjY291bnRcbiAgICAgICAgICAgIFdIRVJFIElkIElOIDphY2NvdW50SWRzXG4gICAgICAgIF07XG4gICAgfVxufWAsXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnU09RTCBzeW50YXggaXMgc2ltaWxhciB0byBTUUwgYnV0IHdpdGggU2FsZXNmb3JjZS1zcGVjaWZpYyBmZWF0dXJlcyBsaWtlIHJlbGF0aW9uc2hpcCBxdWVyaWVzLiBBbHdheXMgc3BlY2lmeSBuZWVkZWQgZmllbGRzIGV4cGxpY2l0bHkgYW5kIHVzZSBMSU1JVCB0byBwcmV2ZW50IGdvdmVybm9yIGxpbWl0IGlzc3Vlcy4nXG4gICAgICB9XG4gICAgXSxcbiAgICBwcmFjdGljZVF1ZXN0aW9uczogW1xuICAgICAgLy8gUHJhY3RpY2UgcXVlc3Rpb25zIGZvciBTT1FMLi4uXG4gICAgXVxuICB9LFxuXG4gICd0cmlnZ2Vycy1hbmQtYXV0b21hdGlvbic6IHtcbiAgICB0aXRsZTogJ1RyaWdnZXJzIGFuZCBBdXRvbWF0aW9uJyxcbiAgICBvdmVydmlldzogJ01hc3RlciBBcGV4IHRyaWdnZXJzIGFuZCBhdXRvbWF0aW9uIHBhdHRlcm5zLiBUcmlnZ2VycyBleGVjdXRlIGF1dG9tYXRpY2FsbHkgd2hlbiByZWNvcmRzIGFyZSBpbnNlcnRlZCwgdXBkYXRlZCwgb3IgZGVsZXRlZC4nLFxuICAgIGNvZGVFeGFtcGxlczogW1xuICAgICAge1xuICAgICAgICB0aXRsZTogJ1RyaWdnZXIgU3RydWN0dXJlJyxcbiAgICAgICAgY29kZTogYHRyaWdnZXIgQWNjb3VudFRyaWdnZXIgb24gQWNjb3VudCAoYmVmb3JlIGluc2VydCwgYmVmb3JlIHVwZGF0ZSwgYWZ0ZXIgaW5zZXJ0LCBhZnRlciB1cGRhdGUpIHtcbiAgICAvLyDinIUgV0hBVDogU2luZ2xlIHRyaWdnZXIgaGFuZGxlcyBtdWx0aXBsZSBldmVudHNcbiAgICAvLyDinIUgV0hZOiBCZXR0ZXIgb3JnYW5pemF0aW9uIGFuZCBwcmVkaWN0YWJsZSBleGVjdXRpb24gb3JkZXJcblxuICAgIGlmIChUcmlnZ2VyLmlzQmVmb3JlKSB7XG4gICAgICAgIGlmIChUcmlnZ2VyLmlzSW5zZXJ0IHx8IFRyaWdnZXIuaXNVcGRhdGUpIHtcbiAgICAgICAgICAgIEFjY291bnRUcmlnZ2VySGFuZGxlci52YWxpZGF0ZUFjY291bnRzKFRyaWdnZXIubmV3KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChUcmlnZ2VyLmlzQWZ0ZXIpIHtcbiAgICAgICAgaWYgKFRyaWdnZXIuaXNJbnNlcnQpIHtcbiAgICAgICAgICAgIEFjY291bnRUcmlnZ2VySGFuZGxlci5jcmVhdGVEZWZhdWx0Q29udGFjdHMoVHJpZ2dlci5uZXcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFRyaWdnZXIuaXNVcGRhdGUpIHtcbiAgICAgICAgICAgIEFjY291bnRUcmlnZ2VySGFuZGxlci51cGRhdGVSZWxhdGVkT3Bwb3J0dW5pdGllcyhcbiAgICAgICAgICAgICAgICBUcmlnZ2VyLm5ldyxcbiAgICAgICAgICAgICAgICBUcmlnZ2VyLm9sZE1hcFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ1VzZSBhIHNpbmdsZSB0cmlnZ2VyIHBlciBvYmplY3Qgd2l0aCBtdWx0aXBsZSBldmVudHMuIERlbGVnYXRlIGxvZ2ljIHRvIGhhbmRsZXIgY2xhc3NlcyBmb3IgYmV0dGVyIG9yZ2FuaXphdGlvbiBhbmQgdGVzdGFiaWxpdHkuJ1xuICAgICAgfVxuICAgIF0sXG4gICAgcHJhY3RpY2VRdWVzdGlvbnM6IFtcbiAgICAgIC8vIFByYWN0aWNlIHF1ZXN0aW9ucyBmb3IgVHJpZ2dlcnMuLi5cbiAgICBdXG4gIH0sXG5cbiAgJ2FzeW5jaHJvbm91cy1hcGV4Jzoge1xuICAgIHRpdGxlOiAnQXN5bmNocm9ub3VzIEFwZXgnLFxuICAgIG92ZXJ2aWV3OiAnTWFzdGVyIGFzeW5jaHJvbm91cyBwcm9jZXNzaW5nIHdpdGggRnV0dXJlLCBCYXRjaCwgUXVldWVhYmxlLCBhbmQgU2NoZWR1bGFibGUgQXBleCBmb3IgaGFuZGxpbmcgbGFyZ2UgZGF0YSB2b2x1bWVzLicsXG4gICAgY29kZUV4YW1wbGVzOiBbXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnRnV0dXJlIE1ldGhvZHMnLFxuICAgICAgICBjb2RlOiBgcHVibGljIGNsYXNzIEFzeW5jRGVtbyB7XG4gICAgLy8g4pyFIFdIQVQ6IEZ1dHVyZSBtZXRob2QgZm9yIGFzeW5jIHByb2Nlc3NpbmdcbiAgICBAZnV0dXJlXG4gICAgcHVibGljIHN0YXRpYyB2b2lkIHByb2Nlc3NBY2NvdW50c0FzeW5jKFNldDxJZD4gYWNjb3VudElkcykge1xuICAgICAgICAvLyDinIUgV0hBVDogUXVlcnkgcmVjb3JkcyBpbiB0aGUgYXN5bmMgbWV0aG9kXG4gICAgICAgIExpc3Q8QWNjb3VudD4gYWNjb3VudHMgPSBbXG4gICAgICAgICAgICBTRUxFQ1QgSWQsIE5hbWUsIEluZHVzdHJ5XG4gICAgICAgICAgICBGUk9NIEFjY291bnRcbiAgICAgICAgICAgIFdIRVJFIElkIElOIDphY2NvdW50SWRzXG4gICAgICAgIF07XG5cbiAgICAgICAgZm9yIChBY2NvdW50IGFjYyA6IGFjY291bnRzKSB7XG4gICAgICAgICAgICAvLyBMb25nLXJ1bm5pbmcgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgYWNjLkRlc2NyaXB0aW9uID0gJ1Byb2Nlc3NlZCBhc3luYyBvbiAnICsgU3lzdGVtLm5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlIGFjY291bnRzO1xuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0Z1dHVyZSBtZXRob2RzIHJ1biBhc3luY2hyb25vdXNseSBhbmQgbXVzdCBiZSBzdGF0aWMuIFRoZXkgY2FuIG9ubHkgYWNjZXB0IHByaW1pdGl2ZSB0eXBlcyBhbmQgY29sbGVjdGlvbnMgb2YgcHJpbWl0aXZlcyBhcyBwYXJhbWV0ZXJzLidcbiAgICAgIH1cbiAgICBdLFxuICAgIHByYWN0aWNlUXVlc3Rpb25zOiBbXG4gICAgICAvLyBQcmFjdGljZSBxdWVzdGlvbnMgZm9yIEFzeW5jIEFwZXguLi5cbiAgICBdXG4gIH0sXG5cbiAgJ3Rlc3RpbmctYW5kLWRlYnVnZ2luZyc6IHtcbiAgICB0aXRsZTogJ1Rlc3RpbmcgYW5kIERlYnVnZ2luZycsXG4gICAgb3ZlcnZpZXc6ICdNYXN0ZXIgdW5pdCB0ZXN0aW5nLCB0ZXN0IGRhdGEgY3JlYXRpb24sIGFuZCB0ZXN0IGF1dG9tYXRpb24gaW4gQXBleC4gUHJvcGVyIHRlc3RpbmcgZW5zdXJlcyBjb2RlIHF1YWxpdHkgYW5kIHByZXZlbnRzIHJlZ3Jlc3Npb25zLicsXG4gICAgY29kZUV4YW1wbGVzOiBbXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnQmFzaWMgVGVzdCBTdHJ1Y3R1cmUnLFxuICAgICAgICBjb2RlOiBgQElzVGVzdFxucHVibGljIGNsYXNzIEFjY291bnRQcm9jZXNzb3JUZXN0IHtcblxuICAgIEBUZXN0U2V0dXBcbiAgICBzdGF0aWMgdm9pZCBjcmVhdGVUZXN0RGF0YSgpIHtcbiAgICAgICAgLy8g4pyFIFdIQVQ6IFRlc3QgZGF0YSBjcmVhdGVkIG9uY2UgZm9yIGFsbCB0ZXN0IG1ldGhvZHNcbiAgICAgICAgTGlzdDxBY2NvdW50PiB0ZXN0QWNjb3VudHMgPSBuZXcgTGlzdDxBY2NvdW50PigpO1xuICAgICAgICBmb3IgKEludGVnZXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXN0QWNjb3VudHMuYWRkKG5ldyBBY2NvdW50KFxuICAgICAgICAgICAgICAgIE5hbWUgPSAnVGVzdCBBY2NvdW50ICcgKyBpLFxuICAgICAgICAgICAgICAgIFR5cGUgPSAnQ3VzdG9tZXInLFxuICAgICAgICAgICAgICAgIEluZHVzdHJ5ID0gJ1RlY2hub2xvZ3knXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQgdGVzdEFjY291bnRzO1xuICAgIH1cblxuICAgIEBJc1Rlc3RcbiAgICBzdGF0aWMgdm9pZCB0ZXN0QWNjb3VudFByb2Nlc3NpbmcoKSB7XG4gICAgICAgIC8vIOKchSBXSEFUOiBRdWVyeSB0ZXN0IGRhdGFcbiAgICAgICAgTGlzdDxBY2NvdW50PiBhY2NvdW50cyA9IFtTRUxFQ1QgSWQsIE5hbWUgRlJPTSBBY2NvdW50XTtcblxuICAgICAgICBUZXN0LnN0YXJ0VGVzdCgpO1xuICAgICAgICAvLyDinIUgV0hBVDogRXhlY3V0ZSBjb2RlIHVuZGVyIHRlc3RcbiAgICAgICAgQWNjb3VudFByb2Nlc3NvciBwcm9jZXNzb3IgPSBuZXcgQWNjb3VudFByb2Nlc3NvcignVGVzdCBQcm9jZXNzb3InLCAyMCk7XG4gICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzQWNjb3VudHMoYWNjb3VudHMpO1xuICAgICAgICBUZXN0LnN0b3BUZXN0KCk7XG5cbiAgICAgICAgLy8g4pyFIFdIQVQ6IFZlcmlmeSByZXN1bHRzXG4gICAgICAgIExpc3Q8QWNjb3VudD4gcHJvY2Vzc2VkQWNjb3VudHMgPSBbXG4gICAgICAgICAgICBTRUxFQ1QgSWQsIExhc3RfUHJvY2Vzc2VkX0RhdGVfX2NcbiAgICAgICAgICAgIEZST00gQWNjb3VudFxuICAgICAgICBdO1xuXG4gICAgICAgIGZvciAoQWNjb3VudCBhY2MgOiBwcm9jZXNzZWRBY2NvdW50cykge1xuICAgICAgICAgICAgU3lzdGVtLmFzc2VydE5vdEVxdWFscyhudWxsLCBhY2MuTGFzdF9Qcm9jZXNzZWRfRGF0ZV9fYyxcbiAgICAgICAgICAgICAgICAnQWNjb3VudCBzaG91bGQgaGF2ZSBwcm9jZXNzaW5nIGRhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbn1gLFxuICAgICAgICBleHBsYW5hdGlvbjogJ1VzZSBAVGVzdFNldHVwIGZvciBjb21tb24gdGVzdCBkYXRhLCBUZXN0LnN0YXJ0VGVzdCgpL3N0b3BUZXN0KCkgdG8gcmVzZXQgZ292ZXJub3IgbGltaXRzLCBhbmQgU3lzdGVtLmFzc2VydCBtZXRob2RzIHRvIHZlcmlmeSByZXN1bHRzLidcbiAgICAgIH1cbiAgICBdLFxuICAgIHByYWN0aWNlUXVlc3Rpb25zOiBbXG4gICAgICAvLyBQcmFjdGljZSBxdWVzdGlvbnMgZm9yIFRlc3RpbmcuLi5cbiAgICBdXG4gIH1cbn07Il0sIm5hbWVzIjpbInRvcGljQ29udGVudCIsInRpdGxlIiwib3ZlcnZpZXciLCJjb2RlRXhhbXBsZXMiLCJjb2RlIiwiZXhwbGFuYXRpb24iLCJwcmFjdGljZVF1ZXN0aW9ucyIsIm51bWJlciIsImRpZmZpY3VsdHkiLCJxdWVzdGlvbiIsImFuc3dlciIsImNvcnJlY3RDb2RlIiwia2V5TGVhcm5pbmciLCJleGFtVGlwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/topicContent.ts\n"));

/***/ })

});