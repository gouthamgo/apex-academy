(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[0],{96977:function(e,n,t){Promise.resolve().then(t.bind(t,43938))},43938:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return T}});var s=t(57437),a=t(2265),o=t(86574),r=t(12658),i=t(71769),c=t(28124),l=t(13781),d=t(64935),u=t(50091),p=t(85954),m=t(73247),g=t(37829),h=t(30401),y=t(78867),b=t(10407);let x=e=>{switch(e){case"info":return"bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300";case"warning":return"bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300";case"danger":return"bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300";case"success":return"bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300";default:return"bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300"}};function f(e){let{code:n,annotations:t,language:i="apex"}=e,[c,l]=(0,a.useState)(!1),d=async()=>{try{await navigator.clipboard.writeText(n),l(!0),setTimeout(()=>l(!1),2e3)}catch(e){console.error("Failed to copy code:",e)}};return(0,s.jsxs)("div",{className:"my-6",children:[(0,s.jsxs)("div",{className:"relative group",children:[(0,s.jsx)(o.Z,{language:i,style:r.Z,className:"rounded-t-lg",customStyle:{background:"#0f0f0f",padding:"1.5rem",fontSize:"14px",lineHeight:"1.6",fontFamily:'"Fira Code", "JetBrains Mono", Consolas, monospace',border:"1px solid #2d2d2d",borderBottom:t.length>0?"none":"1px solid #2d2d2d",borderBottomLeftRadius:t.length>0?"0":"0.5rem",borderBottomRightRadius:t.length>0?"0":"0.5rem",margin:0},lineProps:{style:{background:"transparent",backgroundColor:"transparent",display:"block"}},codeTagProps:{style:{background:"transparent",backgroundColor:"transparent"}},children:n}),(0,s.jsx)("button",{onClick:d,className:"absolute top-2 right-2 p-2 rounded-md bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white transition-colors opacity-0 group-hover:opacity-100",title:"Copy code",children:c?(0,s.jsx)(h.Z,{className:"h-4 w-4 text-green-400"}):(0,s.jsx)(y.Z,{className:"h-4 w-4"})})]}),t.length>0&&(0,s.jsx)("div",{className:"bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 border-t-0 rounded-b-lg p-4 space-y-3",children:t.map((e,n)=>(0,s.jsxs)("div",{className:"font-mono text-sm",children:[(0,s.jsx)("div",{className:"text-blue-500 dark:text-blue-400 mb-2 font-bold tracking-wider",children:e.arrows}),(0,s.jsxs)("div",{className:"flex items-start space-x-3",children:[(0,s.jsx)("div",{className:"inline-flex items-center justify-center w-6 h-6 rounded-full text-xs font-medium flex-shrink-0 mt-0.5 ".concat(x(e.type)),children:e.icon}),(0,s.jsx)("div",{className:"flex-1 text-gray-700 dark:text-gray-300 leading-relaxed",children:e.explanation})]})]},n))})]})}let A=[{id:"variables",title:"Variables and Data Types",icon:i.Z,description:"Master Apex variables, primitive data types, and type conversion",content:(0,s.jsxs)("div",{className:"space-y-8",children:[(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-gray-900 dark:text-white mb-4",children:"Overview"}),(0,s.jsxs)("div",{className:"prose prose-lg dark:prose-dark max-w-none",children:[(0,s.jsx)("p",{children:"Variables are the fundamental building blocks of any Apex program. Think of them as labeled containers that store information your code can use and manipulate. Understanding data types and how to work with them effectively is crucial for building robust Salesforce applications."}),(0,s.jsxs)("p",{children:["In Apex, every variable must have a specific data type that determines what kind of information it can store. Apex is ",(0,s.jsx)("strong",{children:"strongly typed"}),", which means you must explicitly declare the type of every variable before you can use it."]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-gray-900 dark:text-white mb-4",children:"Core Concepts"}),(0,s.jsxs)("div",{className:"space-y-6",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-3",children:"What are Variables?"}),(0,s.jsxs)("div",{className:"prose dark:prose-dark max-w-none",children:[(0,s.jsx)("p",{children:"A variable is a named storage location in memory that holds data. In Apex, variables have three key characteristics:"}),(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Name"}),": A descriptive identifier you choose (like ",(0,s.jsx)("code",{children:"customerName"})," or ",(0,s.jsx)("code",{children:"totalPrice"}),")"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Type"}),": What kind of data it can store (String, Integer, Boolean, etc.)"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Value"}),": The actual data stored in the variable (can be null initially)"]})]})]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-3",children:"Data Types in Apex"}),(0,s.jsxs)("div",{className:"prose dark:prose-dark max-w-none",children:[(0,s.jsx)("p",{children:"Apex provides several built-in primitive data types:"}),(0,s.jsxs)("div",{className:"grid md:grid-cols-2 gap-4 my-4",children:[(0,s.jsxs)("div",{className:"p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-blue-900 dark:text-blue-100",children:"String"}),(0,s.jsx)("p",{className:"text-sm text-blue-800 dark:text-blue-200",children:"Text data and character sequences. Immutable with rich manipulation methods."})]}),(0,s.jsxs)("div",{className:"p-4 bg-green-50 dark:bg-green-900/20 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-green-900 dark:text-green-100",children:"Integer"}),(0,s.jsx)("p",{className:"text-sm text-green-800 dark:text-green-200",children:"Whole numbers (-2,147,483,648 to 2,147,483,647). Perfect for counts and IDs."})]}),(0,s.jsxs)("div",{className:"p-4 bg-purple-50 dark:bg-purple-900/20 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-purple-900 dark:text-purple-100",children:"Boolean"}),(0,s.jsx)("p",{className:"text-sm text-purple-800 dark:text-purple-200",children:"True/false values with three-valued logic (true/false/null)."})]}),(0,s.jsxs)("div",{className:"p-4 bg-orange-50 dark:bg-orange-900/20 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-orange-900 dark:text-orange-100",children:"Decimal"}),(0,s.jsx)("p",{className:"text-sm text-orange-800 dark:text-orange-200",children:"Precise decimal numbers. Ideal for financial calculations."})]})]})]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-3",children:"Variable Declaration Rules"}),(0,s.jsx)("div",{className:"prose dark:prose-dark max-w-none",children:(0,s.jsxs)("ol",{children:[(0,s.jsx)("li",{children:"Must specify access modifier (public, private, global)"}),(0,s.jsx)("li",{children:"Must declare data type before variable name"}),(0,s.jsx)("li",{children:"Can optionally initialize with a value"}),(0,s.jsx)("li",{children:"Variable names must follow naming conventions"})]})})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-gray-900 dark:text-white mb-6",children:"Complete Code Examples"}),(0,s.jsxs)("div",{className:"space-y-10",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"Basic Variable Declaration (Complete Class)"}),(0,s.jsx)(f,{code:'public class CustomerData {\n    // Class-level variables (instance variables)\n    private String customerName;\n    // ✅ WHAT:\n    //   - `private` = ACCESS MODIFIER (only this class can access)\n    //   - `String` = TEXT data type\n    //   - `customerName` = INSTANCE VARIABLE (camelCase naming)\n    // ✅ WHY:\n    //   - `private` = ENCAPSULATION (controlled access to data)\n    //   - Instance variables store object state\n    // \uD83D\uDCA5 EXAM TRAP:\n    //   - Forgetting access modifier = COMPILATION ERROR\n    //   - `String customerName` (no modifier) → COMPILE FAILS\n\n    private Integer age;\n    // ✅ WHAT:\n    //   - `Integer` = WHOLE NUMBER container (no decimals)\n    //   - Range: -2,147,483,648 to 2,147,483,647\n    // ✅ WHY:\n    //   - Age is always whole number, Integer prevents confusion\n    //   - `Integer` safer than `int` (handles null values)\n    // \uD83D\uDCA5 IF WRONG:\n    //   - `int age` → COMPILE ERROR (Apex uses `Integer`, not `int`)\n    //   - `Double age` → Allows decimals (25.5 years = confusing)\n\n    private Boolean isActive;\n    // ✅ WHAT:\n    //   - `Boolean` = TRUE/FALSE container\n    //   - `isActive` = DESCRIPTIVE name (starts with "is")\n    // ✅ WHY:\n    //   - `Boolean` = ONLY type for conditions (if/else)\n    //   - Naming convention makes boolean instantly recognizable\n    // \uD83D\uDCA5 IF WRONG:\n    //   - `boolean isActive` → COMPILE ERROR (must be `Boolean`)\n    //   - `active` (no "is" prefix) → unclear if boolean\n\n    private Decimal accountBalance;\n    // ✅ WHAT:\n    //   - `Decimal` = PRECISE decimal numbers\n    //   - Perfect for financial calculations\n    // ✅ WHY:\n    //   - `Decimal` avoids floating-point precision errors\n    //   - Never loses cents in money calculations\n    // \uD83D\uDCA5 EXAM TRAP:\n    //   - Using `Double` for money = PRECISION LOSS\n    //   - `$19.99` could become `$19.990000000000002`\n\n    // Constructor\n    public CustomerData(String name, Integer customerAge) {\n        // ✅ WHAT:\n        //   - `public` = ACCESSIBLE from outside class\n        //   - `CustomerData` = CONSTRUCTOR (same name as class)\n        //   - Parameters define required data for object creation\n        // ✅ WHY:\n        //   - Constructor INITIALIZES object state when created\n        //   - Called automatically with `new CustomerData(\'John\', 25)`\n        // \uD83D\uDCA5 IF WRONG:\n        //   - Wrong name → becomes regular method, not constructor\n        //   - No constructor → objects created with null values\n\n        this.customerName = name;\n        // ✅ WHAT:\n        //   - `this.customerName` = INSTANCE VARIABLE\n        //   - `name` = PARAMETER VALUE\n        //   - Assignment stores parameter in instance variable\n        // ✅ WHY:\n        //   - `this.` distinguishes between parameter and field\n        //   - Required when parameter name conflicts with field name\n        // \uD83D\uDCA5 IF WRONG:\n        //   - `customerName = name` → might work but unclear\n        //   - `name = name` → assigns parameter to itself (does nothing)\n\n        this.age = customerAge;\n        this.isActive = true;\n        // ✅ WHAT:\n        //   - Assign parameter value to instance variable\n        //   - Set default status to active for new customers\n        // ✅ WHY:\n        //   - Explicit initialization prevents null values\n        //   - Business rule: new customers start as active\n        // \uD83D\uDCA5 IF SKIPPED:\n        //   - Uninitialized variables default to NULL\n        //   - Math with null = NULL POINTER EXCEPTION\n\n        this.accountBalance = 0.0;\n        // ✅ WHAT:\n        //   - Initialize balance to zero decimal\n        //   - `0.0` creates Decimal, not Integer\n        // ✅ WHY:\n        //   - Prevents null pointer exceptions in calculations\n        //   - Safe starting point for financial operations\n        // \uD83D\uDCA5 IF SKIPPED:\n        //   - `Decimal balance; balance += 100` → NULL POINTER EXCEPTION\n        //   - `null + 100 = CRASH` (not 100!)\n    }\n\n    // Getter methods\n    public String getName() {\n        return this.customerName;\n        // ✅ WHAT:\n        //   - `public` = ACCESSIBLE from outside class\n        //   - `return` = SEND value back to caller\n        // ✅ WHY:\n        //   - Controlled access to private data (encapsulation)\n        //   - Read-only access prevents unauthorized modifications\n        // ✅ SECURITY:\n        //   - Caller can read but not directly modify private field\n    }\n\n    public Integer getAge() {\n        return this.age;\n        // ✅ WHAT:\n        //   - Simple getter for age field\n        // ✅ WHY:\n        //   - Consistent access pattern for all fields\n        //   - Could add validation logic later if needed\n    }\n}',annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"String Operations (Complete Example)"}),(0,s.jsx)(f,{code:"public class StringDemo {\n    public void demonstrateStrings() {\n        String firstName = 'John';\n        // ✅ WHAT:\n        //   - `String` = TEXT container for character sequences\n        //   - `'John'` = STRING LITERAL using single quotes\n        // ✅ WHY:\n        //   - `String` = ONLY type for text data in Apex\n        //   - Single quotes = Apex string syntax (not double quotes)\n        // \uD83D\uDCA5 IF WRONG:\n        //   `String name = \"John\"` → COMPILE ERROR (must use single quotes)\n\n        String lastName = 'Doe';\n        String fullName = firstName + ' ' + lastName;\n        // ✅ WHAT:\n        //   - `+` = STRING CONCATENATION operator\n        //   - `' '` = SPACE CHARACTER literal\n        // ✅ WHY:\n        //   - Simple way to join strings together\n        //   - Result: 'John Doe' (combined string)\n        // \uD83D\uDCA5 IF WRONG:\n        //   Missing space → 'JohnDoe' (no separation)\n\n        String companyName = firstName != null ? firstName + ' Corp' : 'Unknown';\n        // ✅ WHAT:\n        //   - `!=` = NULL CHECK (not equal to null)\n        //   - `? ... : ...` = TERNARY OPERATOR (inline if/else)\n        // ✅ WHY:\n        //   - Prevents NullPointerException when field is empty\n        //   - Shorter than full if/else block\n        // \uD83D\uDCA5 IF SKIPPED:\n        //   `String companyName = firstName + ' Corp'` → CRASH if firstName = null\n\n        String message = String.format('Hello {0}, you are {1} years old',\n                                       new List<String>{fullName, '25'});\n        // ✅ WHAT:\n        //   - `String.format()` = PARAMETERIZED string construction\n        //   - `{0}, {1}` = PLACEHOLDERS for values\n        //   - `new List<String>{}` = PARAMETER VALUES in order\n        // ✅ WHY:\n        //   - More readable than concatenation for complex strings\n        //   - Template-based approach reduces errors\n        // ✅ PERFORMANCE:\n        //   - More efficient than multiple concatenations\n\n        Boolean nameMatches = firstName.equals('John');\n        // ✅ WHAT:\n        //   - `.equals()` = STRING COMPARISON method\n        //   - Compares string CONTENT, not object references\n        // ✅ WHY:\n        //   - Safe comparison that handles null values\n        //   - Returns true/false based on actual text content\n        // \uD83D\uDCA5 EXAM TRAP:\n        //   - Using `==` compares references, not content\n        //   - `==` gives unpredictable results for strings\n\n        Boolean referenceCheck = firstName == 'John'; // DANGEROUS!\n        // ✅ WHAT:\n        //   - `==` = REFERENCE COMPARISON (object identity)\n        //   - Checks if two variables point to same object\n        // \uD83D\uDCA5 WHY DANGEROUS:\n        //   - `==` checks memory addresses, not string content\n        //   - Can return false even when strings look identical\n        // \uD83D\uDCA5 IF USED:\n        //   - Unpredictable results in production\n        //   - Exam questions test this heavily (automatic points lost)\n\n        Boolean nameExists = String.isNotBlank(fullName);\n        // ✅ WHAT:\n        //   - `String.isNotBlank()` = NULL-SAFE content check\n        //   - Returns false for null, empty (''), or whitespace ('   ')\n        // ✅ WHY:\n        //   - Safer than `fullName != null && fullName.length() > 0`\n        //   - Single method handles all edge cases\n        // ✅ BEST PRACTICE:\n        //   - Always use String.isBlank/isNotBlank for null-safe checks\n\n        String upperName = fullName.toUpperCase();\n        Integer nameLength = fullName.length();\n        // ✅ WHAT:\n        //   - `.toUpperCase()` = CONVERT to uppercase letters\n        //   - `.length()` = GET character count\n        // ✅ WHY:\n        //   - Common operations for formatting and validation\n        //   - `length()` useful for input validation\n\n        System.debug('Full name: ' + fullName);\n        System.debug('Message: ' + message);\n        // ✅ WHAT:\n        //   - `System.debug()` = OUTPUT to debug log\n        //   - Concatenation for displaying variable values\n        // ✅ WHY:\n        //   - Essential for development and troubleshooting\n        //   - Only appears in debug logs, not user interface\n    }\n}",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"Type Conversion with Error Handling"}),(0,s.jsx)(f,{code:"public class TypeConversionExample {\n    public void convertAndValidate(String input) {\n        try {\n            // ✅ WHAT:\n            //   - `try` = ATTEMPT potentially dangerous operations\n            //   - Code inside try block might throw exceptions\n            // ✅ WHY:\n            //   - Type conversions can FAIL with invalid input\n            //   - `Integer.valueOf('abc')` throws TypeException\n            // ✅ BEST PRACTICE:\n            //   - Always handle conversion exceptions in production\n            //   - Never assume user input is valid\n\n            Integer number = Integer.valueOf(input);\n            // ✅ WHAT:\n            //   - `Integer.valueOf()` = CONVERT string to integer\n            //   - Takes string parameter, returns Integer object\n            // ✅ WHY:\n            //   - Safer than casting, provides clear error messages\n            //   - Handles null input gracefully (returns null)\n            // \uD83D\uDCA5 EXAM TRAP:\n            //   - `valueOf()` throws TypeException for invalid input\n            //   - '123' → 123 (success), 'abc' → TypeException (crash)\n            // \uD83D\uDCA5 GOTCHA:\n            //   - `Integer.valueOf(null)` returns null (doesn't crash)\n            //   - `Integer.valueOf('')` throws exception (empty string fails)\n\n            System.debug('Converted number: ' + number);\n\n            String numberText = String.valueOf(number);\n            // ✅ WHAT:\n            //   - `String.valueOf()` = CONVERT any type to string\n            //   - Universal conversion method for all data types\n            // ✅ WHY:\n            //   - Safe conversion, NEVER throws exceptions\n            //   - Handles null values (returns 'null' string)\n            // ✅ WORKS WITH:\n            //   - Integer, Boolean, Decimal, Date, SObject, etc.\n            //   - `null` becomes `'null'` (4-character string)\n\n            System.debug('Back to string: ' + numberText);\n\n            Decimal price = 19.99;\n            Integer dollars = (Integer) Math.round(price);\n            // ✅ WHAT:\n            //   - `Math.round()` = ROUND decimal to nearest integer\n            //   - `(Integer)` = TYPE CAST Double result to Integer\n            // ✅ WHY:\n            //   - Proper rounding BEFORE conversion to whole number\n            //   - Financial calculations need precise rounding\n            // \uD83D\uDCA5 DIFFERENCE:\n            //   - Casting alone TRUNCATES: `(Integer) 19.99` → 19\n            //   - Round then cast ROUNDS: `(Integer) Math.round(19.99)` → 20\n            // ✅ FINANCIAL:\n            //   - Always round currency before casting to Integer\n            //   - Result: 19.99 → 20.0 → 20 (proper rounding)\n\n            System.debug('Rounded price: ' + dollars);\n\n            Boolean isValid = Boolean.valueOf('true');\n            // ✅ WHAT:\n            //   - `Boolean.valueOf()` = CONVERT string to Boolean\n            //   - Case-insensitive conversion ('TRUE', 'True', 'true' all work)\n            // ✅ WHY:\n            //   - Handles 'true'/'false' strings properly\n            //   - More explicit than manual string comparison\n            // \uD83D\uDCA5 GOTCHA:\n            //   - Only string 'true' (any case) returns true\n            //   - EVERYTHING else returns false: 'false', 'yes', 'Y', '1', null\n            //   - `Boolean.valueOf('yes')` → false (not true!)\n\n            System.debug('Boolean value: ' + isValid);\n\n        } catch (TypeException e) {\n            // ✅ WHAT:\n            //   - `catch` = HANDLE specific exception type\n            //   - `TypeException` = Conversion/casting errors\n            //   - `e` = Exception object with error details\n            // ✅ WHY:\n            //   - Graceful error handling prevents application crashes\n            //   - Provides specific error information for debugging\n            // ✅ PRODUCTION:\n            //   - Log error details for developer analysis\n            //   - Show user-friendly message (not technical details)\n\n            System.debug('Conversion failed: ' + e.getMessage());\n            // ✅ WHAT:\n            //   - `e.getMessage()` = GET error description\n            //   - Log the failure for debugging purposes\n            // ✅ WHY:\n            //   - Don't just ignore conversion failures silently\n            //   - Error details help identify input validation issues\n            // \uD83D\uDCA5 IF SKIPPED:\n            //   - Silent failures make bugs impossible to track\n            //   - Users get unexpected behavior with no explanation\n        }\n    }\n}",annotations:[]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-red-600 dark:text-red-400 mb-4",children:"\uD83D\uDC80 Common Gotchas"}),(0,s.jsxs)("div",{className:"space-y-6",children:[(0,s.jsxs)("div",{className:"p-6 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-red-900 dark:text-red-100 mb-2",children:"Forgetting Access Modifiers"}),(0,s.jsx)("p",{className:"text-red-800 dark:text-red-200 mb-4",children:"Variables must have access modifiers (public/private/global). Omitting them causes compilation errors."}),(0,s.jsxs)("div",{className:"grid md:grid-cols-2 gap-4",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-red-900 dark:text-red-100 mb-2",children:"❌ BAD"}),(0,s.jsx)(f,{code:"String name = 'John'; // Compilation error!",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-green-900 dark:text-green-100 mb-2",children:"✅ GOOD"}),(0,s.jsx)(f,{code:"private String name = 'John'; // Compiles successfully",annotations:[]})]})]})]}),(0,s.jsxs)("div",{className:"p-6 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-yellow-900 dark:text-yellow-100 mb-2",children:"String Quote Types"}),(0,s.jsx)("p",{className:"text-yellow-800 dark:text-yellow-200 mb-4",children:"Apex uses single quotes for string literals, not double quotes."}),(0,s.jsxs)("div",{className:"grid md:grid-cols-2 gap-4",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-red-900 dark:text-red-100 mb-2",children:"❌ BAD"}),(0,s.jsx)(f,{code:'String message = "Hello World"; // Compilation error!',annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-green-900 dark:text-green-100 mb-2",children:"✅ GOOD"}),(0,s.jsx)(f,{code:"String message = 'Hello World'; // Compiles successfully",annotations:[]})]})]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-yellow-600 dark:text-yellow-400 mb-4",children:"\uD83D\uDCA1 Exam Tips"}),(0,s.jsxs)("div",{className:"p-6 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-yellow-900 dark:text-yellow-100 mb-4",children:"High-Priority Certification Points"}),(0,s.jsxs)("div",{className:"prose dark:prose-dark max-w-none",children:[(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Access Modifiers"}),": Variables require explicit access modifiers (public/private/global)"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"String Literals"}),": Use single quotes for string values in Apex"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Integer Range"}),": -2,147,483,648 to 2,147,483,647 (know the limits)"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Boolean Logic"}),": Three-valued logic (true/false/null) - common exam topic"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Type Conversion"}),": Always handle TypeException in production code"]})]}),(0,s.jsx)("h4",{className:"mt-6 mb-3",children:"Common Exam Scenarios"}),(0,s.jsxs)("ul",{children:[(0,s.jsx)("li",{children:"Questions about uninitialized variable values (they're null, not default)"}),(0,s.jsx)("li",{children:"String comparison using == vs .equals() (use .equals() for content)"}),(0,s.jsx)("li",{children:"Type casting vs valueOf() methods (casting truncates, valueOf() may round)"}),(0,s.jsx)("li",{children:"Null checking patterns for Boolean variables"}),(0,s.jsx)("li",{children:"Access modifier requirements for class variables"})]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-purple-600 dark:text-purple-400 mb-4",children:"\uD83C\uDFAF Practice Exercises"}),(0,s.jsxs)("div",{className:"space-y-4",children:[(0,s.jsxs)("div",{className:"p-6 bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-purple-900 dark:text-purple-100 mb-2",children:"Exercise 1: Variable Declaration"}),(0,s.jsx)("p",{className:"text-purple-800 dark:text-purple-200",children:"Create a class with properly declared variables for a customer record: Customer name (String), Age (Integer), Account balance (Decimal), Is VIP status (Boolean)"})]}),(0,s.jsxs)("div",{className:"p-6 bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-purple-900 dark:text-purple-100 mb-2",children:"Exercise 2: Safe Type Conversion"}),(0,s.jsx)("p",{className:"text-purple-800 dark:text-purple-200",children:"Write a method that safely converts a string to an integer with proper error handling."})]}),(0,s.jsxs)("div",{className:"p-6 bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-purple-900 dark:text-purple-100 mb-2",children:"Exercise 3: Boolean Logic"}),(0,s.jsx)("p",{className:"text-purple-800 dark:text-purple-200",children:"Create a method that checks multiple Boolean conditions with null-safe logic."})]})]})]}),(0,s.jsxs)("div",{className:"mt-8 p-6 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-blue-900 dark:text-blue-100 mb-2",children:"\uD83C\uDF93 Key Takeaway"}),(0,s.jsx)("p",{className:"text-blue-800 dark:text-blue-200",children:"Understanding variables and data types is fundamental to all Apex programming. Master these concepts thoroughly - every line of Apex code you write will use these building blocks!"})]})]})},{id:"collections",title:"Collections Deep Dive",icon:c.Z,description:"Master Lists, Sets, Maps and bulkification patterns",content:(0,s.jsxs)("div",{className:"space-y-8",children:[(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-gray-900 dark:text-white mb-4",children:"\uD83D\uDD17 Building on Variables"}),(0,s.jsxs)("div",{className:"p-6 bg-gradient-to-r from-green-50 to-blue-50 dark:from-green-900/20 dark:to-blue-900/20 border border-green-200 dark:border-green-700 rounded-lg",children:[(0,s.jsxs)("p",{className:"text-gray-700 dark:text-gray-300 leading-relaxed mb-4",children:[(0,s.jsx)("strong",{children:"You just learned:"})," Variables hold ONE value at a time (",(0,s.jsx)("code",{children:"String name = 'John'"}),")"]}),(0,s.jsxs)("p",{className:"text-gray-700 dark:text-gray-300 leading-relaxed",children:[(0,s.jsx)("strong",{children:"Now you'll learn:"})," Collections hold MULTIPLE values of the same type (",(0,s.jsxs)("code",{children:["List<String> names = new List<String>","{'John', 'Jane', 'Bob'}"]}),")"]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-gray-900 dark:text-white mb-4",children:"Core Concepts"}),(0,s.jsxs)("div",{className:"space-y-6",children:[(0,s.jsxs)("div",{className:"p-6 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-3",children:"Why Collections Matter"}),(0,s.jsxs)("div",{className:"prose dark:prose-dark max-w-none",children:[(0,s.jsxs)("p",{children:[(0,s.jsx)("strong",{children:"Real-world problem:"})," You need to process 200 Contact records. Without collections, you'd need 200 separate variables!"]}),(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Variables:"})," Hold ONE value → ",(0,s.jsx)("code",{children:"String contact1Name, contact2Name, contact3Name..."})," (impossible to manage)"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Collections:"})," Hold MANY values → ",(0,s.jsx)("code",{children:"List<String> allContactNames"})," (clean and manageable)"]})]})]})]}),(0,s.jsxs)("div",{className:"grid md:grid-cols-3 gap-6",children:[(0,s.jsxs)("div",{className:"p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-blue-900 dark:text-blue-100 mb-2",children:"\uD83D\uDCCB Lists"}),(0,s.jsxs)("p",{className:"text-sm text-blue-800 dark:text-blue-200 mb-2",children:[(0,s.jsx)("strong",{children:"WHEN:"})," Order matters, duplicates allowed"]}),(0,s.jsxs)("p",{className:"text-sm text-blue-800 dark:text-blue-200",children:[(0,s.jsx)("strong",{children:"EXAMPLE:"})," Task priorities, transaction history"]})]}),(0,s.jsxs)("div",{className:"p-4 bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-700 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-purple-900 dark:text-purple-100 mb-2",children:"\uD83C\uDFAF Sets"}),(0,s.jsxs)("p",{className:"text-sm text-purple-800 dark:text-purple-200 mb-2",children:[(0,s.jsx)("strong",{children:"WHEN:"})," Uniqueness required, fast lookup"]}),(0,s.jsxs)("p",{className:"text-sm text-purple-800 dark:text-purple-200",children:[(0,s.jsx)("strong",{children:"EXAMPLE:"})," Unique email addresses, processed IDs"]})]}),(0,s.jsxs)("div",{className:"p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-700 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-green-900 dark:text-green-100 mb-2",children:"\uD83D\uDDFA️ Maps"}),(0,s.jsxs)("p",{className:"text-sm text-green-800 dark:text-green-200 mb-2",children:[(0,s.jsx)("strong",{children:"WHEN:"})," Key-value relationships, fast retrieval"]}),(0,s.jsxs)("p",{className:"text-sm text-green-800 dark:text-green-200",children:[(0,s.jsx)("strong",{children:"EXAMPLE:"})," Account ID → Account Name"]})]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-gray-900 dark:text-white mb-6",children:"Complete Code Examples"}),(0,s.jsxs)("div",{className:"space-y-10",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"Lists - Managing Multiple Values"}),(0,s.jsx)(f,{code:"public class ListDemo {\n    public void demonstrateLists() {\n        // ✅ BUILDING ON: You know String variables hold one text value\n        String singleName = 'John';\n        // ✅ WHAT: One variable = one value (what you already know)\n\n        // ✅ NEW CONCEPT: List holds MULTIPLE values of same type\n        List<String> allNames = new List<String>();\n        // ✅ WHAT:\n        //   - `List<String>` = CONTAINER for multiple text values\n        //   - `new List<String>()` = CREATE empty container\n        // ✅ WHY List<String>:\n        //   - Tells Apex \"this list only holds text values\"\n        //   - Prevents mixing types (can't accidentally add numbers)\n        // \uD83D\uDCA5 EXAM TRAP:\n        //   - `List names;` (without <String>) = COMPILATION ERROR\n        //   - Must specify what TYPE the list contains\n\n        // ✅ ADDING VALUES: Build the list step by step\n        allNames.add('John');\n        allNames.add('Jane');\n        allNames.add('Bob');\n        // ✅ WHAT:\n        //   - `.add()` = PUT values INTO the list\n        //   - Each call adds one more value to the end\n        // ✅ WHY:\n        //   - Lists maintain ORDER: John=position 0, Jane=1, Bob=2\n        //   - Order matters for processing sequences\n        // \uD83D\uDCA5 IF WRONG:\n        //   - `allNames.add(25);` → COMPILE ERROR (25 is Integer, not String)\n\n        // ✅ ALTERNATIVE: Initialize with values directly\n        List<String> quickNames = new List<String>{'Alice', 'Charlie', 'Diana'};\n        // ✅ WHAT:\n        //   - Creates list AND adds values in one line\n        //   - Curly braces `{}` contain initial values\n        // ✅ WHY:\n        //   - More efficient than multiple .add() calls\n        //   - Cleaner when you know values upfront\n\n        // ✅ ACCESSING VALUES: Get specific items by position\n        if (allNames.size() > 0) {\n            // ✅ WHAT:\n            //   - `.size()` = COUNT how many items in list\n            //   - Check prevents \"index out of bounds\" errors\n            // ✅ WHY size() check FIRST:\n            //   - Empty list has size 0\n            //   - `.get(0)` on empty list = CRASH\n            // \uD83D\uDCA5 IF SKIPPED:\n            //   - `allNames.get(0)` on empty list → LIST EXCEPTION\n\n            String firstName = allNames.get(0);\n            String lastName = allNames.get(allNames.size() - 1);\n            // ✅ WHAT:\n            //   - `.get(0)` = GET first item (position 0)\n            //   - `.get(size() - 1)` = GET last item\n            // ✅ WHY:\n            //   - Lists start counting at 0, not 1\n            //   - Last position = total count minus 1\n            // \uD83D\uDCA5 EXAM TRAP:\n            //   - `.get(allNames.size())` → INDEX OUT OF BOUNDS (too high by 1)\n\n            System.debug('First: ' + firstName + ', Last: ' + lastName);\n        }\n\n        // ✅ PROCESSING ALL VALUES: Loop through entire list\n        for (String currentName : allNames) {\n            // ✅ WHAT:\n            //   - `for (String currentName : allNames)` = ENHANCED FOR LOOP\n            //   - `currentName` = TEMPORARY variable for each item\n            // ✅ WHY:\n            //   - Automatically goes through every item in order\n            //   - No need to track positions or worry about boundaries\n            // ✅ PERFORMANCE:\n            //   - More efficient than traditional for loops\n            //   - Reads each item exactly once\n\n            System.debug('Processing name: ' + currentName);\n\n            // Real-world example: Format each name\n            String formattedName = currentName.toUpperCase();\n            System.debug('Formatted: ' + formattedName);\n        }\n\n        // ✅ LIST METHODS: Common operations you'll use constantly\n        Boolean hasJohn = allNames.contains('John');\n        // ✅ WHAT: Check if specific value exists in list\n        // ✅ WHY: Avoids manual loops for simple existence checks\n\n        Integer position = allNames.indexOf('Jane');\n        // ✅ WHAT: Find POSITION of value (returns -1 if not found)\n        // ✅ WHY: Useful for conditional processing based on position\n\n        allNames.remove(1); // Removes 'Jane' (position 1)\n        // ✅ WHAT: Remove item at specific position\n        // ✅ WHY: Lists automatically shift remaining items down\n        // \uD83D\uDCA5 GOTCHA: After removal, all positions change!\n\n        System.debug('Final list size: ' + allNames.size());\n    }\n}",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"Sets - Enforcing Uniqueness"}),(0,s.jsx)(f,{code:"public class SetDemo {\n    public void demonstrateSets() {\n        // ✅ BUILDING ON: Lists allow duplicates, Sets enforce uniqueness\n        List<String> listWithDuplicates = new List<String>{'John', 'Jane', 'John'};\n        // ✅ WHAT: This list happily contains 'John' twice\n        // ✅ PROBLEM: Sometimes duplicates cause business logic errors\n\n        // ✅ NEW CONCEPT: Set automatically prevents duplicates\n        Set<String> uniqueNames = new Set<String>();\n        // ✅ WHAT:\n        //   - `Set<String>` = CONTAINER for unique text values only\n        //   - No duplicates allowed, ever\n        // ✅ WHY:\n        //   - Perfect for tracking processed IDs\n        //   - Ensures business rules about uniqueness\n        // ✅ PERFORMANCE:\n        //   - `.contains()` is MUCH faster than List (no loop needed)\n\n        // ✅ ADDING VALUES: Duplicates ignored automatically\n        uniqueNames.add('John');\n        uniqueNames.add('Jane');\n        uniqueNames.add('John'); // This is IGNORED (duplicate)\n        uniqueNames.add('Bob');\n        // ✅ WHAT:\n        //   - `.add()` attempts to add value\n        //   - Returns true if added, false if duplicate\n        // ✅ WHY:\n        //   - Set only contains: {'John', 'Jane', 'Bob'}\n        //   - Size is 3, not 4 (second 'John' ignored)\n        // \uD83D\uDCA5 EXAM TRAP:\n        //   - Don't assume .add() always increases size!\n\n        System.debug('Set size: ' + uniqueNames.size()); // Prints 3, not 4\n\n        // ✅ REAL-WORLD EXAMPLE: Remove duplicates from List\n        List<String> emailsWithDuplicates = new List<String>{\n            'john@email.com', 'jane@email.com', 'john@email.com', 'bob@email.com'\n        };\n        // ✅ PROBLEM: Email list has duplicates (bad for marketing)\n\n        Set<String> uniqueEmails = new Set<String>(emailsWithDuplicates);\n        // ✅ WHAT:\n        //   - `new Set<String>(listVariable)` = CONVERT List to Set\n        //   - Automatically removes duplicates during conversion\n        // ✅ WHY:\n        //   - One line of code fixes duplicate problem\n        //   - Much faster than manual loop checking\n\n        List<String> cleanEmailList = new List<String>(uniqueEmails);\n        // ✅ WHAT:\n        //   - `new List<String>(setVariable)` = CONVERT Set back to List\n        //   - Now you have List without duplicates\n        // ✅ WHY:\n        //   - Sometimes you need List features (ordering, indexing)\n        //   - But want Set's duplicate removal\n\n        System.debug('Original emails: ' + emailsWithDuplicates.size());\n        System.debug('Unique emails: ' + cleanEmailList.size());\n\n        // ✅ SET OPERATIONS: Fast lookups and membership testing\n        Boolean hasJohn = uniqueNames.contains('John');\n        // ✅ WHAT: Check if value exists in set\n        // ✅ WHY: MUCH faster than List.contains() for large datasets\n        // ✅ PERFORMANCE: O(1) vs O(n) - constant time vs linear time\n\n        // ✅ PRACTICAL EXAMPLE: Track processed record IDs\n        Set<Id> processedAccountIds = new Set<Id>();\n        // ✅ WHAT: Track which Account records we've already handled\n        // ✅ WHY: Prevents duplicate processing in complex business logic\n\n        // Simulate processing accounts\n        List<Account> accounts = [SELECT Id, Name FROM Account LIMIT 5];\n        for (Account acc : accounts) {\n            if (!processedAccountIds.contains(acc.Id)) {\n                // ✅ WHAT: Only process if we haven't seen this ID before\n                // ✅ WHY: Prevents infinite loops and duplicate work\n\n                System.debug('Processing account: ' + acc.Name);\n                processedAccountIds.add(acc.Id);\n                // ✅ WHAT: Mark this ID as processed\n                // ✅ WHY: Future checks will skip this account\n            }\n        }\n\n        // ✅ SET ITERATION: Process each unique value\n        for (String email : uniqueEmails) {\n            // ✅ WHAT: Loop through each unique email\n            // ✅ WHY: Guaranteed no duplicates to handle\n            // \uD83D\uDCA5 GOTCHA: Sets have NO guaranteed order (unlike Lists)\n\n            System.debug('Sending newsletter to: ' + email);\n        }\n    }\n}",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"Maps - Key-Value Relationships"}),(0,s.jsx)(f,{code:"public class MapDemo {\n    public void demonstrateMaps() {\n        // ✅ BUILDING ON: Lists/Sets hold values, Maps connect keys to values\n        List<String> accountNames = new List<String>{'Acme Corp', 'Global Inc'};\n        // ✅ PROBLEM: How do you connect account ID to account name?\n        // ✅ SOLUTION: Maps create key → value relationships\n\n        // ✅ NEW CONCEPT: Map stores key-value pairs\n        Map<Id, String> accountIdToName = new Map<Id, String>();\n        // ✅ WHAT:\n        //   - `Map<Id, String>` = ID keys pointing to String values\n        //   - Each ID maps to exactly one name\n        // ✅ WHY:\n        //   - Fast lookup: give me ID, get back name instantly\n        //   - Perfect for relating Salesforce records\n        // ✅ PERFORMANCE:\n        //   - Lookup by key is O(1) - constant time, super fast\n\n        // ✅ ADDING KEY-VALUE PAIRS: Build relationships\n        // Note: Using fake IDs for demonstration\n        Id acmeId = '001000000000001';\n        Id globalId = '001000000000002';\n\n        accountIdToName.put(acmeId, 'Acme Corp');\n        accountIdToName.put(globalId, 'Global Inc');\n        // ✅ WHAT:\n        //   - `.put(key, value)` = CREATE or UPDATE relationship\n        //   - Key acmeId now points to 'Acme Corp'\n        // ✅ WHY:\n        //   - Maps store relationships, not just individual values\n        //   - Each key can only have ONE value (overwrites if repeated)\n        // \uD83D\uDCA5 EXAM TRAP:\n        //   - `map.put(sameKey, newValue)` OVERWRITES old value\n\n        // ✅ ALTERNATIVE: Initialize with values directly\n        Map<String, Integer> scoreMap = new Map<String, Integer>{\n            'John' => 95,\n            'Jane' => 87,\n            'Bob' => 92\n        };\n        // ✅ WHAT:\n        //   - Creates map AND adds pairs in one line\n        //   - `=>` connects key to value\n        // ✅ WHY:\n        //   - Cleaner syntax when you know relationships upfront\n        //   - More readable than multiple .put() calls\n\n        // ✅ RETRIEVING VALUES: Get value by providing key\n        String acmeName = accountIdToName.get(acmeId);\n        // ✅ WHAT:\n        //   - `.get(key)` = RETRIEVE value associated with key\n        //   - Returns the value, or null if key doesn't exist\n        // ✅ WHY:\n        //   - Instant lookup - no loops needed\n        //   - Much faster than searching through Lists\n        // \uD83D\uDCA5 GOTCHA:\n        //   - `.get(nonExistentKey)` returns NULL (doesn't crash)\n\n        // ✅ SAFE RETRIEVAL: Always check for null\n        Id unknownId = '001000000000999';\n        String unknownName = accountIdToName.get(unknownId);\n        if (unknownName != null) {\n            System.debug('Found account: ' + unknownName);\n        } else {\n            System.debug('Account not found for ID: ' + unknownId);\n        }\n        // ✅ WHAT:\n        //   - Check if .get() returned actual value or null\n        //   - Handle both cases appropriately\n        // ✅ WHY:\n        //   - Prevents null pointer exceptions\n        //   - Makes code defensive and robust\n        // \uD83D\uDCA5 IF SKIPPED:\n        //   - `unknownName.toUpperCase()` → NULL POINTER EXCEPTION\n\n        // ✅ ALTERNATIVE: containsKey() for existence checking\n        if (accountIdToName.containsKey(acmeId)) {\n            String safeName = accountIdToName.get(acmeId);\n            System.debug('Definitely found: ' + safeName);\n        }\n        // ✅ WHAT:\n        //   - `.containsKey()` = CHECK if key exists (true/false)\n        //   - Only call .get() after confirming key exists\n        // ✅ WHY:\n        //   - More explicit than null checking\n        //   - Separates existence check from value retrieval\n\n        // ✅ REAL-WORLD BULKIFICATION PATTERN\n        List<Contact> contacts = [SELECT Id, AccountId, Name FROM Contact LIMIT 100];\n\n        // Step 1: Collect all unique Account IDs\n        Set<Id> accountIds = new Set<Id>();\n        for (Contact con : contacts) {\n            if (con.AccountId != null) {\n                accountIds.add(con.AccountId);\n            }\n        }\n        // ✅ WHAT:\n        //   - Extract all Account IDs from Contact records\n        //   - Set automatically handles duplicates\n        // ✅ WHY:\n        //   - Prepare for bulk query (no loops in loops)\n        //   - Only query for IDs we actually need\n\n        // Step 2: Bulk query Account names\n        Map<Id, Account> accountMap = new Map<Id, Account>(\n            [SELECT Id, Name FROM Account WHERE Id IN :accountIds]\n        );\n        // ✅ WHAT:\n        //   - `new Map<Id, Account>(queryResult)` = SOQL to Map conversion\n        //   - Automatically creates ID → Account mappings\n        // ✅ WHY:\n        //   - ONE query instead of 100 separate queries\n        //   - Governor limit friendly (max 100 SOQL per transaction)\n        // ✅ PERFORMANCE:\n        //   - Bulk query: ~5ms, Individual queries: ~500ms\n\n        // Step 3: Process all Contacts with Account names\n        for (Contact con : contacts) {\n            Account relatedAccount = accountMap.get(con.AccountId);\n            if (relatedAccount != null) {\n                System.debug(con.Name + ' works at ' + relatedAccount.Name);\n            } else {\n                System.debug(con.Name + ' has no account');\n            }\n        }\n        // ✅ WHAT:\n        //   - Use map for instant Account lookup per Contact\n        //   - No additional queries needed\n        // ✅ WHY:\n        //   - Processes 100 Contacts with 1 query, not 100 queries\n        //   - Scalable pattern for any volume of data\n        // \uD83D\uDCA5 WITHOUT MAPS:\n        //   - Would need query inside loop = GOVERNOR LIMIT EXCEEDED\n\n        // ✅ MAP UTILITY METHODS: Working with keys and values\n        Set<Id> allAccountIds = accountIdToName.keySet();\n        // ✅ WHAT: Get all keys from map as a Set\n        // ✅ WHY: Useful for bulk operations on all keys\n\n        List<String> allAccountNames = accountIdToName.values();\n        // ✅ WHAT: Get all values from map as a List\n        // ✅ WHY: Process all values without caring about keys\n\n        System.debug('Map size: ' + accountIdToName.size());\n        System.debug('Keys: ' + allAccountIds);\n        System.debug('Values: ' + allAccountNames);\n    }\n}",annotations:[]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-red-600 dark:text-red-400 mb-4",children:"\uD83D\uDC80 Common Gotchas"}),(0,s.jsxs)("div",{className:"space-y-6",children:[(0,s.jsxs)("div",{className:"p-6 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-red-900 dark:text-red-100 mb-2",children:"Index Out of Bounds"}),(0,s.jsx)("p",{className:"text-red-800 dark:text-red-200 mb-4",children:"Lists crash when you try to access positions that don't exist."}),(0,s.jsxs)("div",{className:"grid md:grid-cols-2 gap-4",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-red-900 dark:text-red-100 mb-2",children:"\uD83D\uDC80 DANGEROUS"}),(0,s.jsx)(f,{code:"List<String> names = new List<String>{'John'};\nString second = names.get(1); // CRASH! Only position 0 exists",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-green-900 dark:text-green-100 mb-2",children:"✅ SAFE"}),(0,s.jsx)(f,{code:"List<String> names = new List<String>{'John'};\nif (names.size() > 1) {\n    String second = names.get(1);\n}",annotations:[]})]})]})]}),(0,s.jsxs)("div",{className:"p-6 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-yellow-900 dark:text-yellow-100 mb-2",children:"Map.get() Returns Null"}),(0,s.jsx)("p",{className:"text-yellow-800 dark:text-yellow-200 mb-4",children:"Maps don't crash for missing keys, they return null."}),(0,s.jsxs)("div",{className:"grid md:grid-cols-2 gap-4",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-red-900 dark:text-red-100 mb-2",children:"\uD83D\uDC80 DANGEROUS"}),(0,s.jsx)(f,{code:"Map<Id, String> names = new Map<Id, String>();\nString name = names.get(someId);\nInteger length = name.length(); // CRASH if someId not in map",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-green-900 dark:text-green-100 mb-2",children:"✅ SAFE"}),(0,s.jsx)(f,{code:"Map<Id, String> names = new Map<Id, String>();\nString name = names.get(someId);\nif (name != null) {\n    Integer length = name.length();\n}",annotations:[]})]})]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-green-600 dark:text-green-400 mb-4",children:"\uD83C\uDF0D Real-World Application"}),(0,s.jsxs)("div",{className:"p-6 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-green-900 dark:text-green-100 mb-4",children:"Why This Matters in Production"}),(0,s.jsxs)("div",{className:"prose dark:prose-dark max-w-none",children:[(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Lists:"})," Processing form submissions, managing workflow steps, storing calculation results"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Sets:"})," Preventing duplicate email sends, tracking processed records, enforcing business rules"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Maps:"})," Relating child records to parents, caching lookup values, building bulk operations"]})]}),(0,s.jsxs)("p",{className:"mt-4",children:[(0,s.jsx)("strong",{children:"Critical for Governor Limits:"})," Collections enable bulk processing that stays within Salesforce's execution limits. Without them, your code crashes in production."]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-blue-600 dark:text-blue-400 mb-4",children:"\uD83D\uDE80 Next Steps"}),(0,s.jsxs)("div",{className:"p-6 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg",children:[(0,s.jsxs)("p",{className:"text-blue-800 dark:text-blue-200 mb-4",children:[(0,s.jsx)("strong",{children:"You now have data in Lists, Sets, and Maps."})," Next, you'll learn ",(0,s.jsx)("strong",{children:"Control Flow"})," - how to make decisions and process that data efficiently with if/else statements and loops."]}),(0,s.jsxs)("p",{className:"text-blue-800 dark:text-blue-200",children:["Control Flow will teach you: ",(0,s.jsx)("em",{children:'"How do you process 200 Lead records and update only the qualified ones?"'})]})]})]})]})},{id:"control-flow",title:"Control Flow",icon:l.Z,description:"If/else, loops, switch statements and flow control",content:(0,s.jsxs)("div",{className:"space-y-8",children:[(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-gray-900 dark:text-white mb-4",children:"\uD83D\uDD17 Building on Collections"}),(0,s.jsxs)("div",{className:"p-6 bg-gradient-to-r from-blue-50 to-purple-50 dark:from-blue-900/20 dark:to-purple-900/20 border border-blue-200 dark:border-blue-700 rounded-lg",children:[(0,s.jsxs)("p",{className:"text-gray-700 dark:text-gray-300 leading-relaxed mb-4",children:[(0,s.jsx)("strong",{children:"You just learned:"})," How to store multiple values in Lists, Sets, and Maps"]}),(0,s.jsxs)("p",{className:"text-gray-700 dark:text-gray-300 leading-relaxed",children:[(0,s.jsx)("strong",{children:"Now you'll learn:"})," How to make decisions about that data and process it efficiently with if/else, loops, and flow control"]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-gray-900 dark:text-white mb-4",children:"Core Concepts"}),(0,s.jsxs)("div",{className:"space-y-6",children:[(0,s.jsxs)("div",{className:"p-6 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-3",children:"Why Control Flow Matters"}),(0,s.jsxs)("div",{className:"prose dark:prose-dark max-w-none",children:[(0,s.jsxs)("p",{children:[(0,s.jsx)("strong",{children:"Real-world problem:"}),' "Process 200 Lead records, but only update the qualified ones with score greater than 50."']}),(0,s.jsxs)("p",{children:[(0,s.jsx)("strong",{children:"Solution:"})," Control flow lets you make decisions (if/else) and repeat actions (loops) to handle complex business logic efficiently."]})]})]}),(0,s.jsxs)("div",{className:"grid md:grid-cols-3 gap-6",children:[(0,s.jsxs)("div",{className:"p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-700 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-green-900 dark:text-green-100 mb-2",children:"\uD83E\uDD14 Decisions"}),(0,s.jsxs)("p",{className:"text-sm text-green-800 dark:text-green-200 mb-2",children:[(0,s.jsx)("strong",{children:"IF/ELSE:"})," Different actions based on conditions"]}),(0,s.jsxs)("p",{className:"text-sm text-green-800 dark:text-green-200",children:[(0,s.jsx)("strong",{children:"SWITCH:"})," Multiple options efficiently"]})]}),(0,s.jsxs)("div",{className:"p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-blue-900 dark:text-blue-100 mb-2",children:"\uD83D\uDD04 Repetition"}),(0,s.jsxs)("p",{className:"text-sm text-blue-800 dark:text-blue-200 mb-2",children:[(0,s.jsx)("strong",{children:"FOR LOOPS:"})," Process collections or count"]}),(0,s.jsxs)("p",{className:"text-sm text-blue-800 dark:text-blue-200",children:[(0,s.jsx)("strong",{children:"WHILE:"})," Repeat until condition changes"]})]}),(0,s.jsxs)("div",{className:"p-4 bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-700 rounded-lg",children:[(0,s.jsx)("h4",{className:"font-semibold text-purple-900 dark:text-purple-100 mb-2",children:"⚡ Flow Control"}),(0,s.jsxs)("p",{className:"text-sm text-purple-800 dark:text-purple-200 mb-2",children:[(0,s.jsx)("strong",{children:"BREAK/CONTINUE:"})," Alter loop behavior"]}),(0,s.jsxs)("p",{className:"text-sm text-purple-800 dark:text-purple-200",children:[(0,s.jsx)("strong",{children:"RETURN:"})," Exit methods early"]})]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-gray-900 dark:text-white mb-6",children:"Complete Code Examples"}),(0,s.jsxs)("div",{className:"space-y-10",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"Making Decisions with If/Else"}),(0,s.jsx)(f,{code:"public class DecisionMaker {\n    public void processLeadScores() {\n        // ✅ BUILDING ON: You have a List of Lead records (from Collections)\n        List<Lead> allLeads = [SELECT Id, Name, Score__c, Status FROM Lead LIMIT 100];\n        // ✅ WHAT: Query returns List of Lead records with score data\n        // ✅ WHY: Real-world scenario - process multiple leads efficiently\n\n        // ✅ DECISION-MAKING: Process each lead with business logic\n        for (Lead currentLead : allLeads) {\n            // ✅ WHAT: Enhanced for loop processes each Lead in the List\n            // ✅ WHY: Iterate through collection to apply business rules\n\n            // ✅ BASIC IF/ELSE: Make decisions based on lead score\n            if (currentLead.Score__c >= 80) {\n                // ✅ WHAT:\n                //   - `if` = CHECK condition first\n                //   - `currentLead.Score__c >= 80` = BOOLEAN EXPRESSION\n                // ✅ WHY:\n                //   - High-value leads get priority treatment\n                //   - Business rule: 80+ score = hot lead\n                // \uD83D\uDCA5 EXAM TRAP:\n                //   - Always check for null: `if (currentLead.Score__c != null && currentLead.Score__c >= 80)`\n\n                currentLead.Status = 'Hot Lead';\n                currentLead.Priority__c = 'High';\n                System.debug('HOT: ' + currentLead.Name + ' (Score: ' + currentLead.Score__c + ')');\n\n            } else if (currentLead.Score__c >= 50) {\n                // ✅ WHAT:\n                //   - `else if` = ADDITIONAL condition if first fails\n                //   - Only checked if previous condition was false\n                // ✅ WHY:\n                //   - Different treatment for medium-value leads\n                //   - Sequential decision making\n\n                currentLead.Status = 'Warm Lead';\n                currentLead.Priority__c = 'Medium';\n                System.debug('WARM: ' + currentLead.Name + ' (Score: ' + currentLead.Score__c + ')');\n\n            } else if (currentLead.Score__c > 0) {\n                // ✅ WHAT: Handle low-value but positive scores\n                // ✅ WHY: Still has some potential, different strategy\n\n                currentLead.Status = 'Cold Lead';\n                currentLead.Priority__c = 'Low';\n                System.debug('COLD: ' + currentLead.Name + ' (Score: ' + currentLead.Score__c + ')');\n\n            } else {\n                // ✅ WHAT:\n                //   - `else` = CATCH-ALL for any remaining cases\n                //   - Executes if ALL previous conditions failed\n                // ✅ WHY:\n                //   - Handle edge cases (null scores, zero scores, negative)\n                //   - Defensive programming - always have a fallback\n\n                currentLead.Status = 'Unqualified';\n                currentLead.Priority__c = 'None';\n                System.debug('UNQUALIFIED: ' + currentLead.Name + ' (Score: ' + currentLead.Score__c + ')');\n            }\n\n            // ✅ COMPLEX CONDITIONS: Multiple criteria with logical operators\n            Boolean isActive = currentLead.IsActive__c;\n            Integer daysSinceContact = currentLead.Days_Since_Contact__c;\n\n            if (isActive && daysSinceContact <= 7 && currentLead.Score__c >= 60) {\n                // ✅ WHAT:\n                //   - `&&` = LOGICAL AND (all conditions must be true)\n                //   - Combines three different boolean expressions\n                // ✅ WHY:\n                //   - Complex business rules require multiple criteria\n                //   - All conditions must pass for special treatment\n                // \uD83D\uDCA5 EXAM TRAP:\n                //   - `&&` vs `||` (AND vs OR) - different meanings!\n\n                currentLead.Follow_Up_Required__c = true;\n                System.debug('IMMEDIATE FOLLOW-UP: ' + currentLead.Name);\n\n            } else if (isActive || currentLead.Score__c >= 90) {\n                // ✅ WHAT:\n                //   - `||` = LOGICAL OR (any condition can be true)\n                //   - Either active OR high score triggers this\n                // ✅ WHY:\n                //   - Flexible criteria - multiple paths to qualification\n                //   - Business rule: active leads OR super high scores get attention\n\n                currentLead.Follow_Up_Required__c = true;\n                currentLead.Follow_Up_Days__c = 3;\n                System.debug('FOLLOW-UP SCHEDULED: ' + currentLead.Name);\n\n            } else {\n                // ✅ WHAT: Default action when complex conditions not met\n                currentLead.Follow_Up_Required__c = false;\n                System.debug('NO FOLLOW-UP: ' + currentLead.Name);\n            }\n\n            // ✅ NULL-SAFE CONDITIONS: Defensive programming\n            if (String.isNotBlank(currentLead.Email)) {\n                // ✅ WHAT:\n                //   - `String.isNotBlank()` = NULL-SAFE string checking\n                //   - Returns false for null, empty (''), or whitespace ('   ')\n                // ✅ WHY:\n                //   - Prevents null pointer exceptions\n                //   - More robust than `currentLead.Email != null`\n                // \uD83D\uDCA5 IF WRONG:\n                //   - `currentLead.Email.contains('@')` → CRASH if Email is null\n\n                System.debug('CAN EMAIL: ' + currentLead.Email);\n                currentLead.Email_Valid__c = currentLead.Email.contains('@');\n\n            } else {\n                System.debug('NO EMAIL: ' + currentLead.Name);\n                currentLead.Email_Valid__c = false;\n            }\n        }\n\n        // ✅ BULK UPDATE: Apply all changes efficiently\n        update allLeads;\n        // ✅ WHAT: Single DML operation updates all modified records\n        // ✅ WHY: Governor limit friendly - 1 DML instead of 100\n        // ✅ PERFORMANCE: Bulk operations are much faster\n    }\n}",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"Switch Statements for Multiple Options"}),(0,s.jsx)(f,{code:"public class StatusProcessor {\n    public void processAccountsByType() {\n        // ✅ BUILDING ON: You have Map of Account data (from Collections)\n        Map<Id, Account> accountMap = new Map<Id, Account>(\n            [SELECT Id, Name, Type, Industry FROM Account LIMIT 50]\n        );\n        // ✅ WHAT: Map enables fast lookups by Account ID\n        // ✅ WHY: Efficient processing of related records\n\n        // ✅ SWITCH STATEMENT: Efficient multi-way decisions\n        for (Account acc : accountMap.values()) {\n            String processingPriority;\n            Decimal discountRate;\n\n            // ✅ SWITCH ON STRING: Handle account types efficiently\n            switch on acc.Type {\n                // ✅ WHAT:\n                //   - `switch on variable` = EVALUATE variable against cases\n                //   - Much faster than multiple if/else for many options\n                // ✅ WHY:\n                //   - Cleaner syntax than long if/else chains\n                //   - Better performance for 3+ options\n                // ✅ PERFORMANCE:\n                //   - O(1) lookup vs O(n) if/else chain\n\n                when 'Customer - Direct' {\n                    processingPriority = 'High';\n                    discountRate = 0.15;\n                    acc.Processing_Notes__c = 'Direct customer - priority support';\n                }\n                when 'Customer - Channel' {\n                    processingPriority = 'Medium';\n                    discountRate = 0.10;\n                    acc.Processing_Notes__c = 'Channel customer - standard support';\n                }\n                when 'Prospect' {\n                    processingPriority = 'Low';\n                    discountRate = 0.05;\n                    acc.Processing_Notes__c = 'Prospect - nurture campaign';\n                }\n                when 'Partner', 'Reseller' {\n                    // ✅ WHAT:\n                    //   - MULTIPLE VALUES in single case (comma-separated)\n                    //   - Both 'Partner' and 'Reseller' execute this code\n                    // ✅ WHY:\n                    //   - Avoid code duplication for similar cases\n                    //   - Clean handling of equivalent business scenarios\n\n                    processingPriority = 'High';\n                    discountRate = 0.20;\n                    acc.Processing_Notes__c = 'Partner - special pricing';\n                }\n                when else {\n                    // ✅ WHAT:\n                    //   - `when else` = DEFAULT CASE (like final else)\n                    //   - Handles any value not explicitly listed above\n                    // ✅ WHY:\n                    //   - Defensive programming - handle unexpected values\n                    //   - Required for complete logic coverage\n                    // \uD83D\uDCA5 IF MISSING:\n                    //   - Code might not handle all possible values\n\n                    processingPriority = 'Medium';\n                    discountRate = 0.05;\n                    acc.Processing_Notes__c = 'Unknown type - review needed';\n                }\n            }\n\n            // ✅ NESTED SWITCH: Industry-specific processing\n            switch on acc.Industry {\n                when 'Technology' {\n                    acc.Sales_Strategy__c = 'Tech-focused approach';\n                    acc.Contract_Length__c = 12; // months\n                }\n                when 'Healthcare', 'Pharmaceuticals' {\n                    acc.Sales_Strategy__c = 'Compliance-focused approach';\n                    acc.Contract_Length__c = 24; // longer contracts for stability\n                }\n                when 'Financial Services', 'Banking' {\n                    acc.Sales_Strategy__c = 'Security-focused approach';\n                    acc.Contract_Length__c = 36; // enterprise contracts\n                }\n                when else {\n                    acc.Sales_Strategy__c = 'Standard approach';\n                    acc.Contract_Length__c = 12;\n                }\n            }\n\n            // ✅ SET CALCULATED VALUES: Apply switch results\n            acc.Processing_Priority__c = processingPriority;\n            acc.Discount_Rate__c = discountRate;\n\n            System.debug('PROCESSED: ' + acc.Name +\n                        ' (Type: ' + acc.Type +\n                        ', Priority: ' + processingPriority +\n                        ', Discount: ' + discountRate + ')');\n        }\n\n        // ✅ SWITCH WITH ENUMS: Type-safe constant values\n        System.LoggingLevel currentLevel = System.LoggingLevel.INFO;\n\n        switch on currentLevel {\n            when DEBUG {\n                System.debug('Debug logging enabled - verbose output');\n            }\n            when INFO {\n                System.debug('Info logging enabled - standard output');\n            }\n            when WARN, ERROR {\n                // ✅ WHAT: Handle both warning and error levels together\n                // ✅ WHY: Similar processing for both severity levels\n                System.debug('High-severity logging enabled');\n            }\n            when else {\n                System.debug('Unknown logging level');\n            }\n        }\n\n        // ✅ BULK UPDATE: Apply all account changes\n        update accountMap.values();\n        // ✅ WHAT: `accountMap.values()` returns List of all Account records\n        // ✅ WHY: Single DML operation for all processed accounts\n    }\n}",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"Loops for Processing Collections"}),(0,s.jsx)(f,{code:"public class CollectionProcessor {\n    public void demonstrateLoops() {\n        // ✅ BUILDING ON: You understand Lists, Sets, Maps from Collections topic\n        List<Contact> contacts = [SELECT Id, Name, AccountId, Email FROM Contact LIMIT 100];\n        Set<Id> accountIds = new Set<Id>();\n        Map<Id, Integer> contactCounts = new Map<Id, Integer>();\n\n        // ✅ ENHANCED FOR LOOP: Best practice for collections\n        for (Contact con : contacts) {\n            // ✅ WHAT:\n            //   - `for (Type variable : collection)` = ENHANCED FOR LOOP\n            //   - `Contact con` = TEMPORARY variable for each iteration\n            // ✅ WHY:\n            //   - Cleaner syntax than traditional for loops\n            //   - Automatically handles collection boundaries\n            //   - More efficient and less error-prone\n            // ✅ PERFORMANCE:\n            //   - Reads each element exactly once\n            //   - No index calculations needed\n\n            System.debug('Processing contact: ' + con.Name);\n\n            // Collect Account IDs for bulk processing\n            if (con.AccountId != null) {\n                accountIds.add(con.AccountId);\n                // ✅ WHAT: Add Account ID to Set (duplicates automatically ignored)\n                // ✅ WHY: Prepare for bulk query - collect unique IDs first\n            }\n\n            // Count contacts per account\n            Id accId = con.AccountId;\n            if (contactCounts.containsKey(accId)) {\n                // ✅ WHAT: Account already has contacts, increment count\n                Integer currentCount = contactCounts.get(accId);\n                contactCounts.put(accId, currentCount + 1);\n            } else {\n                // ✅ WHAT: First contact for this account, start count at 1\n                contactCounts.put(accId, 1);\n            }\n        }\n\n        // ✅ TRADITIONAL FOR LOOP: When you need index numbers\n        for (Integer i = 0; i < contacts.size(); i++) {\n            // ✅ WHAT:\n            //   - `Integer i = 0` = INITIALIZE counter variable\n            //   - `i < contacts.size()` = CONDITION to continue\n            //   - `i++` = INCREMENT after each iteration\n            // ✅ WHY:\n            //   - Use when you need current position/index\n            //   - Required for comparing adjacent elements\n            //   - Useful for batch processing by position\n            // \uD83D\uDCA5 GOTCHA:\n            //   - Easy to create off-by-one errors\n            //   - `i <= contacts.size()` would crash (too high by 1)\n\n            Contact currentContact = contacts.get(i);\n            System.debug('Contact #' + i + ': ' + currentContact.Name);\n\n            // Example: Compare with next contact (why you need index)\n            if (i + 1 < contacts.size()) {\n                Contact nextContact = contacts.get(i + 1);\n                System.debug('Comparing: ' + currentContact.Name + ' → ' + nextContact.Name);\n            }\n        }\n\n        // ✅ PROCESSING MAP WITH LOOPS: Iterate through key-value pairs\n        for (Id accountId : contactCounts.keySet()) {\n            // ✅ WHAT:\n            //   - `contactCounts.keySet()` = GET all keys as Set\n            //   - Loop through each Account ID\n            // ✅ WHY:\n            //   - Process each account's contact count\n            //   - keySet() gives you all the accounts that have contacts\n\n            Integer count = contactCounts.get(accountId);\n            System.debug('Account ' + accountId + ' has ' + count + ' contacts');\n\n            // Business logic based on contact count\n            if (count >= 10) {\n                System.debug('HIGH VOLUME: Account has many contacts');\n            } else if (count >= 5) {\n                System.debug('MEDIUM VOLUME: Account has several contacts');\n            } else {\n                System.debug('LOW VOLUME: Account has few contacts');\n            }\n        }\n\n        // ✅ WHILE LOOP: Repeat until condition changes\n        Integer batchSize = 200;\n        Integer processed = 0;\n        List<Contact> allContacts = [SELECT Id FROM Contact];\n\n        while (processed < allContacts.size()) {\n            // ✅ WHAT:\n            //   - `while (condition)` = REPEAT while condition is true\n            //   - Check condition BEFORE each iteration\n            // ✅ WHY:\n            //   - Useful for batch processing with unknown total iterations\n            //   - Continue until work is complete\n            // \uD83D\uDCA5 DANGER:\n            //   - Can create INFINITE LOOPS if condition never becomes false\n            //   - Always ensure the condition will eventually change\n\n            Integer endIndex = Math.min(processed + batchSize, allContacts.size());\n            List<Contact> batch = new List<Contact>();\n\n            // Process current batch\n            for (Integer i = processed; i < endIndex; i++) {\n                batch.add(allContacts.get(i));\n            }\n\n            System.debug('Processing batch: ' + processed + ' to ' + (endIndex - 1));\n            // ... process batch ...\n\n            processed = endIndex; // ✅ CRITICAL: Update condition variable\n            // ✅ WHAT: Move to next batch starting position\n            // ✅ WHY: Ensures while condition will eventually become false\n            // \uD83D\uDCA5 IF MISSING: Infinite loop (processed never increases)\n        }\n\n        // ✅ DO-WHILE LOOP: Execute at least once, then check condition\n        Integer attempts = 0;\n        Boolean operationSucceeded = false;\n\n        do {\n            // ✅ WHAT:\n            //   - `do { ... } while (condition)` = EXECUTE FIRST, check after\n            //   - Guaranteed to run at least once\n            // ✅ WHY:\n            //   - Useful when you always need to try at least once\n            //   - Common for retry logic\n\n            attempts++;\n            System.debug('Attempt #' + attempts);\n\n            // Simulate operation that might fail\n            operationSucceeded = Math.random() > 0.7; // 30% success rate\n\n            if (!operationSucceeded) {\n                System.debug('Operation failed, will retry...');\n            }\n\n        } while (!operationSucceeded && attempts < 5);\n        // ✅ WHAT: Continue if operation failed AND we haven't exceeded max attempts\n        // ✅ WHY: Retry logic with maximum attempt limit\n\n        if (operationSucceeded) {\n            System.debug('Operation succeeded after ' + attempts + ' attempts');\n        } else {\n            System.debug('Operation failed after ' + attempts + ' attempts');\n        }\n    }\n}",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4",children:"Flow Control - Break, Continue, Return"}),(0,s.jsx)(f,{code:"public class FlowControlDemo {\n    public void demonstrateFlowControl() {\n        List<Account> accounts = [SELECT Id, Name, AnnualRevenue, Type FROM Account LIMIT 20];\n\n        // ✅ BREAK: Exit loop early when condition is met\n        for (Account acc : accounts) {\n            System.debug('Checking account: ' + acc.Name);\n\n            if (acc.AnnualRevenue != null && acc.AnnualRevenue > 1000000) {\n                // ✅ WHAT:\n                //   - `break` = IMMEDIATELY EXIT the current loop\n                //   - Skips all remaining iterations\n                // ✅ WHY:\n                //   - Found what we're looking for, no need to continue\n                //   - Performance optimization - don't do unnecessary work\n                // ✅ PRACTICAL:\n                //   - \"Find first high-value account and stop\"\n\n                System.debug('FOUND HIGH-VALUE ACCOUNT: ' + acc.Name);\n                break; // Exit loop immediately\n            }\n        }\n\n        // ✅ CONTINUE: Skip current iteration, proceed to next\n        Integer validAccountCount = 0;\n        for (Account acc : accounts) {\n            // Skip accounts without revenue data\n            if (acc.AnnualRevenue == null) {\n                // ✅ WHAT:\n                //   - `continue` = SKIP rest of current iteration\n                //   - Jump directly to next account in loop\n                // ✅ WHY:\n                //   - Don't process incomplete data\n                //   - Cleaner than nested if statements\n                // ✅ PRACTICAL:\n                //   - \"Skip invalid records, process only good ones\"\n\n                System.debug('SKIPPING: ' + acc.Name + ' (no revenue data)');\n                continue; // Skip to next account\n            }\n\n            // This code only runs for accounts WITH revenue data\n            validAccountCount++;\n            System.debug('PROCESSING: ' + acc.Name + ' (Revenue: ' + acc.AnnualRevenue + ')');\n\n            // Business logic for valid accounts only\n            if (acc.AnnualRevenue > 500000) {\n                acc.Type = 'Enterprise';\n            } else {\n                acc.Type = 'SMB';\n            }\n        }\n\n        System.debug('Processed ' + validAccountCount + ' valid accounts');\n\n        // ✅ LABELED BREAK: Break out of nested loops\n        outerLoop: // ✅ WHAT: Label for referencing specific loop\n        for (Integer i = 0; i < 5; i++) {\n            for (Integer j = 0; j < 5; j++) {\n                System.debug('i=' + i + ', j=' + j);\n\n                if (i == 2 && j == 2) {\n                    // ✅ WHAT:\n                    //   - `break outerLoop` = EXIT the labeled loop (not just inner)\n                    //   - Breaks out of BOTH loops at once\n                    // ✅ WHY:\n                    //   - Sometimes you need to exit multiple nested levels\n                    //   - Cleaner than boolean flags\n\n                    System.debug('Breaking out of both loops');\n                    break outerLoop; // Exit both loops\n                }\n            }\n        }\n        System.debug('Both loops exited');\n    }\n\n    // ✅ RETURN: Exit method and optionally return value\n    public String categorizeAccount(Account acc) {\n        // ✅ EARLY RETURNS: Validate inputs first\n        if (acc == null) {\n            // ✅ WHAT:\n            //   - `return` = IMMEDIATELY EXIT method\n            //   - Returns specified value to caller\n            // ✅ WHY:\n            //   - Guard clauses prevent null pointer exceptions\n            //   - Fail fast for invalid inputs\n            // ✅ PATTERN:\n            //   - Check edge cases first, main logic last\n\n            return 'Invalid'; // Exit method immediately\n        }\n\n        if (acc.AnnualRevenue == null) {\n            return 'Unknown'; // Early return for missing data\n        }\n\n        // ✅ MAIN LOGIC: Only reached if inputs are valid\n        if (acc.AnnualRevenue >= 10000000) {\n            return 'Enterprise'; // ✅ WHAT: Early return for high-value\n        }\n\n        if (acc.AnnualRevenue >= 1000000) {\n            return 'Large'; // ✅ WHAT: Early return for medium-value\n        }\n\n        if (acc.AnnualRevenue >= 100000) {\n            return 'Medium'; // ✅ WHAT: Early return for small-value\n        }\n\n        return 'Small'; // ✅ WHAT: Default return (all other cases)\n        // ✅ WHY: Method must return String in all code paths\n    }\n\n    public Boolean validateAndProcessLead(Lead lead) {\n        // ✅ MULTIPLE EARLY RETURNS: Clean validation pattern\n        if (lead == null) {\n            System.debug('ERROR: Lead is null');\n            return false;\n        }\n\n        if (String.isBlank(lead.Email)) {\n            System.debug('ERROR: Lead has no email');\n            return false;\n        }\n\n        if (!lead.Email.contains('@')) {\n            System.debug('ERROR: Invalid email format');\n            return false;\n        }\n\n        if (lead.Score__c == null || lead.Score__c < 0) {\n            System.debug('ERROR: Invalid lead score');\n            return false;\n        }\n\n        // ✅ ALL VALIDATIONS PASSED: Proceed with main logic\n        System.debug('SUCCESS: Processing valid lead: ' + lead.Email);\n\n        // Main processing logic here...\n        lead.Status = 'Qualified';\n        lead.Processed_Date__c = Date.today();\n\n        return true; // ✅ WHAT: Success return after processing\n        // ✅ WHY: Indicates successful completion to caller\n    }\n}",annotations:[]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-red-600 dark:text-red-400 mb-4",children:"\uD83D\uDC80 Common Gotchas"}),(0,s.jsxs)("div",{className:"space-y-6",children:[(0,s.jsxs)("div",{className:"p-6 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-red-900 dark:text-red-100 mb-2",children:"Infinite Loops"}),(0,s.jsx)("p",{className:"text-red-800 dark:text-red-200 mb-4",children:"While loops can run forever if the condition never changes."}),(0,s.jsxs)("div",{className:"grid md:grid-cols-2 gap-4",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-red-900 dark:text-red-100 mb-2",children:"\uD83D\uDC80 DANGEROUS"}),(0,s.jsx)(f,{code:"Integer i = 0;\nwhile (i < 10) {\n    System.debug(i);\n    // FORGOT i++; - infinite loop!\n}",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-green-900 dark:text-green-100 mb-2",children:"✅ SAFE"}),(0,s.jsx)(f,{code:"Integer i = 0;\nwhile (i < 10) {\n    System.debug(i);\n    i++; // Always update condition variable\n}",annotations:[]})]})]})]}),(0,s.jsxs)("div",{className:"p-6 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-yellow-900 dark:text-yellow-100 mb-2",children:"Off-by-One Errors"}),(0,s.jsx)("p",{className:"text-yellow-800 dark:text-yellow-200 mb-4",children:"Traditional for loops are prone to boundary errors."}),(0,s.jsxs)("div",{className:"grid md:grid-cols-2 gap-4",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-red-900 dark:text-red-100 mb-2",children:"\uD83D\uDC80 DANGEROUS"}),(0,s.jsx)(f,{code:"List<String> items = new List<String>{'a', 'b'};\nfor (Integer i = 0; i <= items.size(); i++) {\n    System.debug(items.get(i)); // CRASH at i=2\n}",annotations:[]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h4",{className:"text-sm font-semibold text-green-900 dark:text-green-100 mb-2",children:"✅ SAFE"}),(0,s.jsx)(f,{code:"List<String> items = new List<String>{'a', 'b'};\nfor (String item : items) {\n    System.debug(item); // Enhanced for loop is safer\n}",annotations:[]})]})]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-green-600 dark:text-green-400 mb-4",children:"\uD83C\uDF0D Real-World Application"}),(0,s.jsxs)("div",{className:"p-6 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-700 rounded-lg",children:[(0,s.jsx)("h3",{className:"text-lg font-semibold text-green-900 dark:text-green-100 mb-4",children:"Why This Matters in Production"}),(0,s.jsxs)("div",{className:"prose dark:prose-dark max-w-none",children:[(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"If/Else:"})," Lead scoring, opportunity qualification, discount calculations based on customer type"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Switch:"})," Processing different record types, handling various case statuses, routing workflows"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"For Loops:"})," Bulk processing records, data migration, report generation, integration data processing"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"While Loops:"})," Retry logic for external callouts, polling for completion status, batch processing"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Break/Continue:"})," Early termination for performance, skipping invalid records, error handling"]})]}),(0,s.jsxs)("p",{className:"mt-4",children:[(0,s.jsx)("strong",{children:"Governor Limit Impact:"})," Efficient control flow prevents timeouts and limit exceptions. Poor loop design can consume all CPU time or SOQL queries."]})]})]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-bold text-blue-600 dark:text-blue-400 mb-4",children:"\uD83D\uDE80 Next Steps"}),(0,s.jsxs)("div",{className:"p-6 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg",children:[(0,s.jsxs)("p",{className:"text-blue-800 dark:text-blue-200 mb-4",children:[(0,s.jsx)("strong",{children:"You now know how to make decisions and process data efficiently."})," Next, you'll learn ",(0,s.jsx)("strong",{children:"Classes and Methods"})," - how to organize your control flow logic into reusable, maintainable components."]}),(0,s.jsxs)("p",{className:"text-blue-800 dark:text-blue-200",children:["Classes will teach you: ",(0,s.jsx)("em",{children:'"How do you organize your Lead processing logic so other developers can reuse it?"'})]})]})]})]})},{id:"classes",title:"Classes and Methods",icon:d.Z,description:"Object-oriented programming in Apex",content:(0,s.jsxs)("div",{className:"space-y-8",children:[(0,s.jsx)("div",{children:(0,s.jsxs)("p",{className:"text-lg text-gray-700 dark:text-gray-300 mb-6",children:[(0,s.jsx)("strong",{children:"Your processing logic needs organization."})," Classes group related functionality, methods perform specific tasks, and objects hold your data. Think of a class as a blueprint and objects as the houses built from it."]})}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Class Structure and Fundamentals"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Every class in Apex follows a consistent structure. Let's build an AccountProcessor class step by step:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Class declaration with access modifier\n// ✅ WHY: Public makes this class accessible from other classes and packages\n// \uD83D\uDCA5 IF WRONG: Without public, the class is only accessible within the same package\npublic class AccountProcessor {\n\n    // ✅ WHAT: Instance variables (properties) store object state\n    // ✅ WHY: Private encapsulation - only this class can directly access these\n    // \uD83D\uDCA5 IF WRONG: Public variables break encapsulation and create tight coupling\n    private String processorName;\n    private Integer maxAccountsToProcess;\n    private Boolean isActive;\n\n    // ✅ WHAT: Static variable shared across ALL instances of this class\n    // ✅ WHY: Tracks total processors created - belongs to the class, not instances\n    // \uD83D\uDCA5 IF WRONG: Instance variable would give each object its own counter\n    private static Integer totalProcessorsCreated = 0;\n\n    // ✅ WHAT: Default constructor (no parameters)\n    // ✅ WHY: Provides a standard way to create objects with default values\n    // \uD83D\uDCA5 IF WRONG: Without any constructor, Salesforce provides a default one anyway\n    public AccountProcessor() {\n        this.processorName = 'Default Processor';\n        this.maxAccountsToProcess = 100;\n        this.isActive = true;\n        totalProcessorsCreated++; // ✅ Increment class-level counter\n    }\n\n    // ✅ WHAT: Parameterized constructor for custom initialization\n    // ✅ WHY: Allows creating objects with specific values instead of defaults\n    // \uD83D\uDCA5 IF WRONG: Having only default constructor limits object creation flexibility\n    public AccountProcessor(String name, Integer maxAccounts) {\n        this.processorName = name;\n        this.maxAccountsToProcess = maxAccounts;\n        this.isActive = true;\n        totalProcessorsCreated++;\n    }\n\n    // ✅ WHAT: Getter method for private instance variable\n    // ✅ WHY: Controlled access to private data - encapsulation principle\n    // \uD83D\uDCA5 IF WRONG: Direct variable access breaks encapsulation\n    public String getProcessorName() {\n        return this.processorName;\n    }\n\n    // ✅ WHAT: Setter method with validation\n    // ✅ WHY: Controlled modification of private data with business rules\n    // \uD83D\uDCA5 IF WRONG: Direct assignment could allow invalid data\n    public void setProcessorName(String newName) {\n        if (String.isNotBlank(newName)) {\n            this.processorName = newName;\n        } else {\n            throw new IllegalArgumentException('Processor name cannot be blank');\n        }\n    }\n\n    // ✅ WHAT: Instance method that operates on this object's data\n    // ✅ WHY: Encapsulates behavior with the data it operates on\n    // \uD83D\uDCA5 IF WRONG: Static method couldn't access instance variables\n    public void processAccounts(List<Account> accounts) {\n        if (!this.isActive) {\n            System.debug('Processor ' + this.processorName + ' is inactive');\n            return;\n        }\n\n        Integer accountsToProcess = Math.min(accounts.size(), this.maxAccountsToProcess);\n\n        for (Integer i = 0; i < accountsToProcess; i++) {\n            Account acc = accounts[i];\n            // ✅ Process each account\n            acc.Description = 'Processed by ' + this.processorName;\n        }\n\n        System.debug(this.processorName + ' processed ' + accountsToProcess + ' accounts');\n    }\n\n    // ✅ WHAT: Static method - belongs to class, not instance\n    // ✅ WHY: Utility function that doesn't need object state\n    // \uD83D\uDCA5 IF WRONG: Instance method would require creating object for utility function\n    public static Integer getTotalProcessorsCreated() {\n        return totalProcessorsCreated;\n    }\n\n    // ✅ WHAT: Static method for creating specialized processors\n    // ✅ WHY: Factory method pattern - encapsulates object creation logic\n    // \uD83D\uDCA5 IF WRONG: Multiple constructors might become confusing\n    public static AccountProcessor createHighVolumeProcessor(String name) {\n        return new AccountProcessor(name, 1000);\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Access modifiers control visibility: public (accessible everywhere), private (only within this class), global (accessible in other namespaces)",type:"info",icon:"ℹ️"},{arrows:"         ↑",explanation:"Instance variables store object state. Each object gets its own copy of these variables",type:"success",icon:"✅"},{arrows:"              ↑",explanation:"Static variables belong to the class itself, shared across all instances. Perfect for counters or configuration",type:"warning",icon:"⚠️"},{arrows:"                   ↑",explanation:"Constructors initialize objects. You can have multiple constructors with different parameters (overloading)",type:"info",icon:"\uD83C\uDFD7️"},{arrows:"                        ↑",explanation:"Getter/setter methods provide controlled access to private variables. This is encapsulation in action",type:"success",icon:"\uD83D\uDD12"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Using Your Classes"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Now let's see how to create and use objects from our AccountProcessor class:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Creating objects using different constructors\n// ✅ WHY: Demonstrates constructor overloading and object instantiation\n// \uD83D\uDCA5 IF WRONG: Forgetting 'new' keyword causes compilation error\n\n// Using default constructor\nAccountProcessor defaultProcessor = new AccountProcessor();\n\n// Using parameterized constructor\nAccountProcessor customProcessor = new AccountProcessor('Enterprise Processor', 500);\n\n// Using static factory method\nAccountProcessor bulkProcessor = AccountProcessor.createHighVolumeProcessor('Bulk Data Processor');\n\n// ✅ WHAT: Accessing object methods and properties\n// ✅ WHY: Demonstrates encapsulation - using getters instead of direct access\n// \uD83D\uDCA5 IF WRONG: Trying to access private variables directly would fail\n\nSystem.debug('Default processor: ' + defaultProcessor.getProcessorName());\nSystem.debug('Custom processor: ' + customProcessor.getProcessorName());\n\n// ✅ WHAT: Modifying object state through setter\n// ✅ WHY: Controlled modification with validation\ncustomProcessor.setProcessorName('Updated Enterprise Processor');\n\n// ✅ WHAT: Using instance methods on objects\n// ✅ WHY: Each object maintains its own state and behavior\nList<Account> accountsToProcess = [SELECT Id, Name FROM Account LIMIT 50];\n\ndefaultProcessor.processAccounts(accountsToProcess);\ncustomProcessor.processAccounts(accountsToProcess);\n\n// ✅ WHAT: Accessing static method without creating object\n// ✅ WHY: Static methods belong to the class, not instances\n// \uD83D\uDCA5 IF WRONG: Calling static methods on instances works but is confusing\nInteger totalCreated = AccountProcessor.getTotalProcessorsCreated();\nSystem.debug('Total processors created: ' + totalCreated);\n\n// ✅ WHAT: Demonstrating object independence\n// ✅ WHY: Each object has its own state and can behave differently\nAccountProcessor processor1 = new AccountProcessor('Processor One', 10);\nAccountProcessor processor2 = new AccountProcessor('Processor Two', 20);\n\n// These will process different amounts based on their maxAccountsToProcess\nprocessor1.processAccounts(accountsToProcess); // Processes up to 10\nprocessor2.processAccounts(accountsToProcess); // Processes up to 20",annotations:[{arrows:"                                    ↑",explanation:"The 'new' keyword creates a new instance of the class in memory and calls the constructor",type:"info",icon:"\uD83C\uDD95"},{arrows:"                        ↑",explanation:"Each object has its own copy of instance variables but shares static variables and methods",type:"success",icon:"\uD83D\uDD04"},{arrows:"                                          ↑",explanation:"Static methods can be called on the class name without creating an object instance",type:"warning",icon:"⚡"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Method Types and Patterns"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Understanding different method types helps you design better classes:"}),(0,s.jsx)(f,{code:"public class ValidationHelper {\n\n    // ✅ WHAT: Instance method that uses object state\n    // ✅ WHY: Needs access to instance variables for validation rules\n    private Map<String, String> validationRules;\n\n    public ValidationHelper() {\n        validationRules = new Map<String, String>();\n        validationRules.put('email', '.*@.*\\..*'); // Simple email pattern\n        validationRules.put('phone', '\\d{3}-\\d{3}-\\d{4}'); // Phone pattern\n    }\n\n    // ✅ WHAT: Instance method using object's validation rules\n    // ✅ WHY: Each validator can have different rules\n    public Boolean validateField(String fieldType, String value) {\n        String pattern = validationRules.get(fieldType);\n        if (pattern == null) {\n            return true; // No rule means valid\n        }\n        return Pattern.matches(pattern, value);\n    }\n\n    // ✅ WHAT: Static utility method - no object state needed\n    // ✅ WHY: Pure function that always behaves the same way\n    // \uD83D\uDCA5 IF WRONG: Making this instance method would require unnecessary object creation\n    public static Boolean isValidEmail(String email) {\n        // ✅ Simple validation logic that doesn't need object state\n        return String.isNotBlank(email) && email.contains('@') && email.contains('.');\n    }\n\n    // ✅ WHAT: Static method with parameters and return value\n    // ✅ WHY: Reusable utility that doesn't depend on object state\n    public static String formatPhoneNumber(String rawPhone) {\n        if (String.isBlank(rawPhone)) {\n            return null;\n        }\n\n        // ✅ Remove all non-digits\n        String cleanPhone = rawPhone.replaceAll('[^0-9]', '');\n\n        // ✅ Format as XXX-XXX-XXXX if 10 digits\n        if (cleanPhone.length() == 10) {\n            return cleanPhone.substring(0, 3) + '-' +\n                   cleanPhone.substring(3, 6) + '-' +\n                   cleanPhone.substring(6);\n        }\n\n        return rawPhone; // Return original if can't format\n    }\n\n    // ✅ WHAT: Method overloading - same name, different parameters\n    // ✅ WHY: Provides flexible ways to call the same logical operation\n    // \uD83D\uDCA5 IF WRONG: Different method names would be less intuitive\n\n    // Version 1: Validate single field\n    public Boolean validate(String fieldType, String value) {\n        return validateField(fieldType, value);\n    }\n\n    // Version 2: Validate multiple fields at once\n    public Map<String, Boolean> validate(Map<String, String> fieldValues) {\n        Map<String, Boolean> results = new Map<String, Boolean>();\n\n        for (String fieldType : fieldValues.keySet()) {\n            String value = fieldValues.get(fieldType);\n            results.put(fieldType, validateField(fieldType, value));\n        }\n\n        return results;\n    }\n\n    // ✅ WHAT: Method with void return type (doesn't return anything)\n    // ✅ WHY: Used for actions/operations rather than calculations\n    public void addValidationRule(String fieldType, String pattern) {\n        validationRules.put(fieldType, pattern);\n        System.debug('Added validation rule for ' + fieldType);\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Instance methods can access and modify object state (instance variables). They require an object to be called",type:"info",icon:"\uD83D\uDCE6"},{arrows:"         ↑",explanation:"Static methods don't need object state. They're like utility functions that belong to the class",type:"success",icon:"\uD83D\uDD27"},{arrows:"              ↑",explanation:"Method overloading allows multiple methods with the same name but different parameters",type:"warning",icon:"\uD83D\uDD04"},{arrows:"                   ↑",explanation:"Void methods perform actions but don't return values. Use them for operations like logging or data modification",type:"info",icon:"⚡"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Real-World Example: Contact Manager"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Let's build a practical class that demonstrates all these concepts in a real Salesforce scenario:"}),(0,s.jsx)(f,{code:"public class ContactManager {\n    // ✅ WHAT: Instance variables for object state\n    private String managerName;\n    private Set<String> allowedDomains;\n    private Integer maxContactsPerBatch;\n\n    // ✅ WHAT: Static variable for class-level tracking\n    private static Integer totalContactsProcessed = 0;\n\n    // ✅ WHAT: Constructor with validation\n    public ContactManager(String name, Set<String> domains) {\n        if (String.isBlank(name)) {\n            throw new IllegalArgumentException('Manager name is required');\n        }\n\n        this.managerName = name;\n        this.allowedDomains = domains != null ? domains : new Set<String>();\n        this.maxContactsPerBatch = 200; // Default limit\n    }\n\n    // ✅ WHAT: Instance method for core business logic\n    // ✅ WHY: Uses object state (allowedDomains, maxContactsPerBatch) for processing\n    public List<Contact> processIncomingContacts(List<Contact> newContacts) {\n        List<Contact> processedContacts = new List<Contact>();\n        Integer processed = 0;\n\n        for (Contact con : newContacts) {\n            // ✅ Check batch limit\n            if (processed >= this.maxContactsPerBatch) {\n                System.debug('Batch limit reached: ' + this.maxContactsPerBatch);\n                break;\n            }\n\n            // ✅ Validate email domain\n            if (isValidDomain(con.Email)) {\n                con.Description = 'Processed by ' + this.managerName;\n                con.LeadSource = 'Web';\n                processedContacts.add(con);\n                processed++;\n            } else {\n                System.debug('Rejected contact with invalid domain: ' + con.Email);\n            }\n        }\n\n        // ✅ Update class-level counter\n        totalContactsProcessed += processed;\n\n        return processedContacts;\n    }\n\n    // ✅ WHAT: Private helper method (encapsulation)\n    // ✅ WHY: Internal logic that shouldn't be called from outside\n    private Boolean isValidDomain(String email) {\n        if (String.isBlank(email) || !email.contains('@')) {\n            return false;\n        }\n\n        String domain = email.split('@')[1].toLowerCase();\n\n        // ✅ If no specific domains set, allow all\n        if (allowedDomains.isEmpty()) {\n            return true;\n        }\n\n        return allowedDomains.contains(domain);\n    }\n\n    // ✅ WHAT: Static utility method for email validation\n    // ✅ WHY: Pure function that doesn't need object state\n    public static Boolean validateEmailFormat(String email) {\n        if (String.isBlank(email)) {\n            return false;\n        }\n\n        // ✅ Basic email format validation\n        String emailRegex = '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}';\n        return Pattern.matches(emailRegex, email);\n    }\n\n    // ✅ WHAT: Static method to get class-level statistics\n    public static Integer getTotalContactsProcessed() {\n        return totalContactsProcessed;\n    }\n\n    // ✅ WHAT: Method to update object configuration\n    public void setBatchLimit(Integer newLimit) {\n        if (newLimit > 0 && newLimit <= 2000) {\n            this.maxContactsPerBatch = newLimit;\n        } else {\n            throw new IllegalArgumentException('Batch limit must be between 1 and 2000');\n        }\n    }\n\n    // ✅ WHAT: Method to add allowed domain\n    public void addAllowedDomain(String domain) {\n        if (String.isNotBlank(domain)) {\n            this.allowedDomains.add(domain.toLowerCase());\n        }\n    }\n\n    // ✅ WHAT: Static factory method for common configurations\n    public static ContactManager createCorporateManager(String name) {\n        Set<String> corporateDomains = new Set<String>{\n            'salesforce.com', 'google.com', 'microsoft.com', 'amazon.com'\n        };\n\n        ContactManager manager = new ContactManager(name, corporateDomains);\n        manager.setBatchLimit(500); // Higher limit for corporate\n        return manager;\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Real-world classes combine data (instance variables) with behavior (methods) that operates on that data",type:"success",icon:"\uD83C\uDFE2"},{arrows:"         ↑",explanation:"Constructor validation ensures objects are created in a valid state from the beginning",type:"info",icon:"✅"},{arrows:"              ↑",explanation:"Instance methods use object state to make decisions and perform operations specific to that object",type:"warning",icon:"⚙️"},{arrows:"                   ↑",explanation:"Private methods encapsulate internal logic that shouldn't be exposed to external code",type:"info",icon:"\uD83D\uDD12"},{arrows:"                        ↑",explanation:"Factory methods provide pre-configured object creation for common use cases",type:"success",icon:"\uD83C\uDFED"}]})]}),(0,s.jsxs)("section",{className:"bg-blue-50 dark:bg-blue-900/20 rounded-lg p-6",children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-blue-900 dark:text-blue-100 mb-3",children:"\uD83D\uDCA1 Key Class Design Principles"}),(0,s.jsxs)("ul",{className:"space-y-2 text-blue-800 dark:text-blue-200",children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Encapsulation:"})," Keep data private, provide controlled access through methods"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Single Responsibility:"})," Each class should have one clear purpose"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Constructor Validation:"})," Ensure objects start in a valid state"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Static vs Instance:"})," Use static for utilities, instance for stateful operations"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Method Overloading:"})," Provide multiple ways to call the same logical operation"]})]})]})]})},{id:"soql",title:"SOQL and Database",icon:u.Z,description:"Query data and database operations",content:(0,s.jsxs)("div",{className:"space-y-8",children:[(0,s.jsx)("div",{children:(0,s.jsxs)("p",{className:"text-lg text-gray-700 dark:text-gray-300 mb-6",children:[(0,s.jsx)("strong",{children:"Your classes need data to work with."})," SOQL retrieves records from Salesforce, DML operations modify them, and proper database patterns ensure your code is efficient and bulkified. Master these fundamentals to build robust data-driven applications."]})}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"SOQL Query Fundamentals"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"SOQL (Salesforce Object Query Language) retrieves data from your Salesforce database. Every query follows a consistent pattern:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Basic SOQL query syntax\n// ✅ WHY: SELECT specifies fields, FROM specifies object, WHERE filters records\n// \uD83D\uDCA5 IF WRONG: Missing SELECT or FROM causes compilation error\n\n// Simple query - get all accounts\nList<Account> allAccounts = [SELECT Id, Name FROM Account];\n\n// ✅ WHAT: Query with WHERE clause for filtering\n// ✅ WHY: Reduces data retrieved, improves performance\n// \uD83D\uDCA5 IF WRONG: No WHERE clause retrieves ALL records (potential performance issue)\nList<Account> activeAccounts = [\n    SELECT Id, Name, Type, Industry\n    FROM Account\n    WHERE Active__c = true\n];\n\n// ✅ WHAT: Query with multiple conditions\n// ✅ WHY: AND/OR operators allow complex filtering logic\nList<Account> enterpriseCustomers = [\n    SELECT Id, Name, AnnualRevenue, NumberOfEmployees\n    FROM Account\n    WHERE (Type = 'Customer' OR Type = 'Customer - Direct')\n    AND AnnualRevenue > 1000000\n    AND NumberOfEmployees > 100\n];\n\n// ✅ WHAT: Query with LIMIT to control result size\n// ✅ WHY: Prevents hitting governor limits, improves performance\n// \uD83D\uDCA5 IF WRONG: No LIMIT might return too many records\nList<Contact> recentContacts = [\n    SELECT Id, Name, Email, CreatedDate\n    FROM Contact\n    WHERE CreatedDate = LAST_N_DAYS:30\n    ORDER BY CreatedDate DESC\n    LIMIT 100\n];\n\n// ✅ WHAT: Query with relationships (looking up)\n// ✅ WHY: Get related data in single query instead of multiple queries\n// \uD83D\uDCA5 IF WRONG: Separate queries create inefficient N+1 query problems\nList<Contact> contactsWithAccounts = [\n    SELECT Id, Name, Email,\n           Account.Name, Account.Type, Account.Industry\n    FROM Contact\n    WHERE Account.Type = 'Customer'\n    LIMIT 50\n];\n\n// ✅ WHAT: Query with relationships (looking down)\n// ✅ WHY: Get child records with parent in single efficient query\nList<Account> accountsWithContacts = [\n    SELECT Id, Name, Type,\n           (SELECT Id, Name, Email FROM Contacts LIMIT 5)\n    FROM Account\n    WHERE Type = 'Customer'\n    LIMIT 20\n];",annotations:[{arrows:"    ↑",explanation:"SOQL queries are embedded in square brackets []. They return lists of sObjects matching your criteria",type:"info",icon:"\uD83D\uDD0D"},{arrows:"         ↑",explanation:"WHERE clauses filter results. Use them to avoid retrieving unnecessary data and hitting limits",type:"success",icon:"\uD83D\uDCCA"},{arrows:"              ↑",explanation:"Relationship queries use dot notation (Account.Name) to access related object fields efficiently",type:"warning",icon:"\uD83D\uDD17"},{arrows:"                   ↑",explanation:"Subqueries (SELECT within SELECT) retrieve child records. Always use LIMIT to control data volume",type:"info",icon:"\uD83D\uDCCB"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"DML Operations and Data Modification"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"DML (Data Manipulation Language) operations create, update, and delete records. Always think in bulk:"}),(0,s.jsx)(f,{code:"public class ContactProcessor {\n\n    // ✅ WHAT: Bulk insert operation\n    // ✅ WHY: Single DML statement handles multiple records efficiently\n    // \uD83D\uDCA5 IF WRONG: Individual inserts in loops hit governor limits quickly\n    public static void createBulkContacts(List<Map<String, String>> contactData) {\n        List<Contact> contactsToInsert = new List<Contact>();\n\n        for (Map<String, String> data : contactData) {\n            Contact newContact = new Contact();\n            newContact.FirstName = data.get('firstName');\n            newContact.LastName = data.get('lastName');\n            newContact.Email = data.get('email');\n            newContact.Phone = data.get('phone');\n\n            // ✅ Add to list for bulk operation\n            contactsToInsert.add(newContact);\n        }\n\n        // ✅ WHAT: Single insert statement for all records\n        // ✅ WHY: Efficient, uses one DML statement regardless of record count\n        if (!contactsToInsert.isEmpty()) {\n            insert contactsToInsert;\n            System.debug('Inserted ' + contactsToInsert.size() + ' contacts');\n        }\n    }\n\n    // ✅ WHAT: Bulk update with error handling\n    // ✅ WHY: Database.update allows partial success and error handling\n    // \uD83D\uDCA5 IF WRONG: Standard update fails entire transaction on any error\n    public static void updateAccountIndustries(Map<Id, String> accountIdToIndustry) {\n        List<Account> accountsToUpdate = new List<Account>();\n\n        // ✅ Build list of accounts to update\n        for (Id accountId : accountIdToIndustry.keySet()) {\n            Account acc = new Account();\n            acc.Id = accountId;\n            acc.Industry = accountIdToIndustry.get(accountId);\n            accountsToUpdate.add(acc);\n        }\n\n        // ✅ WHAT: Database.update with allOrNone = false\n        // ✅ WHY: Allows partial success, continues processing valid records\n        if (!accountsToUpdate.isEmpty()) {\n            Database.SaveResult[] results = Database.update(accountsToUpdate, false);\n\n            // ✅ Process results to handle errors\n            for (Integer i = 0; i < results.size(); i++) {\n                Database.SaveResult result = results[i];\n                if (!result.isSuccess()) {\n                    System.debug('Failed to update account: ' + accountsToUpdate[i].Id);\n                    for (Database.Error error : result.getErrors()) {\n                        System.debug('Error: ' + error.getMessage());\n                    }\n                }\n            }\n        }\n    }\n\n    // ✅ WHAT: Upsert operation for insert or update\n    // ✅ WHY: Handles both new and existing records based on external ID\n    // \uD83D\uDCA5 IF WRONG: Separate insert/update logic is more complex and error-prone\n    public static void upsertContactsByExternalId(List<Contact> contactsToUpsert) {\n        // ✅ WHAT: Upsert using external ID field\n        // ✅ WHY: Automatically determines insert vs update based on External_Id__c\n        try {\n            upsert contactsToUpsert External_Id__c;\n            System.debug('Upserted ' + contactsToUpsert.size() + ' contacts');\n        } catch (DmlException e) {\n            System.debug('Upsert failed: ' + e.getMessage());\n            // ✅ Handle specific DML errors\n            for (Integer i = 0; i < e.getNumDml(); i++) {\n                System.debug('Record ' + i + ': ' + e.getDmlMessage(i));\n            }\n        }\n    }\n\n    // ✅ WHAT: Safe delete with relationship checking\n    // ✅ WHY: Prevents accidental deletion of records with dependencies\n    public static void deleteInactiveAccounts() {\n        // ✅ Query accounts to delete with related data check\n        List<Account> accountsToDelete = [\n            SELECT Id, Name,\n                   (SELECT Id FROM Contacts LIMIT 1),\n                   (SELECT Id FROM Opportunities LIMIT 1)\n            FROM Account\n            WHERE Active__c = false\n            AND LastActivityDate < LAST_N_DAYS:365\n        ];\n\n        List<Account> safeToDelete = new List<Account>();\n\n        for (Account acc : accountsToDelete) {\n            // ✅ Only delete if no related records\n            if (acc.Contacts.isEmpty() && acc.Opportunities.isEmpty()) {\n                safeToDelete.add(acc);\n            } else {\n                System.debug('Cannot delete account with related records: ' + acc.Name);\n            }\n        }\n\n        if (!safeToDelete.isEmpty()) {\n            delete safeToDelete;\n            System.debug('Deleted ' + safeToDelete.size() + ' inactive accounts');\n        }\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Always build lists of records and use single DML statements. Never use DML inside loops!",type:"danger",icon:"⚠️"},{arrows:"         ↑",explanation:"Database.update with allOrNone=false allows partial success and detailed error handling",type:"success",icon:"✅"},{arrows:"              ↑",explanation:"Upsert automatically handles insert vs update logic based on external ID or record ID",type:"info",icon:"\uD83D\uDD04"},{arrows:"                   ↑",explanation:"Always check for related records before deletion to prevent referential integrity errors",type:"warning",icon:"\uD83D\uDEE1️"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Advanced SOQL Patterns"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Master these patterns for complex data retrieval scenarios:"}),(0,s.jsx)(f,{code:"public class AdvancedQueryExamples {\n\n    // ✅ WHAT: Dynamic SOQL with String.escapeSingleQuotes()\n    // ✅ WHY: Prevents SOQL injection while allowing runtime query building\n    // \uD83D\uDCA5 IF WRONG: Direct string concatenation allows SOQL injection attacks\n    public static List<Account> searchAccountsByName(String searchTerm) {\n        // ✅ Escape user input to prevent injection\n        String safeTerm = String.escapeSingleQuotes(searchTerm);\n\n        String query = 'SELECT Id, Name, Type, Industry FROM Account ' +\n                      'WHERE Name LIKE '%' + safeTerm + '%' ' +\n                      'ORDER BY Name LIMIT 100';\n\n        return Database.query(query);\n    }\n\n    // ✅ WHAT: Aggregate queries for calculations\n    // ✅ WHY: Database-level calculations are more efficient than Apex loops\n    // \uD83D\uDCA5 IF WRONG: Retrieving all records to calculate in Apex is inefficient\n    public static Map<String, Decimal> getRevenueByIndustry() {\n        // ✅ Use aggregate functions in SOQL\n        List<AggregateResult> results = [\n            SELECT Industry, SUM(AnnualRevenue) totalRevenue, COUNT(Id) accountCount\n            FROM Account\n            WHERE AnnualRevenue != null\n            AND Industry != null\n            GROUP BY Industry\n            HAVING SUM(AnnualRevenue) > 1000000\n            ORDER BY SUM(AnnualRevenue) DESC\n        ];\n\n        Map<String, Decimal> industryRevenue = new Map<String, Decimal>();\n\n        for (AggregateResult result : results) {\n            String industry = (String) result.get('Industry');\n            Decimal revenue = (Decimal) result.get('totalRevenue');\n            industryRevenue.put(industry, revenue);\n        }\n\n        return industryRevenue;\n    }\n\n    // ✅ WHAT: Date-based queries with date literals\n    // ✅ WHY: Date literals are timezone-aware and more reliable than date comparisons\n    public static List<Opportunity> getOpportunitiesByTimePeriod() {\n        return [\n            SELECT Id, Name, Amount, CloseDate, StageName,\n                   Account.Name, Account.Type\n            FROM Opportunity\n            WHERE CloseDate = THIS_QUARTER\n            AND StageName IN ('Negotiation/Review', 'Closed Won')\n            AND Amount > 50000\n            ORDER BY CloseDate DESC, Amount DESC\n        ];\n    }\n\n    // ✅ WHAT: Complex relationship queries with filtering\n    // ✅ WHY: Filters both parent and child records in single query\n    public static List<Account> getAccountsWithRecentHighValueOpportunities() {\n        return [\n            SELECT Id, Name, Type, Industry,\n                   (SELECT Id, Name, Amount, CloseDate, StageName\n                    FROM Opportunities\n                    WHERE Amount > 100000\n                    AND CloseDate >= LAST_N_DAYS:90\n                    ORDER BY Amount DESC\n                    LIMIT 5)\n            FROM Account\n            WHERE Type = 'Customer'\n            AND Id IN (\n                SELECT AccountId\n                FROM Opportunity\n                WHERE Amount > 100000\n                AND CloseDate >= LAST_N_DAYS:90\n            )\n            ORDER BY Name\n        ];\n    }\n\n    // ✅ WHAT: Query optimization with selective fields\n    // ✅ WHY: Only query fields you actually need to improve performance\n    // \uD83D\uDCA5 IF WRONG: SELECT * equivalent queries waste resources\n    public static void processContactsEfficiently() {\n        // ✅ BAD: Querying unnecessary fields\n        // List<Contact> contacts = [SELECT Id, Name, Email, Phone, Title,\n        //                          Department, MailingAddress, Description\n        //                          FROM Contact LIMIT 1000];\n\n        // ✅ GOOD: Only query fields you'll use\n        List<Contact> contacts = [\n            SELECT Id, Email\n            FROM Contact\n            WHERE Email != null\n            AND EmailBouncedReason = null\n            LIMIT 1000\n        ];\n\n        // ✅ Process only the data you need\n        List<String> emailAddresses = new List<String>();\n        for (Contact con : contacts) {\n            emailAddresses.add(con.Email);\n        }\n\n        // ✅ Use the collected data for business logic\n        EmailService.sendBulkEmail(emailAddresses, 'Monthly Newsletter');\n    }\n\n    // ✅ WHAT: Using IN clause with set of values\n    // ✅ WHY: Efficient way to filter by multiple values\n    public static List<Contact> getContactsByAccountTypes(Set<String> accountTypes) {\n        return [\n            SELECT Id, Name, Email, Account.Name, Account.Type\n            FROM Contact\n            WHERE Account.Type IN :accountTypes\n            AND Email != null\n            ORDER BY Account.Name, Name\n        ];\n    }\n}",annotations:[{arrows:"    ↑",explanation:"String.escapeSingleQuotes() prevents SOQL injection. Always sanitize user input in dynamic queries",type:"danger",icon:"\uD83D\uDEE1️"},{arrows:"         ↑",explanation:"Aggregate queries (SUM, COUNT, AVG) perform calculations at database level for better performance",type:"success",icon:"\uD83D\uDCCA"},{arrows:"              ↑",explanation:"Date literals (THIS_QUARTER, LAST_N_DAYS) are timezone-aware and more reliable than date math",type:"info",icon:"\uD83D\uDCC5"},{arrows:"                   ↑",explanation:"Only query fields you actually need. This improves performance and reduces memory usage",type:"warning",icon:"⚡"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Transaction Management and Best Practices"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Understanding transactions and error handling ensures data integrity:"}),(0,s.jsx)(f,{code:"public class TransactionManager {\n\n    // ✅ WHAT: All-or-nothing transaction pattern\n    // ✅ WHY: Ensures data consistency - either all operations succeed or all fail\n    // \uD83D\uDCA5 IF WRONG: Partial updates can leave data in inconsistent state\n    public static void createOpportunityWithProducts(\n        Opportunity opp,\n        List<OpportunityLineItem> products\n    ) {\n        Savepoint sp = Database.setSavepoint();\n\n        try {\n            // ✅ Step 1: Insert opportunity\n            insert opp;\n\n            // ✅ Step 2: Set opportunity ID on products\n            for (OpportunityLineItem product : products) {\n                product.OpportunityId = opp.Id;\n            }\n\n            // ✅ Step 3: Insert products\n            insert products;\n\n            System.debug('Successfully created opportunity with ' + products.size() + ' products');\n\n        } catch (Exception e) {\n            // ✅ WHAT: Rollback on any error\n            // ✅ WHY: Maintains data integrity by undoing all changes\n            Database.rollback(sp);\n            System.debug('Transaction failed, rolled back: ' + e.getMessage());\n            throw e; // Re-throw to notify caller\n        }\n    }\n\n    // ✅ WHAT: Bulk processing with error isolation\n    // ✅ WHY: Continues processing valid records even when some fail\n    public static void bulkUpdateWithErrorHandling(List<Account> accountsToUpdate) {\n        // ✅ Use Database.update with allOrNone = false\n        Database.SaveResult[] results = Database.update(accountsToUpdate, false);\n\n        List<Account> failedAccounts = new List<Account>();\n\n        for (Integer i = 0; i < results.size(); i++) {\n            Database.SaveResult result = results[i];\n            Account acc = accountsToUpdate[i];\n\n            if (result.isSuccess()) {\n                System.debug('Updated account: ' + acc.Name);\n            } else {\n                // ✅ Collect failed records for retry or manual review\n                failedAccounts.add(acc);\n\n                // ✅ Log specific error details\n                for (Database.Error error : result.getErrors()) {\n                    System.debug('Failed to update ' + acc.Name + ': ' +\n                               error.getMessage() + ' (Field: ' + error.getFields() + ')');\n                }\n            }\n        }\n\n        // ✅ Handle failed records appropriately\n        if (!failedAccounts.isEmpty()) {\n            // Could retry, send to admin, or store for manual processing\n            System.debug(failedAccounts.size() + ' accounts failed to update');\n        }\n    }\n\n    // ✅ WHAT: Query optimization to avoid limits\n    // ✅ WHY: Prevents hitting SOQL query limits in bulk operations\n    // \uD83D\uDCA5 IF WRONG: Multiple queries in loops hit governor limits\n    public static void processAccountContactRelationships() {\n        // ✅ GOOD: Single query with relationships\n        List<Account> accountsWithContacts = [\n            SELECT Id, Name, Type,\n                   (SELECT Id, Name, Email FROM Contacts WHERE Email != null)\n            FROM Account\n            WHERE Type = 'Customer'\n            AND Id IN (SELECT AccountId FROM Contact WHERE Email != null)\n        ];\n\n        // ✅ Process all data from single query\n        for (Account acc : accountsWithContacts) {\n            System.debug('Account: ' + acc.Name + ' has ' + acc.Contacts.size() + ' contacts');\n\n            for (Contact con : acc.Contacts) {\n                // ✅ Process each contact\n                EmailService.addToNewsletter(con.Email);\n            }\n        }\n\n        // ✅ BAD: This would create N+1 query problem\n        // for (Account acc : accounts) {\n        //     List<Contact> contacts = [SELECT Id, Email FROM Contact WHERE AccountId = :acc.Id];\n        //     // This creates one query per account!\n        // }\n    }\n\n    // ✅ WHAT: Proper exception handling hierarchy\n    // ✅ WHY: Different error types need different handling strategies\n    public static void handleDifferentExceptionTypes(List<Contact> contactsToProcess) {\n        try {\n            insert contactsToProcess;\n\n        } catch (DmlException e) {\n            // ✅ Handle DML-specific errors\n            System.debug('DML Error occurred: ' + e.getMessage());\n\n            for (Integer i = 0; i < e.getNumDml(); i++) {\n                System.debug('Record ' + i + ' failed: ' + e.getDmlMessage(i));\n                System.debug('Error code: ' + e.getDmlType(i));\n                System.debug('Failed fields: ' + e.getDmlFields(i));\n            }\n\n        } catch (QueryException e) {\n            // ✅ Handle query-related errors\n            System.debug('Query Error: ' + e.getMessage());\n\n        } catch (Exception e) {\n            // ✅ Handle any other unexpected errors\n            System.debug('Unexpected error: ' + e.getMessage());\n            System.debug('Stack trace: ' + e.getStackTraceString());\n\n            // ✅ Could send email to admin or log to custom object\n            ErrorLogger.logError('ContactProcessor', 'handleDifferentExceptionTypes', e);\n        }\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Savepoints allow you to rollback to a specific point if errors occur, maintaining data integrity",type:"info",icon:"\uD83D\uDCBE"},{arrows:"         ↑",explanation:"Database.update with allOrNone=false allows partial success and detailed error information",type:"success",icon:"\uD83D\uDD04"},{arrows:"              ↑",explanation:"Use relationship queries to avoid N+1 problems. One query with subqueries beats many individual queries",type:"warning",icon:"⚡"},{arrows:"                   ↑",explanation:"Catch specific exception types (DmlException, QueryException) for targeted error handling",type:"info",icon:"\uD83C\uDFAF"}]})]}),(0,s.jsxs)("section",{className:"bg-green-50 dark:bg-green-900/20 rounded-lg p-6",children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-green-900 dark:text-green-100 mb-3",children:"\uD83D\uDE80 Database Performance Tips"}),(0,s.jsxs)("ul",{className:"space-y-2 text-green-800 dark:text-green-200",children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Selective Queries:"})," Only query fields you need, use WHERE clauses to filter"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Bulk Operations:"})," Always process records in bulk, never use DML in loops"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Relationship Queries:"})," Use subqueries instead of separate queries to avoid N+1 problems"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Error Handling:"})," Use Database.* methods with allOrNone=false for partial success"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Governor Limits:"})," Be aware of SOQL query limits (100), DML row limits (10,000), heap size"]})]})]})]})},{id:"triggers",title:"Triggers",icon:p.Z,description:"Apex triggers and automation patterns",content:(0,s.jsxs)("div",{className:"space-y-8",children:[(0,s.jsx)("div",{children:(0,s.jsxs)("p",{className:"text-lg text-gray-700 dark:text-gray-300 mb-6",children:[(0,s.jsx)("strong",{children:"Your data needs automated business logic."})," Triggers execute automatically when records are inserted, updated, or deleted. They're powerful but require careful design to avoid performance issues and maintain data integrity."]})}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Trigger Fundamentals and Context"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Every trigger provides context about the operation being performed. Understanding this context is crucial for writing effective triggers:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Trigger declaration with multiple events\n// ✅ WHY: Single trigger handles all events for better organization and performance\n// \uD83D\uDCA5 IF WRONG: Multiple triggers on same object can cause unexpected execution order\ntrigger AccountTrigger on Account (before insert, before update, after insert, after update, after delete) {\n\n    // ✅ WHAT: Using Trigger.isExecuting to check if running in trigger context\n    // ✅ WHY: Prevents logic execution outside trigger context\n    if (!Trigger.isExecuting) {\n        return;\n    }\n\n    // ✅ WHAT: Separate handler class for trigger logic\n    // ✅ WHY: Keeps trigger lean, makes logic testable and reusable\n    // \uD83D\uDCA5 IF WRONG: Business logic in trigger makes testing difficult\n    AccountTriggerHandler handler = new AccountTriggerHandler();\n\n    // ✅ WHAT: Context-specific logic based on trigger operation\n    // ✅ WHY: Different events need different processing logic\n    if (Trigger.isBefore) {\n        if (Trigger.isInsert) {\n            // ✅ Before insert: validation, default values, field manipulation\n            handler.handleBeforeInsert(Trigger.new);\n        }\n        if (Trigger.isUpdate) {\n            // ✅ Before update: validation, field updates based on changes\n            handler.handleBeforeUpdate(Trigger.new, Trigger.oldMap);\n        }\n    }\n\n    if (Trigger.isAfter) {\n        if (Trigger.isInsert) {\n            // ✅ After insert: create related records, send notifications\n            handler.handleAfterInsert(Trigger.newMap);\n        }\n        if (Trigger.isUpdate) {\n            // ✅ After update: update related records, audit changes\n            handler.handleAfterUpdate(Trigger.newMap, Trigger.oldMap);\n        }\n        if (Trigger.isDelete) {\n            // ✅ After delete: cleanup related records, logging\n            handler.handleAfterDelete(Trigger.oldMap);\n        }\n    }\n}\n\n// ✅ WHAT: Dedicated handler class for trigger logic\n// ✅ WHY: Separation of concerns, easier testing, reusable code\npublic class AccountTriggerHandler {\n\n    // ✅ WHAT: Prevent recursive trigger execution\n    // ✅ WHY: Stops infinite loops when trigger logic causes more triggers\n    private static Boolean isProcessing = false;\n\n    public void handleBeforeInsert(List<Account> newAccounts) {\n        if (isProcessing) return;\n        isProcessing = true;\n\n        try {\n            // ✅ WHAT: Default value assignment in before trigger\n            // ✅ WHY: Before triggers can modify record fields before save\n            for (Account acc : newAccounts) {\n                if (String.isBlank(acc.AccountNumber)) {\n                    acc.AccountNumber = generateAccountNumber();\n                }\n\n                // ✅ Set default industry if not provided\n                if (String.isBlank(acc.Industry)) {\n                    acc.Industry = 'Other';\n                }\n\n                // ✅ Standardize account name formatting\n                if (String.isNotBlank(acc.Name)) {\n                    acc.Name = acc.Name.trim();\n                }\n            }\n\n        } finally {\n            isProcessing = false;\n        }\n    }\n\n    public void handleBeforeUpdate(List<Account> newAccounts, Map<Id, Account> oldAccountMap) {\n        if (isProcessing) return;\n        isProcessing = true;\n\n        try {\n            for (Account newAcc : newAccounts) {\n                Account oldAcc = oldAccountMap.get(newAcc.Id);\n\n                // ✅ WHAT: Field change detection\n                // ✅ WHY: Only process records where specific fields changed\n                if (hasSignificantChange(newAcc, oldAcc)) {\n                    newAcc.Last_Significant_Update__c = System.now();\n\n                    // ✅ Log the change type\n                    if (newAcc.Type != oldAcc.Type) {\n                        newAcc.Type_Change_History__c =\n                            (newAcc.Type_Change_History__c != null ? newAcc.Type_Change_History__c + '; ' : '') +\n                            'Changed from ' + oldAcc.Type + ' to ' + newAcc.Type + ' on ' + System.today();\n                    }\n                }\n            }\n\n        } finally {\n            isProcessing = false;\n        }\n    }\n\n    // ✅ WHAT: Helper method to detect significant field changes\n    // ✅ WHY: Reduces unnecessary processing and improves performance\n    private Boolean hasSignificantChange(Account newAcc, Account oldAcc) {\n        return newAcc.Type != oldAcc.Type ||\n               newAcc.Industry != oldAcc.Industry ||\n               newAcc.AnnualRevenue != oldAcc.AnnualRevenue;\n    }\n\n    private String generateAccountNumber() {\n        // ✅ Simple account number generation\n        return 'ACC-' + String.valueOf(System.currentTimeMillis()).right(8);\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Triggers should handle multiple events in one trigger for better organization and predictable execution order",type:"info",icon:"\uD83D\uDD04"},{arrows:"         ↑",explanation:"Use separate handler classes to keep triggers lean and make business logic testable",type:"success",icon:"\uD83C\uDFD7️"},{arrows:"              ↑",explanation:"Before triggers can modify record fields. Use them for validation, default values, and field manipulation",type:"warning",icon:"⚡"},{arrows:"                   ↑",explanation:"Recursion prevention is crucial to avoid infinite trigger loops when your logic modifies data",type:"danger",icon:"\uD83D\uDD01"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Bulkification and Performance Patterns"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Triggers must handle bulk operations efficiently. Always design for collections, never individual records:"}),(0,s.jsx)(f,{code:"public class OpportunityTriggerHandler {\n\n    // ✅ WHAT: Bulk-safe after insert handler\n    // ✅ WHY: Handles 1 record or 200 records with same performance characteristics\n    // \uD83D\uDCA5 IF WRONG: Per-record processing hits governor limits quickly\n    public void handleAfterInsert(Map<Id, Opportunity> newOpportunityMap) {\n        // ✅ Collect all account IDs in one pass\n        Set<Id> accountIds = new Set<Id>();\n        List<Opportunity> highValueOpps = new List<Opportunity>();\n\n        for (Opportunity opp : newOpportunityMap.values()) {\n            accountIds.add(opp.AccountId);\n\n            // ✅ Identify high-value opportunities for special processing\n            if (opp.Amount > 100000) {\n                highValueOpps.add(opp);\n            }\n        }\n\n        // ✅ WHAT: Single query to get all related account data\n        // ✅ WHY: One query handles all accounts, regardless of opportunity count\n        // \uD83D\uDCA5 IF WRONG: Querying in loops creates N+1 query problems\n        Map<Id, Account> accountMap = new Map<Id, Account>([\n            SELECT Id, Name, Type, Industry, Owner.Email\n            FROM Account\n            WHERE Id IN :accountIds\n        ]);\n\n        // ✅ Process high-value opportunities\n        if (!highValueOpps.isEmpty()) {\n            createHighValueOpportunityTasks(highValueOpps, accountMap);\n        }\n\n        // ✅ Update account statistics in bulk\n        updateAccountOpportunityStats(accountIds);\n    }\n\n    // ✅ WHAT: Bulk task creation pattern\n    // ✅ WHY: Creates all tasks in single DML operation\n    private void createHighValueOpportunityTasks(\n        List<Opportunity> opportunities,\n        Map<Id, Account> accountMap\n    ) {\n        List<Task> tasksToCreate = new List<Task>();\n\n        for (Opportunity opp : opportunities) {\n            Account acc = accountMap.get(opp.AccountId);\n\n            // ✅ Create task for opportunity owner\n            Task oppTask = new Task(\n                WhatId = opp.Id,\n                OwnerId = opp.OwnerId,\n                Subject = 'Follow up on high-value opportunity: ' + opp.Name,\n                Description = 'Opportunity amount: $' + opp.Amount +\n                            '\\nAccount: ' + acc.Name +\n                            '\\nIndustry: ' + acc.Industry,\n                ActivityDate = System.today().addDays(1),\n                Status = 'Not Started',\n                Priority = 'High'\n            );\n            tasksToCreate.add(oppTask);\n\n            // ✅ Create task for account owner if different\n            if (acc.OwnerId != opp.OwnerId) {\n                Task accTask = new Task(\n                    WhatId = acc.Id,\n                    OwnerId = acc.OwnerId,\n                    Subject = 'High-value opportunity created on your account',\n                    Description = 'New opportunity: ' + opp.Name +\n                                '\\nAmount: $' + opp.Amount,\n                    ActivityDate = System.today().addDays(1),\n                    Status = 'Not Started',\n                    Priority = 'Normal'\n                );\n                tasksToCreate.add(accTask);\n            }\n        }\n\n        // ✅ WHAT: Single DML operation for all tasks\n        // ✅ WHY: Efficient regardless of number of tasks created\n        if (!tasksToCreate.isEmpty()) {\n            insert tasksToCreate;\n        }\n    }\n\n    // ✅ WHAT: Bulk update of related records\n    // ✅ WHY: Updates account statistics based on opportunity changes\n    private void updateAccountOpportunityStats(Set<Id> accountIds) {\n        // ✅ Query current opportunity statistics\n        List<AggregateResult> oppStats = [\n            SELECT AccountId, COUNT(Id) oppCount, SUM(Amount) totalAmount\n            FROM Opportunity\n            WHERE AccountId IN :accountIds\n            AND StageName NOT IN ('Closed Lost', 'Closed Won')\n            GROUP BY AccountId\n        ];\n\n        List<Account> accountsToUpdate = new List<Account>();\n\n        for (AggregateResult stat : oppStats) {\n            Account acc = new Account(\n                Id = (Id) stat.get('AccountId'),\n                Active_Opportunity_Count__c = (Integer) stat.get('oppCount'),\n                Total_Pipeline_Amount__c = (Decimal) stat.get('totalAmount')\n            );\n            accountsToUpdate.add(acc);\n        }\n\n        // ✅ Single update for all affected accounts\n        if (!accountsToUpdate.isEmpty()) {\n            update accountsToUpdate;\n        }\n    }\n\n    // ✅ WHAT: Bulk-safe update handler with change detection\n    // ✅ WHY: Only processes records where relevant fields changed\n    public void handleAfterUpdate(Map<Id, Opportunity> newOpportunityMap, Map<Id, Opportunity> oldOpportunityMap) {\n        List<Opportunity> stageChangedOpps = new List<Opportunity>();\n        List<Opportunity> amountChangedOpps = new List<Opportunity>();\n\n        // ✅ Identify what type of changes occurred\n        for (Id oppId : newOpportunityMap.keySet()) {\n            Opportunity newOpp = newOpportunityMap.get(oppId);\n            Opportunity oldOpp = oldOpportunityMap.get(oppId);\n\n            // ✅ Stage change detection\n            if (newOpp.StageName != oldOpp.StageName) {\n                stageChangedOpps.add(newOpp);\n            }\n\n            // ✅ Amount change detection\n            if (newOpp.Amount != oldOpp.Amount) {\n                amountChangedOpps.add(newOpp);\n            }\n        }\n\n        // ✅ Process each type of change appropriately\n        if (!stageChangedOpps.isEmpty()) {\n            processStageChanges(stageChangedOpps, oldOpportunityMap);\n        }\n\n        if (!amountChangedOpps.isEmpty()) {\n            // Update account pipeline amounts\n            Set<Id> affectedAccountIds = new Set<Id>();\n            for (Opportunity opp : amountChangedOpps) {\n                affectedAccountIds.add(opp.AccountId);\n            }\n            updateAccountOpportunityStats(affectedAccountIds);\n        }\n    }\n\n    private void processStageChanges(List<Opportunity> changedOpps, Map<Id, Opportunity> oldOpportunityMap) {\n        List<Opportunity> wonOpps = new List<Opportunity>();\n        List<Opportunity> lostOpps = new List<Opportunity>();\n\n        for (Opportunity opp : changedOpps) {\n            if (opp.StageName == 'Closed Won') {\n                wonOpps.add(opp);\n            } else if (opp.StageName == 'Closed Lost') {\n                lostOpps.add(opp);\n            }\n        }\n\n        // ✅ Handle won opportunities\n        if (!wonOpps.isEmpty()) {\n            createWonOpportunityFollowups(wonOpps);\n        }\n\n        // ✅ Handle lost opportunities\n        if (!lostOpps.isEmpty()) {\n            logLostOpportunityReasons(lostOpps);\n        }\n    }\n\n    private void createWonOpportunityFollowups(List<Opportunity> wonOpps) {\n        List<Task> followupTasks = new List<Task>();\n\n        for (Opportunity opp : wonOpps) {\n            Task followup = new Task(\n                WhatId = opp.Id,\n                OwnerId = opp.OwnerId,\n                Subject = 'Implementation planning for won opportunity',\n                Description = 'Begin implementation planning for: ' + opp.Name,\n                ActivityDate = System.today().addDays(3),\n                Status = 'Not Started',\n                Priority = 'High'\n            );\n            followupTasks.add(followup);\n        }\n\n        if (!followupTasks.isEmpty()) {\n            insert followupTasks;\n        }\n    }\n\n    private void logLostOpportunityReasons(List<Opportunity> lostOpps) {\n        // ✅ Could create custom log records, send reports, etc.\n        for (Opportunity opp : lostOpps) {\n            System.debug('Lost opportunity: ' + opp.Name +\n                        ', Reason: ' + opp.Loss_Reason__c +\n                        ', Amount: $' + opp.Amount);\n        }\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Always collect data in bulk first, then process collections. Never query or process one record at a time",type:"success",icon:"\uD83D\uDCE6"},{arrows:"         ↑",explanation:"Single queries handle all related data efficiently, avoiding N+1 query patterns in triggers",type:"warning",icon:"\uD83D\uDD0D"},{arrows:"              ↑",explanation:"Build collections of records to modify, then use single DML operations for all changes",type:"info",icon:"⚡"},{arrows:"                   ↑",explanation:"Detect specific field changes to avoid unnecessary processing and improve trigger performance",type:"info",icon:"\uD83C\uDFAF"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Advanced Trigger Patterns"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Complex business requirements need sophisticated trigger patterns. Here are proven approaches:"}),(0,s.jsx)(f,{code:"public class ContactTriggerHandler {\n\n    // ✅ WHAT: Platform event publishing from triggers\n    // ✅ WHY: Decouples trigger logic from external system integration\n    // \uD83D\uDCA5 IF WRONG: Direct callouts from triggers are not allowed\n    public void handleAfterInsert(List<Contact> newContacts) {\n        List<Contact_Created__e> eventsToPublish = new List<Contact_Created__e>();\n\n        for (Contact con : newContacts) {\n            // ✅ Create platform event for external system notification\n            Contact_Created__e event = new Contact_Created__e(\n                Contact_Id__c = con.Id,\n                Contact_Name__c = con.Name,\n                Account_Id__c = con.AccountId,\n                Email__c = con.Email,\n                Created_Date__c = System.now()\n            );\n            eventsToPublish.add(event);\n        }\n\n        // ✅ Publish events for asynchronous processing\n        if (!eventsToPublish.isEmpty()) {\n            EventBus.publish(eventsToPublish);\n        }\n    }\n\n    // ✅ WHAT: Complex validation with related record checking\n    // ✅ WHY: Business rules often require checking related data\n    public void handleBeforeInsert(List<Contact> newContacts) {\n        // ✅ Collect account IDs for bulk validation\n        Set<Id> accountIds = new Set<Id>();\n        for (Contact con : newContacts) {\n            if (con.AccountId != null) {\n                accountIds.add(con.AccountId);\n            }\n        }\n\n        // ✅ Get account information in bulk\n        Map<Id, Account> accountMap = new Map<Id, Account>([\n            SELECT Id, Type, Max_Contacts__c,\n                   (SELECT Id FROM Contacts)\n            FROM Account\n            WHERE Id IN :accountIds\n        ]);\n\n        // ✅ Validate each contact against business rules\n        for (Contact con : newContacts) {\n            validateContactBusinessRules(con, accountMap.get(con.AccountId));\n        }\n    }\n\n    private void validateContactBusinessRules(Contact con, Account acc) {\n        if (acc == null) return;\n\n        // ✅ WHAT: Business rule validation\n        // ✅ WHY: Enforce data quality and business constraints\n\n        // Rule 1: Customer accounts can have unlimited contacts\n        // Rule 2: Prospect accounts limited to 3 contacts\n        // Rule 3: Partner accounts limited to 10 contacts\n\n        Integer currentContactCount = acc.Contacts.size();\n        Integer maxAllowed = getMaxContactsForAccountType(acc.Type, acc.Max_Contacts__c);\n\n        if (maxAllowed != null && currentContactCount >= maxAllowed) {\n            con.addError('Account ' + acc.Id + ' has reached maximum allowed contacts (' +\n                        maxAllowed + ') for account type: ' + acc.Type);\n        }\n\n        // ✅ Email domain validation for specific account types\n        if (acc.Type == 'Customer' && String.isNotBlank(con.Email)) {\n            if (!isValidEmailDomain(con.Email, acc.Id)) {\n                con.Email.addError('Email domain does not match approved domains for this account');\n            }\n        }\n    }\n\n    private Integer getMaxContactsForAccountType(String accountType, Decimal customLimit) {\n        // ✅ Custom limit takes precedence\n        if (customLimit != null) {\n            return customLimit.intValue();\n        }\n\n        // ✅ Default limits by account type\n        switch on accountType {\n            when 'Customer' { return null; } // Unlimited\n            when 'Prospect' { return 3; }\n            when 'Partner' { return 10; }\n            when else { return 5; } // Default limit\n        }\n    }\n\n    private Boolean isValidEmailDomain(String email, Id accountId) {\n        // ✅ This could check against approved domain list\n        // For now, simple validation\n        if (!email.contains('@')) return false;\n\n        String domain = email.split('@')[1].toLowerCase();\n\n        // ✅ Could query custom metadata for approved domains per account\n        // List<Approved_Domain__mdt> approvedDomains = [SELECT Domain__c FROM Approved_Domain__mdt];\n\n        return true; // Simplified for example\n    }\n\n    // ✅ WHAT: Trigger framework pattern with bypass mechanism\n    // ✅ WHY: Allows selective trigger bypass for data migration or testing\n    public void handleBeforeUpdate(List<Contact> newContacts, Map<Id, Contact> oldContactMap) {\n        // ✅ Check if triggers should be bypassed\n        if (TriggerBypassManager.isBypassed('ContactTrigger')) {\n            return;\n        }\n\n        List<Contact> emailChangedContacts = new List<Contact>();\n        List<Contact> nameChangedContacts = new List<Contact>();\n\n        // ✅ Categorize changes for targeted processing\n        for (Contact newCon : newContacts) {\n            Contact oldCon = oldContactMap.get(newCon.Id);\n\n            if (newCon.Email != oldCon.Email) {\n                emailChangedContacts.add(newCon);\n            }\n\n            if (newCon.FirstName != oldCon.FirstName || newCon.LastName != oldCon.LastName) {\n                nameChangedContacts.add(newCon);\n            }\n        }\n\n        // ✅ Process each type of change\n        if (!emailChangedContacts.isEmpty()) {\n            validateEmailChanges(emailChangedContacts, oldContactMap);\n        }\n\n        if (!nameChangedContacts.isEmpty()) {\n            processNameChanges(nameChangedContacts, oldContactMap);\n        }\n    }\n\n    private void validateEmailChanges(List<Contact> contacts, Map<Id, Contact> oldContactMap) {\n        for (Contact con : contacts) {\n            Contact oldCon = oldContactMap.get(con.Id);\n\n            // ✅ Log email changes for audit\n            if (String.isNotBlank(oldCon.Email)) {\n                con.Email_Change_History__c =\n                    (con.Email_Change_History__c != null ? con.Email_Change_History__c + '; ' : '') +\n                    'Changed from ' + oldCon.Email + ' to ' + con.Email + ' on ' + System.today();\n            }\n        }\n    }\n\n    private void processNameChanges(List<Contact> contacts, Map<Id, Contact> oldContactMap) {\n        for (Contact con : contacts) {\n            // ✅ Update full name field\n            con.Full_Name__c =\n                (String.isNotBlank(con.FirstName) ? con.FirstName + ' ' : '') +\n                (String.isNotBlank(con.LastName) ? con.LastName : '');\n\n            // ✅ Set flag for external system sync\n            con.Needs_External_Sync__c = true;\n        }\n    }\n\n    // ✅ WHAT: After delete cleanup pattern\n    // ✅ WHY: Maintain data integrity when records are deleted\n    public void handleAfterDelete(Map<Id, Contact> deletedContactMap) {\n        Set<Id> accountIds = new Set<Id>();\n        List<Id> contactIds = new List<Id>(deletedContactMap.keySet());\n\n        // ✅ Collect related account IDs\n        for (Contact con : deletedContactMap.values()) {\n            if (con.AccountId != null) {\n                accountIds.add(con.AccountId);\n            }\n        }\n\n        // ✅ Update account contact counts\n        if (!accountIds.isEmpty()) {\n            updateAccountContactCounts(accountIds);\n        }\n\n        // ✅ Archive contact relationships\n        archiveContactRelationships(contactIds);\n    }\n\n    private void updateAccountContactCounts(Set<Id> accountIds) {\n        List<AggregateResult> contactCounts = [\n            SELECT AccountId, COUNT(Id) contactCount\n            FROM Contact\n            WHERE AccountId IN :accountIds\n            GROUP BY AccountId\n        ];\n\n        List<Account> accountsToUpdate = new List<Account>();\n\n        for (AggregateResult result : contactCounts) {\n            Account acc = new Account(\n                Id = (Id) result.get('AccountId'),\n                Contact_Count__c = (Integer) result.get('contactCount')\n            );\n            accountsToUpdate.add(acc);\n        }\n\n        if (!accountsToUpdate.isEmpty()) {\n            update accountsToUpdate;\n        }\n    }\n\n    private void archiveContactRelationships(List<Id> contactIds) {\n        // ✅ Could create archive records, update related data, etc.\n        List<Contact_Archive__c> archives = new List<Contact_Archive__c>();\n\n        for (Id contactId : contactIds) {\n            Contact_Archive__c archive = new Contact_Archive__c(\n                Original_Contact_Id__c = contactId,\n                Archived_Date__c = System.now(),\n                Archived_By__c = UserInfo.getUserId()\n            );\n            archives.add(archive);\n        }\n\n        if (!archives.isEmpty()) {\n            insert archives;\n        }\n    }\n}\n\n// ✅ WHAT: Trigger bypass utility class\n// ✅ WHY: Allows controlled trigger bypass for data operations\npublic class TriggerBypassManager {\n    private static Set<String> bypassedTriggers = new Set<String>();\n\n    public static void bypass(String triggerName) {\n        bypassedTriggers.add(triggerName);\n    }\n\n    public static void clearBypass(String triggerName) {\n        bypassedTriggers.remove(triggerName);\n    }\n\n    public static Boolean isBypassed(String triggerName) {\n        return bypassedTriggers.contains(triggerName);\n    }\n\n    public static void clearAllBypasses() {\n        bypassedTriggers.clear();\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Platform events allow triggers to integrate with external systems without direct callouts",type:"info",icon:"\uD83D\uDCE1"},{arrows:"         ↑",explanation:"Complex validation often requires checking related records. Always do this in bulk",type:"warning",icon:"✅"},{arrows:"              ↑",explanation:"Categorize changes by type to avoid unnecessary processing and improve performance",type:"success",icon:"\uD83C\uDFAF"},{arrows:"                   ↑",explanation:"Trigger bypass mechanisms are essential for data migration and selective trigger disabling",type:"info",icon:"\uD83D\uDD27"}]})]}),(0,s.jsxs)("section",{className:"bg-red-50 dark:bg-red-900/20 rounded-lg p-6",children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-red-900 dark:text-red-100 mb-3",children:"⚠️ Trigger Anti-Patterns to Avoid"}),(0,s.jsxs)("ul",{className:"space-y-2 text-red-800 dark:text-red-200",children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"DML in Loops:"})," Never use insert/update/delete inside for loops - always build collections"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"SOQL in Loops:"})," Avoid queries inside loops - get all data upfront with relationship queries"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"No Recursion Control:"})," Always implement recursion prevention to avoid infinite trigger loops"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Business Logic in Trigger:"})," Keep triggers lean - move complex logic to handler classes"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"No Error Handling:"})," Implement proper exception handling and partial success patterns"]})]})]})]})},{id:"async",title:"Async Apex",icon:m.Z,description:"Future methods, batch Apex, and queueable",content:(0,s.jsxs)("div",{className:"space-y-8",children:[(0,s.jsx)("div",{children:(0,s.jsxs)("p",{className:"text-lg text-gray-700 dark:text-gray-300 mb-6",children:[(0,s.jsx)("strong",{children:"Your business logic needs to escape governor limits."})," Asynchronous Apex runs your code in separate transactions with higher limits, allowing processing of large data volumes, external integrations, and long-running operations without blocking user interactions."]})}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Future Methods - Simple Async Processing"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Future methods execute asynchronously with higher governor limits. Perfect for callouts and simple background processing:"}),(0,s.jsx)(f,{code:"public class ExternalIntegrationService {\n\n    // ✅ WHAT: Future method declaration\n    // ✅ WHY: @future annotation makes method execute asynchronously\n    // \uD83D\uDCA5 IF WRONG: Without @future, callouts block user interface\n    @future(callout=true)\n    public static void syncAccountToExternalSystem(Set<Id> accountIds) {\n        // ✅ WHAT: Higher governor limits in async context\n        // ✅ WHY: Future methods get 12MB heap, 60 second timeout\n        // \uD83D\uDCA5 IF WRONG: Sync context has 6MB heap, 10 second timeout\n\n        List<Account> accounts = [\n            SELECT Id, Name, Type, Industry, BillingAddress\n            FROM Account\n            WHERE Id IN :accountIds\n            LIMIT 200 // ✅ Future methods can process more records\n        ];\n\n        for (Account acc : accounts) {\n            try {\n                // ✅ WHAT: HTTP callout to external system\n                // ✅ WHY: Future methods allow callouts, sync methods don't (in triggers)\n                syncSingleAccount(acc);\n\n                // ✅ Update sync status\n                acc.External_Sync_Status__c = 'Synced';\n                acc.Last_Sync_Date__c = System.now();\n\n            } catch (Exception e) {\n                // ✅ Handle individual record failures\n                acc.External_Sync_Status__c = 'Failed';\n                acc.Sync_Error_Message__c = e.getMessage();\n                System.debug('Failed to sync account ' + acc.Id + ': ' + e.getMessage());\n            }\n        }\n\n        // ✅ Bulk update all accounts\n        try {\n            update accounts;\n        } catch (DmlException e) {\n            System.debug('Failed to update sync status: ' + e.getMessage());\n        }\n    }\n\n    // ✅ WHAT: Helper method for individual account sync\n    // ✅ WHY: Separates HTTP logic from bulk processing logic\n    private static void syncSingleAccount(Account acc) {\n        HttpRequest req = new HttpRequest();\n        req.setEndpoint('https://external-system.com/api/accounts');\n        req.setMethod('POST');\n        req.setHeader('Content-Type', 'application/json');\n\n        // ✅ Build JSON payload\n        Map<String, Object> payload = new Map<String, Object>{\n            'salesforceId' => acc.Id,\n            'name' => acc.Name,\n            'type' => acc.Type,\n            'industry' => acc.Industry\n        };\n\n        req.setBody(JSON.serialize(payload));\n\n        Http http = new Http();\n        HttpResponse res = http.send(req);\n\n        if (res.getStatusCode() != 200) {\n            throw new CalloutException('HTTP ' + res.getStatusCode() + ': ' + res.getBody());\n        }\n    }\n\n    // ✅ WHAT: Future method for email notifications\n    // ✅ WHY: Async processing prevents email delays from blocking UI\n    @future\n    public static void sendBulkNotifications(Set<Id> opportunityIds, String templateName) {\n        List<Opportunity> opportunities = [\n            SELECT Id, Name, Amount, CloseDate, StageName,\n                   Account.Name, Owner.Email, Owner.Name\n            FROM Opportunity\n            WHERE Id IN :opportunityIds\n        ];\n\n        List<Messaging.SingleEmailMessage> emails = new List<Messaging.SingleEmailMessage>();\n\n        for (Opportunity opp : opportunities) {\n            if (String.isNotBlank(opp.Owner.Email)) {\n                Messaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\n                email.setToAddresses(new String[] { opp.Owner.Email });\n                email.setSubject('Opportunity Update: ' + opp.Name);\n\n                String body = 'Dear ' + opp.Owner.Name + ',\\n\\n' +\n                             'Your opportunity ' + opp.Name + ' has been updated.\\n' +\n                             'Amount: $' + opp.Amount + '\\n' +\n                             'Stage: ' + opp.StageName + '\\n' +\n                             'Close Date: ' + opp.CloseDate + '\\n\\n' +\n                             'Best regards,\\nSalesforce System';\n\n                email.setPlainTextBody(body);\n                emails.add(email);\n            }\n        }\n\n        // ✅ WHAT: Bulk email sending\n        // ✅ WHY: Single email operation handles multiple messages efficiently\n        if (!emails.isEmpty()) {\n            try {\n                Messaging.sendEmail(emails);\n                System.debug('Sent ' + emails.size() + ' notification emails');\n            } catch (Exception e) {\n                System.debug('Failed to send emails: ' + e.getMessage());\n            }\n        }\n    }\n\n    // ✅ WHAT: Future method with primitive parameters only\n    // ✅ WHY: Future methods can only accept primitive types and collections of primitives\n    // \uD83D\uDCA5 IF WRONG: Passing sObjects or custom classes causes compilation error\n    @future\n    public static void processRecords(List<Id> recordIds, String processType, Boolean isUrgent) {\n        // ✅ Query records inside future method\n        if (processType == 'ACCOUNT') {\n            List<Account> accounts = [SELECT Id, Name FROM Account WHERE Id IN :recordIds];\n            // Process accounts...\n        } else if (processType == 'CONTACT') {\n            List<Contact> contacts = [SELECT Id, Name FROM Contact WHERE Id IN :recordIds];\n            // Process contacts...\n        }\n    }\n}",annotations:[{arrows:"    ↑",explanation:"@future annotation executes method asynchronously with higher limits. Must be static and use primitive parameters only",type:"info",icon:"⚡"},{arrows:"         ↑",explanation:"Future methods get higher governor limits: 12MB heap vs 6MB, and can make HTTP callouts",type:"success",icon:"\uD83D\uDCC8"},{arrows:"              ↑",explanation:"Always handle individual record failures in async processing to avoid losing all work",type:"warning",icon:"\uD83D\uDEE1️"},{arrows:"                   ↑",explanation:"Future methods accept only primitives. Query sObjects inside the method, don't pass them as parameters",type:"danger",icon:"⚠️"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Batch Apex - Large Data Processing"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Batch Apex processes large datasets by breaking them into manageable chunks. Essential for data migration and bulk operations:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Batch class implementing Database.Batchable interface\n// ✅ WHY: Processes large datasets in chunks to avoid governor limits\n// \uD83D\uDCA5 IF WRONG: Processing millions of records synchronously hits limits\npublic class AccountCleanupBatch implements Database.Batchable<sObject>, Database.Stateful {\n\n    // ✅ WHAT: Instance variables for tracking batch state\n    // ✅ WHY: Database.Stateful preserves state across batch chunks\n    private Integer recordsProcessed = 0;\n    private Integer recordsUpdated = 0;\n    private Integer recordsWithErrors = 0;\n\n    private String processType;\n    private Date cutoffDate;\n\n    // ✅ WHAT: Constructor for batch configuration\n    // ✅ WHY: Allows parameterized batch execution\n    public AccountCleanupBatch(String processType, Date cutoffDate) {\n        this.processType = processType;\n        this.cutoffDate = cutoffDate;\n    }\n\n    // ✅ WHAT: start() method defines the dataset to process\n    // ✅ WHY: Returns a QueryLocator or Iterable for the batch to process\n    public Database.QueryLocator start(Database.BatchableContext context) {\n        System.debug('Starting AccountCleanupBatch for process: ' + processType);\n\n        String query;\n\n        // ✅ Build query based on process type\n        switch on processType {\n            when 'INACTIVE_CLEANUP' {\n                query = 'SELECT Id, Name, Type, LastActivityDate, Active__c ' +\n                       'FROM Account ' +\n                       'WHERE LastActivityDate < :cutoffDate ' +\n                       'AND Active__c = true';\n            }\n            when 'DUPLICATE_MERGE' {\n                query = 'SELECT Id, Name, Type, BillingPostalCode ' +\n                       'FROM Account ' +\n                       'WHERE Name != null ' +\n                       'ORDER BY Name, CreatedDate';\n            }\n            when else {\n                query = 'SELECT Id FROM Account LIMIT 0'; // Empty result\n            }\n        }\n\n        return Database.getQueryLocator(query);\n    }\n\n    // ✅ WHAT: execute() method processes each batch chunk\n    // ✅ WHY: Called once per chunk (default 200 records, configurable up to 2000)\n    public void execute(Database.BatchableContext context, List<Account> accounts) {\n        System.debug('Processing batch chunk with ' + accounts.size() + ' accounts');\n\n        recordsProcessed += accounts.size();\n\n        try {\n            switch on processType {\n                when 'INACTIVE_CLEANUP' {\n                    processInactiveAccounts(accounts);\n                }\n                when 'DUPLICATE_MERGE' {\n                    processDuplicateAccounts(accounts);\n                }\n            }\n        } catch (Exception e) {\n            System.debug('Error in batch execute: ' + e.getMessage());\n            recordsWithErrors += accounts.size();\n        }\n    }\n\n    // ✅ WHAT: finish() method called after all batches complete\n    // ✅ WHY: Performs cleanup, sends notifications, or starts dependent jobs\n    public void finish(Database.BatchableContext context) {\n        System.debug('AccountCleanupBatch completed');\n        System.debug('Records processed: ' + recordsProcessed);\n        System.debug('Records updated: ' + recordsUpdated);\n        System.debug('Records with errors: ' + recordsWithErrors);\n\n        // ✅ Send completion notification\n        sendBatchCompletionEmail(context);\n\n        // ✅ Start dependent batch if needed\n        if (processType == 'INACTIVE_CLEANUP') {\n            // Could start a follow-up batch for related data cleanup\n            // Database.executeBatch(new RelatedDataCleanupBatch());\n        }\n    }\n\n    // ✅ WHAT: Business logic for inactive account processing\n    private void processInactiveAccounts(List<Account> accounts) {\n        List<Account> accountsToUpdate = new List<Account>();\n\n        for (Account acc : accounts) {\n            // ✅ Mark as inactive if no activity for specified period\n            if (acc.LastActivityDate < cutoffDate) {\n                acc.Active__c = false;\n                acc.Deactivation_Date__c = System.today();\n                acc.Deactivation_Reason__c = 'No activity since ' + acc.LastActivityDate;\n                accountsToUpdate.add(acc);\n            }\n        }\n\n        // ✅ WHAT: Bulk update with error handling\n        // ✅ WHY: Use Database.update with partial success for batch reliability\n        if (!accountsToUpdate.isEmpty()) {\n            Database.SaveResult[] results = Database.update(accountsToUpdate, false);\n\n            for (Integer i = 0; i < results.size(); i++) {\n                if (results[i].isSuccess()) {\n                    recordsUpdated++;\n                } else {\n                    recordsWithErrors++;\n                    System.debug('Failed to update account ' + accountsToUpdate[i].Id +\n                               ': ' + results[i].getErrors()[0].getMessage());\n                }\n            }\n        }\n    }\n\n    private void processDuplicateAccounts(List<Account> accounts) {\n        // ✅ Simple duplicate detection by name\n        Map<String, List<Account>> accountsByName = new Map<String, List<Account>>();\n\n        for (Account acc : accounts) {\n            String key = acc.Name.toLowerCase().trim();\n            if (!accountsByName.containsKey(key)) {\n                accountsByName.put(key, new List<Account>());\n            }\n            accountsByName.get(key).add(acc);\n        }\n\n        List<Account> accountsToUpdate = new List<Account>();\n\n        // ✅ Mark potential duplicates\n        for (String accountName : accountsByName.keySet()) {\n            List<Account> duplicates = accountsByName.get(accountName);\n\n            if (duplicates.size() > 1) {\n                // Mark all but the first as potential duplicates\n                for (Integer i = 1; i < duplicates.size(); i++) {\n                    Account acc = duplicates[i];\n                    acc.Potential_Duplicate__c = true;\n                    acc.Duplicate_Of__c = duplicates[0].Id;\n                    accountsToUpdate.add(acc);\n                }\n            }\n        }\n\n        if (!accountsToUpdate.isEmpty()) {\n            try {\n                update accountsToUpdate;\n                recordsUpdated += accountsToUpdate.size();\n            } catch (DmlException e) {\n                recordsWithErrors += accountsToUpdate.size();\n                System.debug('Failed to mark duplicates: ' + e.getMessage());\n            }\n        }\n    }\n\n    private void sendBatchCompletionEmail(Database.BatchableContext context) {\n        Messaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\n        email.setToAddresses(new String[] { UserInfo.getUserEmail() });\n        email.setSubject('Account Cleanup Batch Completed - ' + processType);\n\n        String body = 'Account cleanup batch has completed.\\n\\n' +\n                     'Process Type: ' + processType + '\\n' +\n                     'Records Processed: ' + recordsProcessed + '\\n' +\n                     'Records Updated: ' + recordsUpdated + '\\n' +\n                     'Records with Errors: ' + recordsWithErrors + '\\n\\n' +\n                     'Job ID: ' + context.getJobId();\n\n        email.setPlainTextBody(body);\n\n        try {\n            Messaging.sendEmail(new Messaging.SingleEmailMessage[] { email });\n        } catch (Exception e) {\n            System.debug('Failed to send completion email: ' + e.getMessage());\n        }\n    }\n}\n\n// ✅ WHAT: Utility class for batch execution\n// ✅ WHY: Provides convenient methods to start different batch types\npublic class BatchJobManager {\n\n    // ✅ WHAT: Start inactive account cleanup batch\n    public static Id startInactiveAccountCleanup(Integer daysInactive) {\n        Date cutoffDate = System.today().addDays(-daysInactive);\n        AccountCleanupBatch batch = new AccountCleanupBatch('INACTIVE_CLEANUP', cutoffDate);\n\n        // ✅ WHAT: Configure batch size (default 200, max 2000)\n        // ✅ WHY: Smaller batches for complex processing, larger for simple updates\n        return Database.executeBatch(batch, 100);\n    }\n\n    // ✅ WHAT: Start duplicate detection batch\n    public static Id startDuplicateDetection() {\n        AccountCleanupBatch batch = new AccountCleanupBatch('DUPLICATE_MERGE', null);\n        return Database.executeBatch(batch, 500); // Larger batch for simple comparison\n    }\n\n    // ✅ WHAT: Check batch job status\n    public static void checkBatchStatus(Id jobId) {\n        AsyncApexJob job = [\n            SELECT Id, Status, JobType, NumberOfErrors,\n                   JobItemsProcessed, TotalJobItems, CreatedDate, CompletedDate\n            FROM AsyncApexJob\n            WHERE Id = :jobId\n        ];\n\n        System.debug('Batch Job Status: ' + job.Status);\n        System.debug('Progress: ' + job.JobItemsProcessed + '/' + job.TotalJobItems);\n        System.debug('Errors: ' + job.NumberOfErrors);\n\n        if (job.Status == 'Completed') {\n            System.debug('Job completed at: ' + job.CompletedDate);\n        }\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Batch classes implement Database.Batchable interface. Use Database.Stateful to preserve data across chunks",type:"info",icon:"\uD83D\uDD04"},{arrows:"         ↑",explanation:"start() returns QueryLocator for up to 50M records, or Iterable for complex data sources",type:"success",icon:"\uD83C\uDFAF"},{arrows:"              ↑",explanation:"execute() processes each chunk. Use Database.update with allOrNone=false for reliability",type:"warning",icon:"⚙️"},{arrows:"                   ↑",explanation:"finish() handles completion logic. Perfect for notifications or chaining dependent jobs",type:"info",icon:"\uD83C\uDFC1"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Queueable Apex - Flexible Async Processing"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Queueable Apex combines the benefits of future methods and batch Apex. It's perfect for complex async operations that need to chain together:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Queueable class implementing System.Queueable interface\n// ✅ WHY: More flexible than future methods, can chain jobs and pass complex data\npublic class OpportunityProcessingJob implements System.Queueable, Database.AllowsCallouts {\n\n    private List<Id> opportunityIds;\n    private String processType;\n    private Map<String, Object> parameters;\n\n    // ✅ WHAT: Constructor accepting complex parameters\n    // ✅ WHY: Unlike future methods, queueable can accept sObjects and complex types\n    public OpportunityProcessingJob(List<Id> oppIds, String processType, Map<String, Object> params) {\n        this.opportunityIds = oppIds;\n        this.processType = processType;\n        this.parameters = params != null ? params : new Map<String, Object>();\n    }\n\n    // ✅ WHAT: execute() method - main queueable logic\n    // ✅ WHY: Runs asynchronously with higher governor limits\n    public void execute(System.QueueableContext context) {\n        System.debug('Starting OpportunityProcessingJob: ' + processType);\n        System.debug('Processing ' + opportunityIds.size() + ' opportunities');\n\n        try {\n            switch on processType {\n                when 'STAGE_AUTOMATION' {\n                    processStageAutomation();\n                }\n                when 'EXTERNAL_SYNC' {\n                    syncWithExternalSystem();\n                }\n                when 'COMPLEX_CALCULATION' {\n                    performComplexCalculations();\n                }\n                when 'CHAIN_PROCESSING' {\n                    processAndChainNext(context);\n                }\n            }\n        } catch (Exception e) {\n            System.debug('Error in queueable job: ' + e.getMessage());\n            handleJobError(e, context);\n        }\n    }\n\n    // ✅ WHAT: Stage automation processing\n    private void processStageAutomation() {\n        List<Opportunity> opportunities = [\n            SELECT Id, Name, StageName, Amount, CloseDate,\n                   Account.Name, Account.Type, Owner.Email\n            FROM Opportunity\n            WHERE Id IN :opportunityIds\n        ];\n\n        List<Opportunity> oppsToUpdate = new List<Opportunity>();\n        List<Task> tasksToCreate = new List<Task>();\n\n        for (Opportunity opp : opportunities) {\n            // ✅ Advanced stage logic based on opportunity characteristics\n            String newStage = calculateOptimalStage(opp);\n\n            if (newStage != opp.StageName) {\n                opp.StageName = newStage;\n                opp.Stage_Change_Reason__c = 'Automated optimization';\n                oppsToUpdate.add(opp);\n\n                // ✅ Create follow-up task\n                Task followup = new Task(\n                    WhatId = opp.Id,\n                    OwnerId = opp.OwnerId,\n                    Subject = 'Review automated stage change: ' + newStage,\n                    Description = 'Opportunity automatically moved to ' + newStage +\n                                ' based on optimization rules.',\n                    ActivityDate = System.today().addDays(1),\n                    Priority = 'Normal'\n                );\n                tasksToCreate.add(followup);\n            }\n        }\n\n        // ✅ Bulk operations\n        if (!oppsToUpdate.isEmpty()) {\n            update oppsToUpdate;\n        }\n        if (!tasksToCreate.isEmpty()) {\n            insert tasksToCreate;\n        }\n    }\n\n    // ✅ WHAT: External system synchronization with callouts\n    // ✅ WHY: Queueable supports callouts with Database.AllowsCallouts interface\n    private void syncWithExternalSystem() {\n        List<Opportunity> opportunities = [\n            SELECT Id, Name, Amount, StageName, CloseDate\n            FROM Opportunity\n            WHERE Id IN :opportunityIds\n        ];\n\n        for (Opportunity opp : opportunities) {\n            try {\n                // ✅ HTTP callout to external system\n                HttpRequest req = new HttpRequest();\n                req.setEndpoint('https://external-crm.com/api/opportunities');\n                req.setMethod('PUT');\n                req.setHeader('Content-Type', 'application/json');\n\n                Map<String, Object> payload = new Map<String, Object>{\n                    'salesforceId' => opp.Id,\n                    'name' => opp.Name,\n                    'amount' => opp.Amount,\n                    'stage' => opp.StageName,\n                    'closeDate' => opp.CloseDate?.format()\n                };\n\n                req.setBody(JSON.serialize(payload));\n\n                Http http = new Http();\n                HttpResponse res = http.send(req);\n\n                // ✅ Update sync status based on response\n                opp.External_Sync_Status__c = res.getStatusCode() == 200 ? 'Success' : 'Failed';\n                opp.Last_Sync_Date__c = System.now();\n\n            } catch (Exception e) {\n                opp.External_Sync_Status__c = 'Failed';\n                opp.Sync_Error__c = e.getMessage();\n            }\n        }\n\n        // ✅ Update all opportunities with sync results\n        update opportunities;\n    }\n\n    // ✅ WHAT: Complex calculations that need async processing\n    private void performComplexCalculations() {\n        Decimal complexityFactor = (Decimal) parameters.get('complexityFactor');\n        Boolean includeHistoricalData = (Boolean) parameters.get('includeHistoricalData');\n\n        List<Opportunity> opportunities = [\n            SELECT Id, Name, Amount, Probability, CreatedDate,\n                   (SELECT Id, Amount FROM OpportunityLineItems)\n            FROM Opportunity\n            WHERE Id IN :opportunityIds\n        ];\n\n        List<Opportunity> oppsToUpdate = new List<Opportunity>();\n\n        for (Opportunity opp : opportunities) {\n            // ✅ Complex scoring algorithm\n            Decimal baseScore = opp.Amount * opp.Probability / 100;\n            Decimal timeFactorWeeks = (System.today().daysBetween(opp.CreatedDate)) / 7.0;\n            Decimal complexityScore = baseScore * complexityFactor * Math.log(timeFactorWeeks + 1);\n\n            // ✅ Calculate product diversity score\n            Decimal diversityScore = calculateProductDiversityScore(opp.OpportunityLineItems);\n\n            opp.Calculated_Score__c = complexityScore + diversityScore;\n            opp.Score_Calculation_Date__c = System.now();\n            oppsToUpdate.add(opp);\n        }\n\n        if (!oppsToUpdate.isEmpty()) {\n            update oppsToUpdate;\n        }\n    }\n\n    // ✅ WHAT: Job chaining - start next queueable job\n    // ✅ WHY: Process data in sequential steps, each with fresh governor limits\n    private void processAndChainNext(System.QueueableContext context) {\n        // ✅ Process current batch\n        processStageAutomation();\n\n        // ✅ Check if more records need processing\n        List<Id> nextBatch = getNextBatchToProcess();\n\n        if (!nextBatch.isEmpty() && Limits.getQueueableJobs() < Limits.getLimitQueueableJobs()) {\n            // ✅ WHAT: Chain next queueable job\n            // ✅ WHY: Continue processing with fresh governor limits\n            OpportunityProcessingJob nextJob = new OpportunityProcessingJob(\n                nextBatch,\n                'STAGE_AUTOMATION',\n                parameters\n            );\n\n            System.enqueueJob(nextJob);\n            System.debug('Chained next job for ' + nextBatch.size() + ' records');\n        }\n    }\n\n    // ✅ WHAT: Helper methods for business logic\n    private String calculateOptimalStage(Opportunity opp) {\n        // ✅ Simplified stage optimization logic\n        if (opp.Amount > 100000 && opp.Account.Type == 'Customer') {\n            return 'Negotiation/Review';\n        } else if (opp.Amount > 50000) {\n            return 'Proposal/Price Quote';\n        } else {\n            return 'Qualification';\n        }\n    }\n\n    private Decimal calculateProductDiversityScore(List<OpportunityLineItem> products) {\n        // ✅ Simple diversity calculation\n        return products.size() * 10.0; // More products = higher diversity score\n    }\n\n    private List<Id> getNextBatchToProcess() {\n        // ✅ Query for next batch of opportunities needing processing\n        List<Opportunity> nextOpps = [\n            SELECT Id\n            FROM Opportunity\n            WHERE Needs_Processing__c = true\n            AND Id NOT IN :opportunityIds\n            LIMIT 100\n        ];\n\n        List<Id> nextIds = new List<Id>();\n        for (Opportunity opp : nextOpps) {\n            nextIds.add(opp.Id);\n        }\n\n        return nextIds;\n    }\n\n    private void handleJobError(Exception e, System.QueueableContext context) {\n        // ✅ Error logging and notification\n        System.debug('Queueable job failed: ' + e.getMessage());\n        System.debug('Stack trace: ' + e.getStackTraceString());\n\n        // ✅ Could create error records, send emails, etc.\n        // Error_Log__c errorLog = new Error_Log__c(\n        //     Job_Id__c = context.getJobId(),\n        //     Error_Message__c = e.getMessage(),\n        //     Stack_Trace__c = e.getStackTraceString()\n        // );\n        // insert errorLog;\n    }\n}\n\n// ✅ WHAT: Utility class for starting queueable jobs\npublic class QueueableJobManager {\n\n    public static Id startOpportunityProcessing(List<Id> oppIds, String processType) {\n        OpportunityProcessingJob job = new OpportunityProcessingJob(oppIds, processType, null);\n        return System.enqueueJob(job);\n    }\n\n    public static Id startComplexCalculation(List<Id> oppIds, Decimal complexityFactor) {\n        Map<String, Object> params = new Map<String, Object>{\n            'complexityFactor' => complexityFactor,\n            'includeHistoricalData' => true\n        };\n\n        OpportunityProcessingJob job = new OpportunityProcessingJob(oppIds, 'COMPLEX_CALCULATION', params);\n        return System.enqueueJob(job);\n    }\n\n    // ✅ WHAT: Monitor queueable job status\n    public static void checkQueueableStatus(Id jobId) {\n        AsyncApexJob job = [\n            SELECT Id, Status, JobType, NumberOfErrors,\n                   CreatedDate, CompletedDate, ExtendedStatus\n            FROM AsyncApexJob\n            WHERE Id = :jobId\n        ];\n\n        System.debug('Queueable Job Status: ' + job.Status);\n        System.debug('Extended Status: ' + job.ExtendedStatus);\n        System.debug('Errors: ' + job.NumberOfErrors);\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Queueable accepts complex parameters unlike future methods. Implement Database.AllowsCallouts for HTTP requests",type:"info",icon:"\uD83D\uDD17"},{arrows:"         ↑",explanation:"Queueable gets higher limits than synchronous code and can make callouts like future methods",type:"success",icon:"⚡"},{arrows:"              ↑",explanation:"Job chaining allows processing large datasets by starting new jobs with fresh governor limits",type:"warning",icon:"\uD83D\uDD17"},{arrows:"                   ↑",explanation:"Always implement proper error handling and logging in async jobs for debugging and monitoring",type:"info",icon:"\uD83D\uDEE1️"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Scheduled Apex - Time-Based Processing"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Scheduled Apex runs your code at specific times. Perfect for daily reports, cleanup jobs, and regular maintenance:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Schedulable class implementing System.Schedulable interface\n// ✅ WHY: Allows code to run at scheduled times automatically\npublic class DailyMaintenanceScheduler implements System.Schedulable {\n\n    private String jobType;\n\n    public DailyMaintenanceScheduler(String jobType) {\n        this.jobType = jobType;\n    }\n\n    // ✅ WHAT: execute() method called by scheduler\n    // ✅ WHY: Entry point for scheduled job execution\n    public void execute(System.SchedulableContext context) {\n        System.debug('Running scheduled job: ' + jobType);\n\n        try {\n            switch on jobType {\n                when 'DAILY_CLEANUP' {\n                    runDailyCleanup();\n                }\n                when 'WEEKLY_REPORTS' {\n                    runWeeklyReports();\n                }\n                when 'MONTHLY_ARCHIVAL' {\n                    runMonthlyArchival();\n                }\n            }\n        } catch (Exception e) {\n            System.debug('Scheduled job error: ' + e.getMessage());\n            notifyAdminsOfError(e, context);\n        }\n    }\n\n    // ✅ WHAT: Daily cleanup routine\n    private void runDailyCleanup() {\n        System.debug('Starting daily cleanup tasks');\n\n        // ✅ Start batch job for inactive record cleanup\n        Id batchJobId = Database.executeBatch(\n            new AccountCleanupBatch('INACTIVE_CLEANUP', System.today().addDays(-90)),\n            100\n        );\n\n        // ✅ Start queueable job for expired data cleanup\n        List<Id> expiredRecordIds = getExpiredRecordIds();\n        if (!expiredRecordIds.isEmpty()) {\n            ExpiredDataCleanupJob cleanupJob = new ExpiredDataCleanupJob(expiredRecordIds);\n            System.enqueueJob(cleanupJob);\n        }\n\n        // ✅ Clean up temporary files and logs\n        cleanupTemporaryData();\n    }\n\n    private void runWeeklyReports() {\n        System.debug('Generating weekly reports');\n\n        // ✅ Start batch job for report generation\n        WeeklyReportBatch reportBatch = new WeeklyReportBatch(System.today().addDays(-7));\n        Database.executeBatch(reportBatch, 50);\n    }\n\n    private void runMonthlyArchival() {\n        System.debug('Starting monthly archival');\n\n        // ✅ Archive old records to external storage\n        MonthlyArchivalJob archivalJob = new MonthlyArchivalJob();\n        System.enqueueJob(archivalJob);\n    }\n\n    private List<Id> getExpiredRecordIds() {\n        List<Custom_Log__c> expiredLogs = [\n            SELECT Id\n            FROM Custom_Log__c\n            WHERE CreatedDate < LAST_N_DAYS:30\n            LIMIT 10000\n        ];\n\n        List<Id> expiredIds = new List<Id>();\n        for (Custom_Log__c log : expiredLogs) {\n            expiredIds.add(log.Id);\n        }\n\n        return expiredIds;\n    }\n\n    private void cleanupTemporaryData() {\n        // ✅ Delete temporary records\n        List<Temporary_Data__c> tempRecords = [\n            SELECT Id\n            FROM Temporary_Data__c\n            WHERE CreatedDate < YESTERDAY\n        ];\n\n        if (!tempRecords.isEmpty()) {\n            delete tempRecords;\n            System.debug('Deleted ' + tempRecords.size() + ' temporary records');\n        }\n    }\n\n    private void notifyAdminsOfError(Exception e, System.SchedulableContext context) {\n        Messaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\n        // ✅ Get admin emails from custom setting or metadata\n        List<String> adminEmails = new List<String>{ UserInfo.getUserEmail() };\n\n        email.setToAddresses(adminEmails);\n        email.setSubject('Scheduled Job Failed: ' + jobType);\n\n        String body = 'Scheduled job failed with the following error:\\n\\n' +\n                     'Job Type: ' + jobType + '\\n' +\n                     'Job ID: ' + context.getTriggerId() + '\\n' +\n                     'Error: ' + e.getMessage() + '\\n' +\n                     'Stack Trace: ' + e.getStackTraceString() + '\\n\\n' +\n                     'Please investigate and resolve the issue.';\n\n        email.setPlainTextBody(body);\n\n        try {\n            Messaging.sendEmail(new Messaging.SingleEmailMessage[] { email });\n        } catch (Exception emailError) {\n            System.debug('Failed to send error notification: ' + emailError.getMessage());\n        }\n    }\n}\n\n// ✅ WHAT: Utility class for managing scheduled jobs\npublic class ScheduledJobManager {\n\n    // ✅ WHAT: Schedule daily cleanup job\n    public static String scheduleDailyCleanup() {\n        DailyMaintenanceScheduler scheduler = new DailyMaintenanceScheduler('DAILY_CLEANUP');\n\n        // ✅ WHAT: Cron expression for daily execution at 2 AM\n        // ✅ WHY: Runs during low-usage hours to minimize impact\n        String cronExpression = '0 0 2 * * ?'; // Every day at 2:00 AM\n\n        return System.schedule('Daily Cleanup Job', cronExpression, scheduler);\n    }\n\n    // ✅ WHAT: Schedule weekly reports\n    public static String scheduleWeeklyReports() {\n        DailyMaintenanceScheduler scheduler = new DailyMaintenanceScheduler('WEEKLY_REPORTS');\n\n        // ✅ WHAT: Cron expression for weekly execution on Sunday at 6 AM\n        String cronExpression = '0 0 6 ? * SUN'; // Every Sunday at 6:00 AM\n\n        return System.schedule('Weekly Reports Job', cronExpression, scheduler);\n    }\n\n    // ✅ WHAT: Schedule monthly archival\n    public static String scheduleMonthlyArchival() {\n        DailyMaintenanceScheduler scheduler = new DailyMaintenanceScheduler('MONTHLY_ARCHIVAL');\n\n        // ✅ WHAT: Cron expression for monthly execution on 1st day at 3 AM\n        String cronExpression = '0 0 3 1 * ?'; // 1st day of every month at 3:00 AM\n\n        return System.schedule('Monthly Archival Job', cronExpression, scheduler);\n    }\n\n    // ✅ WHAT: Check status of scheduled jobs\n    public static void checkScheduledJobs() {\n        List<CronTrigger> scheduledJobs = [\n            SELECT Id, CronJobDetail.Name, State, NextFireTime, PreviousFireTime\n            FROM CronTrigger\n            WHERE CronJobDetail.Name LIKE '%Cleanup%'\n            OR CronJobDetail.Name LIKE '%Reports%'\n            OR CronJobDetail.Name LIKE '%Archival%'\n        ];\n\n        System.debug('Found ' + scheduledJobs.size() + ' scheduled jobs:');\n\n        for (CronTrigger job : scheduledJobs) {\n            System.debug('Job: ' + job.CronJobDetail.Name);\n            System.debug('State: ' + job.State);\n            System.debug('Next Fire Time: ' + job.NextFireTime);\n            System.debug('Previous Fire Time: ' + job.PreviousFireTime);\n            System.debug('---');\n        }\n    }\n\n    // ✅ WHAT: Cancel all scheduled jobs\n    public static void cancelAllScheduledJobs() {\n        List<CronTrigger> jobsToCancel = [\n            SELECT Id\n            FROM CronTrigger\n            WHERE CronJobDetail.Name LIKE '%Cleanup%'\n            OR CronJobDetail.Name LIKE '%Reports%'\n            OR CronJobDetail.Name LIKE '%Archival%'\n        ];\n\n        for (CronTrigger job : jobsToCancel) {\n            System.abortJob(job.Id);\n        }\n\n        System.debug('Cancelled ' + jobsToCancel.size() + ' scheduled jobs');\n    }\n\n    // ✅ WHAT: Utility method to parse cron expressions\n    public static void explainCronExpression(String cronExpr) {\n        List<String> parts = cronExpr.split(' ');\n\n        if (parts.size() != 6) {\n            System.debug('Invalid cron expression');\n            return;\n        }\n\n        System.debug('Cron Expression Breakdown:');\n        System.debug('Seconds: ' + parts[0]);\n        System.debug('Minutes: ' + parts[1]);\n        System.debug('Hours: ' + parts[2]);\n        System.debug('Day of Month: ' + parts[3]);\n        System.debug('Month: ' + parts[4]);\n        System.debug('Day of Week: ' + parts[5]);\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Schedulable classes run at specific times using cron expressions. Perfect for regular maintenance tasks",type:"info",icon:"⏰"},{arrows:"         ↑",explanation:"Scheduled jobs can start other async jobs (batch, queueable) to handle large data processing",type:"success",icon:"\uD83D\uDD17"},{arrows:"              ↑",explanation:"Always implement error handling and admin notification in scheduled jobs for monitoring",type:"warning",icon:"\uD83D\uDEA8"},{arrows:"                   ↑",explanation:"Use System.schedule() with cron expressions to schedule jobs. Monitor with CronTrigger object",type:"info",icon:"⚙️"}]})]}),(0,s.jsxs)("section",{className:"bg-purple-50 dark:bg-purple-900/20 rounded-lg p-6",children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-purple-900 dark:text-purple-100 mb-3",children:"\uD83D\uDE80 Async Apex Best Practices"}),(0,s.jsxs)("ul",{className:"space-y-2 text-purple-800 dark:text-purple-200",children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Choose the Right Tool:"})," Future for simple callouts, Batch for large datasets, Queueable for complex chaining"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Error Handling:"})," Always implement try-catch blocks and logging in async methods"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Governor Limits:"})," Monitor async job limits (250 queued/running jobs, 5 queued queueable jobs)"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Job Monitoring:"})," Query AsyncApexJob to track job status and handle failures"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Data Consistency:"})," Use Database.* methods with allOrNone=false for partial success patterns"]})]})]})]})},{id:"testing",title:"Testing",icon:g.Z,description:"Unit testing and test data management",content:(0,s.jsxs)("div",{className:"space-y-8",children:[(0,s.jsx)("div",{children:(0,s.jsxs)("p",{className:"text-lg text-gray-700 dark:text-gray-300 mb-6",children:[(0,s.jsx)("strong",{children:"Your code needs validation and confidence."})," Testing ensures your Apex logic works correctly, handles edge cases, and maintains quality through changes. Master test-driven development, data factories, and testing patterns to build robust Salesforce applications."]})}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Test Class Fundamentals"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Every Apex class should have comprehensive tests. Test classes validate your logic and are required for deployment:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Test class annotation\n// ✅ WHY: @IsTest marks class as test-only, excluded from code coverage requirements\n// \uD83D\uDCA5 IF WRONG: Regular classes need 75% coverage, test classes don't count toward limits\n@IsTest\npublic class AccountProcessorTest {\n\n    // ✅ WHAT: Test setup method runs before each test\n    // ✅ WHY: @TestSetup creates test data once for all test methods in class\n    // \uD83D\uDCA5 IF WRONG: Creating data in each test method is slower and hits DML limits\n    @TestSetup\n    static void setupTestData() {\n        // ✅ Create test accounts for multiple test scenarios\n        List<Account> testAccounts = new List<Account>();\n\n        // Account for positive test cases\n        testAccounts.add(new Account(\n            Name = 'Test Customer Account',\n            Type = 'Customer',\n            Industry = 'Technology',\n            AnnualRevenue = 1000000,\n            NumberOfEmployees = 500\n        ));\n\n        // Account for edge case testing\n        testAccounts.add(new Account(\n            Name = 'Test Prospect Account',\n            Type = 'Prospect',\n            Industry = 'Healthcare',\n            AnnualRevenue = 50000,\n            NumberOfEmployees = 10\n        ));\n\n        // Account with minimal data\n        testAccounts.add(new Account(\n            Name = 'Minimal Account'\n            // No type, industry, or revenue\n        ));\n\n        insert testAccounts;\n    }\n\n    // ✅ WHAT: Positive test case - test expected behavior\n    // ✅ WHY: Validates that your code works correctly with valid inputs\n    @IsTest\n    static void testProcessAccountsPositive() {\n        // ✅ WHAT: Test data retrieval\n        // ✅ WHY: Get data created in @TestSetup method\n        List<Account> testAccounts = [SELECT Id, Name, Type FROM Account];\n\n        // ✅ WHAT: Test context setup\n        Test.startTest(); // ✅ Resets governor limits for the test\n\n        // ✅ Execute the method being tested\n        AccountProcessor processor = new AccountProcessor('Test Processor', 100);\n        processor.processAccounts(testAccounts);\n\n        Test.stopTest(); // ✅ Forces async code to complete\n\n        // ✅ WHAT: Assertions to verify expected behavior\n        // ✅ WHY: Validates that processing worked correctly\n        List<Account> processedAccounts = [\n            SELECT Id, Name, Description\n            FROM Account\n            WHERE Description LIKE '%Processed by%'\n        ];\n\n        // ✅ Verify all accounts were processed\n        System.assertEquals(3, processedAccounts.size(),\n            'All three test accounts should have been processed');\n\n        // ✅ Verify specific account was updated correctly\n        Account customerAccount = [\n            SELECT Description\n            FROM Account\n            WHERE Name = 'Test Customer Account'\n            LIMIT 1\n        ];\n\n        System.assertEquals('Processed by Test Processor', customerAccount.Description,\n            'Customer account should have correct description');\n    }\n\n    // ✅ WHAT: Negative test case - test error handling\n    // ✅ WHY: Validates that your code handles invalid inputs gracefully\n    @IsTest\n    static void testProcessAccountsWithInvalidProcessor() {\n        List<Account> testAccounts = [SELECT Id FROM Account LIMIT 1];\n\n        Test.startTest();\n\n        try {\n            // ✅ WHAT: Test invalid input scenario\n            // ✅ WHY: Ensure constructor validation works\n            AccountProcessor processor = new AccountProcessor('', 100); // Empty name\n            processor.processAccounts(testAccounts);\n\n            // ✅ If we reach this line, the test should fail\n            System.assert(false, 'Expected IllegalArgumentException was not thrown');\n\n        } catch (IllegalArgumentException e) {\n            // ✅ WHAT: Verify expected exception was thrown\n            // ✅ WHY: Confirms error handling works correctly\n            System.assertEquals('Processor name cannot be blank', e.getMessage(),\n                'Exception message should match expected error');\n        }\n\n        Test.stopTest();\n    }\n\n    // ✅ WHAT: Bulk testing - test with large datasets\n    // ✅ WHY: Validates bulkification and governor limit compliance\n    @IsTest\n    static void testProcessAccountsBulk() {\n        // ✅ Create larger dataset for bulk testing\n        List<Account> bulkAccounts = new List<Account>();\n\n        for (Integer i = 0; i < 200; i++) {\n            bulkAccounts.add(new Account(\n                Name = 'Bulk Account ' + i,\n                Type = 'Customer'\n            ));\n        }\n\n        insert bulkAccounts;\n\n        Test.startTest();\n\n        // ✅ Test bulk processing\n        AccountProcessor processor = new AccountProcessor('Bulk Processor', 150);\n        processor.processAccounts(bulkAccounts);\n\n        Test.stopTest();\n\n        // ✅ Verify only the limited number were processed\n        List<Account> processedAccounts = [\n            SELECT Id FROM Account\n            WHERE Description = 'Processed by Bulk Processor'\n        ];\n\n        System.assertEquals(150, processedAccounts.size(),\n            'Should only process up to the maximum limit of 150 accounts');\n    }\n\n    // ✅ WHAT: Test static methods\n    // ✅ WHY: Static utility methods need testing too\n    @IsTest\n    static void testStaticMethods() {\n        Test.startTest();\n\n        // ✅ Test static method functionality\n        Integer totalProcessors = AccountProcessor.getTotalProcessorsCreated();\n        System.assertEquals(0, totalProcessors, 'Initial count should be zero');\n\n        // ✅ Create processor to increment counter\n        AccountProcessor processor1 = new AccountProcessor();\n        totalProcessors = AccountProcessor.getTotalProcessorsCreated();\n        System.assertEquals(1, totalProcessors, 'Count should increment to 1');\n\n        // ✅ Test factory method\n        AccountProcessor bulkProcessor = AccountProcessor.createHighVolumeProcessor('Test Bulk');\n        System.assertEquals('Test Bulk', bulkProcessor.getProcessorName(),\n            'Factory method should set processor name correctly');\n\n        Test.stopTest();\n    }\n\n    // ✅ WHAT: Test private methods indirectly\n    // ✅ WHY: Private methods are tested through public method calls\n    @IsTest\n    static void testPrivateMethodsIndirectly() {\n        Test.startTest();\n\n        // ✅ Test private validation by triggering it through public methods\n        AccountProcessor processor = new AccountProcessor();\n\n        try {\n            processor.setProcessorName(null); // Should trigger validation\n            System.assert(false, 'Expected exception for null name');\n        } catch (IllegalArgumentException e) {\n            System.assert(e.getMessage().contains('cannot be blank'),\n                'Should validate empty processor name');\n        }\n\n        Test.stopTest();\n    }\n}",annotations:[{arrows:"    ↑",explanation:"@IsTest annotation marks test classes and methods. @TestSetup creates shared test data efficiently",type:"info",icon:"\uD83E\uDDEA"},{arrows:"         ↑",explanation:"Test.startTest() and Test.stopTest() reset governor limits and force async code completion",type:"success",icon:"⏱️"},{arrows:"              ↑",explanation:"Use System.assertEquals() and System.assert() to validate expected behavior and results",type:"warning",icon:"✅"},{arrows:"                   ↑",explanation:"Test both positive scenarios (expected behavior) and negative scenarios (error handling)",type:"info",icon:"\uD83C\uDFAF"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Test Data Factories and Patterns"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Reusable test data factories make tests maintainable and reduce duplication:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Test data factory utility class\n// ✅ WHY: Centralized test data creation reduces duplication and improves maintainability\n// \uD83D\uDCA5 IF WRONG: Duplicating test data creation in every test leads to maintenance issues\n@IsTest\npublic class TestDataFactory {\n\n    // ✅ WHAT: Account creation with default values\n    // ✅ WHY: Provides sensible defaults while allowing customization\n    public static Account createAccount(String name, String accountType) {\n        return new Account(\n            Name = name,\n            Type = accountType,\n            Industry = 'Technology',\n            AnnualRevenue = 500000,\n            NumberOfEmployees = 100,\n            BillingCity = 'San Francisco',\n            BillingState = 'CA',\n            BillingCountry = 'USA'\n        );\n    }\n\n    // ✅ WHAT: Overloaded method with fewer parameters\n    // ✅ WHY: Convenience method for common use cases\n    public static Account createAccount(String name) {\n        return createAccount(name, 'Customer');\n    }\n\n    // ✅ WHAT: Bulk account creation\n    // ✅ WHY: Efficient creation of multiple test records\n    public static List<Account> createAccounts(Integer count, String namePrefix, String accountType) {\n        List<Account> accounts = new List<Account>();\n\n        for (Integer i = 0; i < count; i++) {\n            accounts.add(createAccount(namePrefix + ' ' + i, accountType));\n        }\n\n        return accounts;\n    }\n\n    // ✅ WHAT: Contact creation with account relationship\n    // ✅ WHY: Creates related data to test relationship scenarios\n    public static Contact createContact(String firstName, String lastName, Id accountId) {\n        return new Contact(\n            FirstName = firstName,\n            LastName = lastName,\n            AccountId = accountId,\n            Email = firstName.toLowerCase() + '.' + lastName.toLowerCase() + '@test.com',\n            Phone = '(555) 123-4567',\n            Title = 'Test Contact',\n            Department = 'Sales'\n        );\n    }\n\n    // ✅ WHAT: Opportunity creation with required fields\n    public static Opportunity createOpportunity(String name, Id accountId, Date closeDate) {\n        return new Opportunity(\n            Name = name,\n            AccountId = accountId,\n            StageName = 'Qualification',\n            CloseDate = closeDate,\n            Amount = 100000,\n            Probability = 25,\n            Type = 'New Customer',\n            LeadSource = 'Web'\n        );\n    }\n\n    // ✅ WHAT: Complete data scenario creation\n    // ✅ WHY: Creates full object hierarchies for complex testing\n    public static Map<String, List<SObject>> createCompleteTestScenario() {\n        Map<String, List<SObject>> testData = new Map<String, List<SObject>>();\n\n        // ✅ Create accounts\n        List<Account> accounts = createAccounts(3, 'Test Account', 'Customer');\n        insert accounts;\n        testData.put('accounts', accounts);\n\n        // ✅ Create contacts for each account\n        List<Contact> contacts = new List<Contact>();\n        for (Account acc : accounts) {\n            contacts.add(createContact('John', 'Doe ' + acc.Name, acc.Id));\n            contacts.add(createContact('Jane', 'Smith ' + acc.Name, acc.Id));\n        }\n        insert contacts;\n        testData.put('contacts', contacts);\n\n        // ✅ Create opportunities for each account\n        List<Opportunity> opportunities = new List<Opportunity>();\n        for (Account acc : accounts) {\n            opportunities.add(createOpportunity('Opp for ' + acc.Name, acc.Id, System.today().addDays(30)));\n        }\n        insert opportunities;\n        testData.put('opportunities', opportunities);\n\n        return testData;\n    }\n\n    // ✅ WHAT: User creation for testing different profiles\n    // ✅ WHY: Testing with different user contexts validates security and permissions\n    public static User createTestUser(String profileName, String uniqueSuffix) {\n        Profile testProfile = [SELECT Id FROM Profile WHERE Name = :profileName LIMIT 1];\n\n        return new User(\n            FirstName = 'Test',\n            LastName = 'User ' + uniqueSuffix,\n            Email = 'testuser' + uniqueSuffix + '@test.com',\n            Username = 'testuser' + uniqueSuffix + '@testcompany.com',\n            Alias = 'tuser' + uniqueSuffix.left(4),\n            ProfileId = testProfile.Id,\n            TimeZoneSidKey = 'America/Los_Angeles',\n            LocaleSidKey = 'en_US',\n            EmailEncodingKey = 'UTF-8',\n            LanguageLocaleKey = 'en_US'\n        );\n    }\n\n    // ✅ WHAT: Custom setting creation for test isolation\n    // ✅ WHY: Tests should not depend on org-specific configuration\n    public static void createTestSettings() {\n        // Example custom setting creation\n        // Test_Settings__c settings = new Test_Settings__c(\n        //     Name = 'Test Config',\n        //     Max_Records__c = 100,\n        //     Enable_Feature__c = true\n        // );\n        // insert settings;\n    }\n}\n\n// ✅ WHAT: Test class using data factory\n@IsTest\npublic class ContactManagerTest {\n\n    @TestSetup\n    static void setupTestData() {\n        // ✅ Use factory to create consistent test data\n        TestDataFactory.createCompleteTestScenario();\n        TestDataFactory.createTestSettings();\n    }\n\n    @IsTest\n    static void testContactValidation() {\n        // ✅ Get test data created by factory\n        List<Account> accounts = [SELECT Id, Type FROM Account];\n        Account testAccount = accounts[0];\n\n        Test.startTest();\n\n        // ✅ Test valid contact creation\n        ContactManager manager = new ContactManager('Test Manager', new Set<String>{'test.com'});\n        List<Contact> validContacts = new List<Contact>{\n            TestDataFactory.createContact('Valid', 'Contact', testAccount.Id)\n        };\n\n        List<Contact> results = manager.processIncomingContacts(validContacts);\n        System.assertEquals(1, results.size(), 'Valid contact should be processed');\n\n        Test.stopTest();\n    }\n\n    @IsTest\n    static void testContactValidationWithDifferentAccountTypes() {\n        // ✅ Test with different account types from factory\n        List<Account> accounts = [SELECT Id, Type FROM Account];\n\n        Test.startTest();\n\n        for (Account acc : accounts) {\n            // ✅ Create specific test scenario for each account type\n            ContactManager manager = new ContactManager('Manager for ' + acc.Type, new Set<String>());\n\n            Contact testContact = TestDataFactory.createContact('Test', 'Contact', acc.Id);\n            List<Contact> results = manager.processIncomingContacts(new List<Contact>{ testContact });\n\n            // ✅ Assertions based on account type\n            if (acc.Type == 'Customer') {\n                System.assertEquals(1, results.size(), 'Customer accounts should allow contacts');\n            }\n        }\n\n        Test.stopTest();\n    }\n\n    // ✅ WHAT: Test with different user contexts\n    @IsTest\n    static void testContactProcessingAsStandardUser() {\n        // ✅ Create test user with standard profile\n        User standardUser = TestDataFactory.createTestUser('Standard User', 'STD001');\n        insert standardUser;\n\n        System.runAs(standardUser) {\n            Test.startTest();\n\n            // ✅ Test functionality with different user permissions\n            List<Account> accounts = [SELECT Id FROM Account LIMIT 1];\n            ContactManager manager = new ContactManager('Standard User Manager', new Set<String>());\n\n            Contact testContact = TestDataFactory.createContact('Standard', 'User Test', accounts[0].Id);\n            List<Contact> results = manager.processIncomingContacts(new List<Contact>{ testContact });\n\n            // ✅ Verify behavior under standard user context\n            System.assertNotEquals(null, results, 'Standard user should be able to process contacts');\n\n            Test.stopTest();\n        }\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Test data factories centralize object creation with sensible defaults and customization options",type:"info",icon:"\uD83C\uDFED"},{arrows:"         ↑",explanation:"Factories can create complete object hierarchies and relationships for complex testing scenarios",type:"success",icon:"\uD83D\uDD17"},{arrows:"              ↑",explanation:"Test different user contexts with System.runAs() to validate security and permission handling",type:"warning",icon:"\uD83D\uDC64"},{arrows:"                   ↑",explanation:"Use factories in @TestSetup to create reusable test data that's available to all test methods",type:"info",icon:"⚙️"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Testing Async Apex and Advanced Scenarios"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"Testing asynchronous code, triggers, and external integrations requires special techniques:"}),(0,s.jsx)(f,{code:"@IsTest\npublic class AsyncApexTest {\n\n    // ✅ WHAT: Testing future methods\n    // ✅ WHY: Future methods execute asynchronously, need Test.stopTest() to complete\n    @IsTest\n    static void testFutureMethod() {\n        // ✅ Create test data\n        List<Account> testAccounts = new List<Account>{\n            TestDataFactory.createAccount('Future Test Account')\n        };\n        insert testAccounts;\n\n        Set<Id> accountIds = new Set<Id>();\n        for (Account acc : testAccounts) {\n            accountIds.add(acc.Id);\n        }\n\n        Test.startTest();\n\n        // ✅ WHAT: Call future method\n        // ✅ WHY: Future method will be queued but not executed until Test.stopTest()\n        ExternalIntegrationService.syncAccountToExternalSystem(accountIds);\n\n        // ✅ WHAT: Test.stopTest() forces future method to complete\n        // ✅ WHY: Without this, future method wouldn't execute in test context\n        Test.stopTest();\n\n        // ✅ Verify future method results\n        List<Account> syncedAccounts = [\n            SELECT Id, External_Sync_Status__c\n            FROM Account\n            WHERE Id IN :accountIds\n        ];\n\n        System.assertEquals(1, syncedAccounts.size(), 'Should have one synced account');\n        // Note: In test context, external callouts are mocked\n    }\n\n    // ✅ WHAT: Testing batch Apex\n    // ✅ WHY: Batch classes need special testing to verify all phases\n    @IsTest\n    static void testBatchApex() {\n        // ✅ Create test data for batch processing\n        List<Account> testAccounts = TestDataFactory.createAccounts(50, 'Batch Test', 'Customer');\n\n        // Set up accounts for cleanup scenario\n        for (Account acc : testAccounts) {\n            acc.Active__c = true;\n            acc.LastActivityDate = System.today().addDays(-100); // Old activity\n        }\n        insert testAccounts;\n\n        Test.startTest();\n\n        // ✅ WHAT: Execute batch job\n        // ✅ WHY: Test.stopTest() will complete all batch chunks\n        AccountCleanupBatch batch = new AccountCleanupBatch('INACTIVE_CLEANUP', System.today().addDays(-90));\n        Id jobId = Database.executeBatch(batch, 10); // Small batch size for testing\n\n        Test.stopTest();\n\n        // ✅ Verify batch processing results\n        List<Account> processedAccounts = [\n            SELECT Id, Active__c, Deactivation_Date__c\n            FROM Account\n            WHERE Id IN :testAccounts\n        ];\n\n        Integer deactivatedCount = 0;\n        for (Account acc : processedAccounts) {\n            if (!acc.Active__c) {\n                deactivatedCount++;\n                System.assertNotEquals(null, acc.Deactivation_Date__c,\n                    'Deactivated accounts should have deactivation date');\n            }\n        }\n\n        System.assertEquals(50, deactivatedCount, 'All test accounts should be deactivated');\n\n        // ✅ Verify batch job completion\n        AsyncApexJob job = [\n            SELECT Status, NumberOfErrors\n            FROM AsyncApexJob\n            WHERE Id = :jobId\n        ];\n\n        System.assertEquals('Completed', job.Status, 'Batch job should complete successfully');\n        System.assertEquals(0, job.NumberOfErrors, 'Batch job should have no errors');\n    }\n\n    // ✅ WHAT: Testing queueable Apex\n    @IsTest\n    static void testQueueableApex() {\n        // ✅ Create opportunities for processing\n        Map<String, List<SObject>> testData = TestDataFactory.createCompleteTestScenario();\n        List<Opportunity> opportunities = (List<Opportunity>) testData.get('opportunities');\n\n        List<Id> oppIds = new List<Id>();\n        for (Opportunity opp : opportunities) {\n            oppIds.add(opp.Id);\n        }\n\n        Test.startTest();\n\n        // ✅ WHAT: Enqueue queueable job\n        OpportunityProcessingJob job = new OpportunityProcessingJob(oppIds, 'STAGE_AUTOMATION', null);\n        Id jobId = System.enqueueJob(job);\n\n        Test.stopTest();\n\n        // ✅ Verify queueable processing results\n        List<Opportunity> processedOpps = [\n            SELECT Id, StageName, Stage_Change_Reason__c\n            FROM Opportunity\n            WHERE Id IN :oppIds\n        ];\n\n        for (Opportunity opp : processedOpps) {\n            System.assertNotEquals(null, opp.StageName, 'Opportunity should have stage');\n        }\n\n        // ✅ Verify job completion\n        AsyncApexJob queueJob = [\n            SELECT Status FROM AsyncApexJob WHERE Id = :jobId\n        ];\n        System.assertEquals('Completed', queueJob.Status, 'Queueable job should complete');\n    }\n\n    // ✅ WHAT: Testing schedulable Apex\n    @IsTest\n    static void testSchedulableApex() {\n        Test.startTest();\n\n        // ✅ WHAT: Schedule the job for immediate execution in test\n        // ✅ WHY: Tests run immediately, don't wait for actual schedule\n        String cronExpression = '0 0 2 * * ?';\n        DailyMaintenanceScheduler scheduler = new DailyMaintenanceScheduler('DAILY_CLEANUP');\n        String jobId = System.schedule('Test Daily Cleanup', cronExpression, scheduler);\n\n        Test.stopTest();\n\n        // ✅ Verify scheduled job was created\n        List<CronTrigger> scheduledJobs = [\n            SELECT Id, CronJobDetail.Name, State\n            FROM CronTrigger\n            WHERE Id = :jobId\n        ];\n\n        System.assertEquals(1, scheduledJobs.size(), 'Scheduled job should be created');\n        System.assertEquals('Test Daily Cleanup', scheduledJobs[0].CronJobDetail.Name);\n    }\n\n    // ✅ WHAT: Testing trigger behavior\n    @IsTest\n    static void testTriggerBehavior() {\n        Test.startTest();\n\n        // ✅ Test insert trigger\n        Account newAccount = TestDataFactory.createAccount('Trigger Test Account');\n        insert newAccount;\n\n        // ✅ Verify trigger logic executed\n        Account insertedAccount = [\n            SELECT Id, AccountNumber, Industry\n            FROM Account\n            WHERE Id = :newAccount.Id\n        ];\n\n        System.assertNotEquals(null, insertedAccount.AccountNumber,\n            'Trigger should set account number');\n        System.assertEquals('Other', insertedAccount.Industry,\n            'Trigger should set default industry');\n\n        // ✅ Test update trigger\n        insertedAccount.Type = 'Partner';\n        update insertedAccount;\n\n        Account updatedAccount = [\n            SELECT Type_Change_History__c, Last_Significant_Update__c\n            FROM Account\n            WHERE Id = :insertedAccount.Id\n        ];\n\n        System.assertNotEquals(null, updatedAccount.Last_Significant_Update__c,\n            'Trigger should set last update timestamp');\n\n        Test.stopTest();\n    }\n\n    // ✅ WHAT: Testing with mock callouts\n    // ✅ WHY: External integrations need mocking for predictable tests\n    @IsTest\n    static void testExternalIntegrationWithMock() {\n        // ✅ Set up mock for HTTP callouts\n        Test.setMock(HttpCalloutMock.class, new MockHttpResponseGenerator());\n\n        List<Account> testAccounts = new List<Account>{\n            TestDataFactory.createAccount('Mock Test Account')\n        };\n        insert testAccounts;\n\n        Test.startTest();\n\n        // ✅ Call method that makes HTTP callout\n        Set<Id> accountIds = new Set<Id>{ testAccounts[0].Id };\n        ExternalIntegrationService.syncAccountToExternalSystem(accountIds);\n\n        Test.stopTest();\n\n        // ✅ Verify mock callout results\n        Account syncedAccount = [\n            SELECT External_Sync_Status__c\n            FROM Account\n            WHERE Id = :testAccounts[0].Id\n        ];\n\n        System.assertEquals('Synced', syncedAccount.External_Sync_Status__c,\n            'Mock should simulate successful sync');\n    }\n\n    // ✅ WHAT: Testing governor limits\n    @IsTest\n    static void testGovernorLimits() {\n        Test.startTest();\n\n        // ✅ Test SOQL limits\n        Integer soqlCount = Limits.getQueries();\n        System.assertEquals(0, soqlCount, 'Should start with 0 SOQL queries');\n\n        List<Account> accounts = [SELECT Id FROM Account LIMIT 1];\n        soqlCount = Limits.getQueries();\n        System.assertEquals(1, soqlCount, 'Should have 1 SOQL query after query');\n\n        // ✅ Test DML limits\n        Integer dmlCount = Limits.getDMLRows();\n        System.assertEquals(0, dmlCount, 'Should start with 0 DML rows');\n\n        Account testAccount = TestDataFactory.createAccount('Limit Test');\n        insert testAccount;\n\n        dmlCount = Limits.getDMLRows();\n        System.assertEquals(1, dmlCount, 'Should have 1 DML row after insert');\n\n        Test.stopTest();\n    }\n}\n\n// ✅ WHAT: Mock HTTP response for testing callouts\n// ✅ WHY: Provides predictable responses for external integration testing\n@IsTest\nglobal class MockHttpResponseGenerator implements HttpCalloutMock {\n    global HTTPResponse respond(HTTPRequest req) {\n        // ✅ Create mock response\n        HttpResponse res = new HttpResponse();\n        res.setHeader('Content-Type', 'application/json');\n        res.setBody('{\"status\": \"success\", \"id\": \"12345\"}');\n        res.setStatusCode(200);\n        return res;\n    }\n}",annotations:[{arrows:"    ↑",explanation:"Test.stopTest() forces async code (future, batch, queueable) to complete synchronously in tests",type:"info",icon:"⏹️"},{arrows:"         ↑",explanation:"Test batch Apex by creating test data, executing the batch, and verifying results after Test.stopTest()",type:"success",icon:"\uD83D\uDCE6"},{arrows:"              ↑",explanation:"Use Test.setMock() to provide predictable responses for HTTP callouts in tests",type:"warning",icon:"\uD83C\uDFAD"},{arrows:"                   ↑",explanation:"Monitor governor limits in tests using Limits class methods to verify efficient code",type:"info",icon:"\uD83D\uDCCA"}]})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-900 dark:text-white mb-4",children:"Test-Driven Development and Best Practices"}),(0,s.jsx)("p",{className:"text-gray-700 dark:text-gray-300 mb-4",children:"TDD and comprehensive testing strategies ensure code quality and maintainability:"}),(0,s.jsx)(f,{code:"// ✅ WHAT: Test-driven development example\n// ✅ WHY: Writing tests first ensures better design and coverage\n@IsTest\npublic class OpportunityScoreCalculatorTest {\n\n    // ✅ STEP 1: Write test first (this will fail initially)\n    @IsTest\n    static void testBasicScoreCalculation() {\n        // ✅ Arrange: Set up test data\n        Opportunity testOpp = new Opportunity(\n            Name = 'Test Opportunity',\n            Amount = 100000,\n            Probability = 50,\n            StageName = 'Qualification',\n            CloseDate = System.today().addDays(30)\n        );\n\n        // ✅ Act: Execute method being tested\n        Test.startTest();\n        Decimal score = OpportunityScoreCalculator.calculateScore(testOpp);\n        Test.stopTest();\n\n        // ✅ Assert: Verify expected results\n        System.assertEquals(50000, score, 'Basic score should be Amount * Probability / 100');\n    }\n\n    // ✅ STEP 2: Write more specific tests\n    @IsTest\n    static void testScoreWithTimeFactors() {\n        // ✅ Test opportunity close to closing\n        Opportunity urgentOpp = new Opportunity(\n            Name = 'Urgent Opportunity',\n            Amount = 100000,\n            Probability = 75,\n            StageName = 'Negotiation/Review',\n            CloseDate = System.today().addDays(7) // Closing soon\n        );\n\n        Test.startTest();\n        Decimal urgentScore = OpportunityScoreCalculator.calculateScore(urgentOpp);\n        Test.stopTest();\n\n        // ✅ Urgent opportunities should have higher scores\n        System.assert(urgentScore > 75000, 'Urgent opportunities should have time bonus');\n    }\n\n    @IsTest\n    static void testScoreWithStageFactors() {\n        // ✅ Test different stages\n        List<Opportunity> opportunities = new List<Opportunity>{\n            new Opportunity(\n                Name = 'Qualification Opp',\n                Amount = 100000,\n                Probability = 25,\n                StageName = 'Qualification',\n                CloseDate = System.today().addDays(30)\n            ),\n            new Opportunity(\n                Name = 'Proposal Opp',\n                Amount = 100000,\n                Probability = 50,\n                StageName = 'Proposal/Price Quote',\n                CloseDate = System.today().addDays(30)\n            ),\n            new Opportunity(\n                Name = 'Negotiation Opp',\n                Amount = 100000,\n                Probability = 75,\n                StageName = 'Negotiation/Review',\n                CloseDate = System.today().addDays(30)\n            )\n        };\n\n        Test.startTest();\n\n        Map<String, Decimal> scoresByStage = new Map<String, Decimal>();\n        for (Opportunity opp : opportunities) {\n            Decimal score = OpportunityScoreCalculator.calculateScore(opp);\n            scoresByStage.put(opp.StageName, score);\n        }\n\n        Test.stopTest();\n\n        // ✅ Later stages should have higher multipliers\n        System.assert(\n            scoresByStage.get('Proposal/Price Quote') > scoresByStage.get('Qualification'),\n            'Proposal stage should score higher than Qualification'\n        );\n        System.assert(\n            scoresByStage.get('Negotiation/Review') > scoresByStage.get('Proposal/Price Quote'),\n            'Negotiation stage should score highest'\n        );\n    }\n\n    // ✅ STEP 3: Test edge cases and error conditions\n    @IsTest\n    static void testScoreWithNullValues() {\n        Opportunity nullAmountOpp = new Opportunity(\n            Name = 'Null Amount Opp',\n            Amount = null,\n            Probability = 50,\n            StageName = 'Qualification',\n            CloseDate = System.today().addDays(30)\n        );\n\n        Test.startTest();\n        Decimal score = OpportunityScoreCalculator.calculateScore(nullAmountOpp);\n        Test.stopTest();\n\n        System.assertEquals(0, score, 'Null amount should result in zero score');\n    }\n\n    @IsTest\n    static void testScoreWithInvalidData() {\n        Opportunity invalidOpp = new Opportunity(\n            Name = 'Invalid Opp',\n            Amount = -1000, // Negative amount\n            Probability = 150, // Invalid probability\n            StageName = 'Invalid Stage',\n            CloseDate = System.today().addDays(-30) // Past date\n        );\n\n        Test.startTest();\n\n        try {\n            Decimal score = OpportunityScoreCalculator.calculateScore(invalidOpp);\n            System.assert(false, 'Should throw exception for invalid data');\n        } catch (IllegalArgumentException e) {\n            System.assert(e.getMessage().contains('Invalid opportunity data'),\n                'Should provide meaningful error message');\n        }\n\n        Test.stopTest();\n    }\n\n    // ✅ STEP 4: Test complex scenarios\n    @IsTest\n    static void testBulkScoreCalculation() {\n        // ✅ Create large dataset for performance testing\n        List<Opportunity> bulkOpportunities = new List<Opportunity>();\n\n        for (Integer i = 0; i < 200; i++) {\n            bulkOpportunities.add(new Opportunity(\n                Name = 'Bulk Opp ' + i,\n                Amount = 10000 + (i * 1000),\n                Probability = 25 + (Math.mod(i, 3) * 25),\n                StageName = 'Qualification',\n                CloseDate = System.today().addDays(30 + Math.mod(i, 60))\n            ));\n        }\n\n        Test.startTest();\n\n        List<Decimal> scores = OpportunityScoreCalculator.calculateBulkScores(bulkOpportunities);\n\n        Test.stopTest();\n\n        System.assertEquals(200, scores.size(), 'Should calculate scores for all opportunities');\n\n        // ✅ Verify no null scores\n        for (Decimal score : scores) {\n            System.assertNotEquals(null, score, 'No scores should be null');\n            System.assert(score >= 0, 'All scores should be non-negative');\n        }\n\n        // ✅ Verify governor limits weren't exceeded\n        System.assert(Limits.getCpuTime() < Limits.getLimitCpuTime(),\n            'Should not exceed CPU time limits');\n    }\n\n    // ✅ STEP 5: Integration testing\n    @IsTest\n    static void testScoreCalculationIntegration() {\n        // ✅ Create complete test scenario with related data\n        Map<String, List<SObject>> testData = TestDataFactory.createCompleteTestScenario();\n        List<Opportunity> opportunities = (List<Opportunity>) testData.get('opportunities');\n\n        // ✅ Add line items to make opportunities more complex\n        List<OpportunityLineItem> lineItems = new List<OpportunityLineItem>();\n        for (Opportunity opp : opportunities) {\n            // Note: Would need Product2 and PricebookEntry setup in real scenario\n            // lineItems.add(new OpportunityLineItem(...));\n        }\n\n        Test.startTest();\n\n        // ✅ Test score calculation with complete data\n        for (Opportunity opp : opportunities) {\n            Decimal score = OpportunityScoreCalculator.calculateScore(opp);\n            System.assertNotEquals(null, score, 'Integration test should produce valid scores');\n        }\n\n        Test.stopTest();\n    }\n}\n\n// ✅ STEP 6: Now implement the actual class to make tests pass\npublic class OpportunityScoreCalculator {\n\n    // ✅ Basic score calculation (implement to make first test pass)\n    public static Decimal calculateScore(Opportunity opp) {\n        if (opp == null) {\n            throw new IllegalArgumentException('Opportunity cannot be null');\n        }\n\n        // ✅ Validate opportunity data\n        validateOpportunity(opp);\n\n        // ✅ Handle null amount\n        if (opp.Amount == null) {\n            return 0;\n        }\n\n        // ✅ Base score calculation\n        Decimal baseScore = opp.Amount * (opp.Probability / 100);\n\n        // ✅ Apply stage multiplier\n        Decimal stageMultiplier = getStageMultiplier(opp.StageName);\n        baseScore *= stageMultiplier;\n\n        // ✅ Apply time factor\n        Decimal timeFactor = getTimeFactor(opp.CloseDate);\n        baseScore *= timeFactor;\n\n        return baseScore;\n    }\n\n    public static List<Decimal> calculateBulkScores(List<Opportunity> opportunities) {\n        List<Decimal> scores = new List<Decimal>();\n\n        for (Opportunity opp : opportunities) {\n            scores.add(calculateScore(opp));\n        }\n\n        return scores;\n    }\n\n    private static void validateOpportunity(Opportunity opp) {\n        if (opp.Amount != null && opp.Amount < 0) {\n            throw new IllegalArgumentException('Invalid opportunity data: Amount cannot be negative');\n        }\n\n        if (opp.Probability != null && (opp.Probability < 0 || opp.Probability > 100)) {\n            throw new IllegalArgumentException('Invalid opportunity data: Probability must be 0-100');\n        }\n\n        if (opp.CloseDate != null && opp.CloseDate < System.today()) {\n            throw new IllegalArgumentException('Invalid opportunity data: Close date cannot be in the past');\n        }\n    }\n\n    private static Decimal getStageMultiplier(String stageName) {\n        switch on stageName {\n            when 'Qualification' { return 1.0; }\n            when 'Needs Analysis' { return 1.1; }\n            when 'Value Proposition' { return 1.2; }\n            when 'Id. Decision Makers' { return 1.3; }\n            when 'Perception Analysis' { return 1.4; }\n            when 'Proposal/Price Quote' { return 1.5; }\n            when 'Negotiation/Review' { return 1.7; }\n            when 'Closed Won' { return 2.0; }\n            when else { return 1.0; }\n        }\n    }\n\n    private static Decimal getTimeFactor(Date closeDate) {\n        if (closeDate == null) {\n            return 1.0;\n        }\n\n        Integer daysUntilClose = System.today().daysBetween(closeDate);\n\n        if (daysUntilClose <= 7) {\n            return 1.5; // Urgent bonus\n        } else if (daysUntilClose <= 30) {\n            return 1.2; // Near-term bonus\n        } else {\n            return 1.0; // Standard\n        }\n    }\n}",annotations:[{arrows:"    ↑",explanation:"TDD: Write tests first to define expected behavior, then implement code to make tests pass",type:"info",icon:"\uD83D\uDD04"},{arrows:"         ↑",explanation:"Test edge cases and error conditions to ensure robust error handling and validation",type:"warning",icon:"⚠️"},{arrows:"              ↑",explanation:"Performance test with bulk data to verify your code scales and respects governor limits",type:"success",icon:"⚡"},{arrows:"                   ↑",explanation:"Integration tests verify components work together correctly with real data relationships",type:"info",icon:"\uD83D\uDD17"}]})]}),(0,s.jsxs)("section",{className:"bg-green-50 dark:bg-green-900/20 rounded-lg p-6",children:[(0,s.jsx)("h3",{className:"text-xl font-semibold text-green-900 dark:text-green-100 mb-3",children:"✅ Testing Best Practices"}),(0,s.jsxs)("ul",{className:"space-y-2 text-green-800 dark:text-green-200",children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Test Coverage:"})," Aim for 100% test coverage, not just the 75% minimum required for deployment"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Test Data:"})," Use @TestSetup and data factories for consistent, maintainable test data"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Assertions:"})," Include meaningful error messages in System.assertEquals() for easier debugging"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Async Testing:"})," Always use Test.startTest() and Test.stopTest() for async code (future, batch, queueable)"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"User Context:"})," Test with different user profiles using System.runAs() to validate security"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Mocking:"})," Use Test.setMock() for external integrations to ensure predictable, isolated tests"]})]})]})]})}],S=e=>{let{code:n}=e,[t,o]=(0,a.useState)(!1),r=async()=>{try{await navigator.clipboard.writeText(n),o(!0),setTimeout(()=>o(!1),2e3)}catch(e){console.error("Failed to copy code:",e)}};return(0,s.jsx)("button",{onClick:r,className:"absolute top-2 right-2 p-2 rounded-md bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white transition-colors",title:"Copy code",children:t?(0,s.jsx)(h.Z,{className:"h-4 w-4 text-green-400"}):(0,s.jsx)(y.Z,{className:"h-4 w-4"})})};function T(){let[e,n]=(0,a.useState)(A[0]),[t,i]=(0,a.useState)(!1);return(0,s.jsxs)("div",{className:"min-h-screen bg-gray-50 dark:bg-gray-900",children:[(0,s.jsx)("header",{className:"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-4",children:(0,s.jsx)("div",{className:"flex items-center justify-between",children:(0,s.jsxs)("div",{className:"flex items-center space-x-4",children:[(0,s.jsx)("button",{onClick:()=>i(!t),className:"lg:hidden p-2 rounded-md text-gray-500 hover:text-gray-700 hover:bg-gray-100 dark:hover:bg-gray-700",children:(0,s.jsx)("svg",{className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:(0,s.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M4 6h16M4 12h16M4 18h16"})})}),(0,s.jsx)("h1",{className:"text-2xl font-bold text-gray-900 dark:text-white",children:"Apex Academy"})]})})}),(0,s.jsxs)("div",{className:"flex",children:[(0,s.jsx)("aside",{className:"\n          fixed inset-y-0 left-0 z-50 w-80 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 transform transition-transform duration-300 ease-in-out pt-16 shadow-lg\n          lg:translate-x-0 lg:static lg:inset-0 lg:pt-0 lg:shadow-none\n          ".concat(t?"translate-x-0":"-translate-x-full","\n        "),children:(0,s.jsxs)("div",{className:"p-6 h-full overflow-y-auto",children:[(0,s.jsxs)("div",{className:"mb-6",children:[(0,s.jsx)("h2",{className:"text-xl font-bold text-gray-900 dark:text-white mb-2",children:"Apex Fundamentals"}),(0,s.jsx)("p",{className:"text-sm text-gray-600 dark:text-gray-400",children:"Master Salesforce development step by step"})]}),(0,s.jsx)("nav",{className:"space-y-1",children:A.map((t,a)=>{let o=t.icon,r=e.id===t.id,c=a<A.findIndex(n=>n.id===e.id);return(0,s.jsx)("button",{onClick:()=>{n(t),i(!1)},className:"\n                      w-full text-left p-4 rounded-lg transition-all duration-200 group border\n                      ".concat(r?"bg-blue-50 dark:bg-blue-900/30 border-blue-200 dark:border-blue-700 text-blue-900 dark:text-blue-100":"border-transparent hover:bg-gray-50 dark:hover:bg-gray-700/50 text-gray-700 dark:text-gray-300 hover:border-gray-200 dark:hover:border-gray-600","\n                    "),children:(0,s.jsxs)("div",{className:"flex items-start space-x-3",children:[(0,s.jsx)("div",{className:"\n                        flex-shrink-0 p-2 rounded-md mt-0.5\n                        ".concat(r?"bg-blue-100 dark:bg-blue-800 text-blue-600 dark:text-blue-300":"bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 group-hover:bg-gray-200 dark:group-hover:bg-gray-600","\n                      "),children:(0,s.jsx)(o,{className:"h-4 w-4"})}),(0,s.jsxs)("div",{className:"flex-1 min-w-0",children:[(0,s.jsxs)("div",{className:"flex items-center justify-between",children:[(0,s.jsx)("h3",{className:"\n                            text-sm font-medium truncate\n                            ".concat(r?"text-blue-900 dark:text-blue-100":"text-gray-900 dark:text-gray-100","\n                          "),children:t.title}),r&&(0,s.jsx)(b.Z,{className:"h-4 w-4 text-blue-600 dark:text-blue-400 flex-shrink-0"})]}),(0,s.jsx)("p",{className:"\n                          text-xs mt-1 truncate\n                          ".concat(r?"text-blue-700 dark:text-blue-300":"text-gray-500 dark:text-gray-400","\n                        "),children:t.description}),(0,s.jsxs)("div",{className:"mt-2 flex items-center space-x-1",children:[(0,s.jsx)("div",{className:"\n                            h-1 w-full rounded-full\n                            ".concat(c?"bg-green-400":r?"bg-blue-200 dark:bg-blue-700":"bg-gray-200 dark:bg-gray-600","\n                          ")}),c&&(0,s.jsx)("div",{className:"text-green-600 dark:text-green-400",children:(0,s.jsx)(h.Z,{className:"h-3 w-3"})})]})]})]})},t.id)})}),(0,s.jsxs)("div",{className:"mt-8 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900/20 dark:to-indigo-900/20 rounded-lg border border-blue-100 dark:border-blue-800",children:[(0,s.jsx)("h4",{className:"text-sm font-medium text-blue-900 dark:text-blue-100 mb-2",children:"\uD83D\uDCA1 Learning Tip"}),(0,s.jsx)("p",{className:"text-xs text-blue-700 dark:text-blue-300",children:"Work through topics in order. Each builds on previous concepts for optimal learning."})]})]})}),t&&(0,s.jsx)("div",{className:"fixed inset-0 bg-gray-600 bg-opacity-75 z-40 lg:hidden",onClick:()=>i(!1)}),(0,s.jsx)("main",{className:"flex-1 lg:ml-0 min-h-screen bg-gray-50 dark:bg-gray-900",children:(0,s.jsxs)("div",{className:"max-w-5xl mx-auto p-6 lg:p-8",children:[(0,s.jsx)("div",{className:"bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 p-8 mb-6",children:(0,s.jsxs)("div",{className:"flex items-start space-x-4",children:[(0,s.jsx)("div",{className:"flex-shrink-0 p-3 bg-blue-100 dark:bg-blue-900/30 rounded-lg",children:(0,s.jsx)(e.icon,{className:"h-6 w-6 text-blue-600 dark:text-blue-400"})}),(0,s.jsxs)("div",{className:"flex-1 min-w-0",children:[(0,s.jsx)("h1",{className:"text-3xl font-bold text-gray-900 dark:text-white mb-2",children:e.title}),(0,s.jsx)("p",{className:"text-lg text-gray-600 dark:text-gray-400 leading-relaxed",children:e.description})]})]})}),(0,s.jsxs)("div",{className:"bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden",children:[(0,s.jsx)("div",{className:"p-8",children:(0,s.jsx)("div",{className:"prose prose-lg dark:prose-dark max-w-none prose-headings:text-gray-900 dark:prose-headings:text-gray-100 prose-p:text-gray-700 dark:prose-p:text-gray-300 prose-strong:text-gray-900 dark:prose-strong:text-gray-100 prose-code:text-blue-600 dark:prose-code:text-blue-400 prose-code:bg-blue-50 dark:prose-code:bg-blue-900/30 prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-blockquote:border-l-blue-500 prose-blockquote:bg-blue-50 dark:prose-blockquote:bg-blue-900/20 prose-blockquote:text-blue-900 dark:prose-blockquote:text-blue-100",children:"string"==typeof e.content?(e=>{let n=e.split("\n"),t=[],a="",i=!1,c="";return n.forEach((e,n)=>{if(e.startsWith("```")){i?(t.push((0,s.jsx)("div",{className:"my-6 relative group",children:(0,s.jsxs)("div",{className:"relative",children:[(0,s.jsx)(o.Z,{language:c||"apex",style:r.Z,className:"rounded-lg",showLineNumbers:!0,customStyle:{background:"#0f0f0f",padding:"1.5rem",fontSize:"14px",lineHeight:"1.6",fontFamily:'"Fira Code", "JetBrains Mono", Consolas, monospace',border:"1px solid #2d2d2d",boxShadow:"0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)"},children:a.trim()}),(0,s.jsx)(S,{code:a.trim()})]})},n)),a="",i=!1,c=""):(i=!0,c=e.replace("```","").trim());return}if(i){a+=e+"\n";return}if(e.startsWith("# "))t.push((0,s.jsx)("h1",{className:"text-3xl font-bold text-gray-900 dark:text-white mb-6 mt-8 first:mt-0",children:e.replace("# ","")},n));else if(e.startsWith("## "))t.push((0,s.jsx)("h2",{className:"text-2xl font-semibold text-gray-800 dark:text-gray-200 mb-4 mt-8",children:e.replace("## ","")},n));else if(e.startsWith("### "))t.push((0,s.jsx)("h3",{className:"text-xl font-semibold text-gray-700 dark:text-gray-300 mb-3 mt-6",children:e.replace("### ","")},n));else if(e.startsWith("**")&&e.endsWith("**"))t.push((0,s.jsx)("p",{className:"font-semibold text-gray-900 dark:text-white mb-2",children:e.replace(/\*\*/g,"")},n));else if(e.startsWith("- "))t.push((0,s.jsx)("li",{className:"ml-6 mb-1 text-gray-700 dark:text-gray-300",children:e.replace("- ","")},n));else if(e.trim()&&!e.startsWith("`")){let a=e.replace(/`([^`]+)`/g,'<code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded text-sm font-mono">$1</code>');t.push((0,s.jsx)("p",{className:"mb-4 text-gray-700 dark:text-gray-300 leading-relaxed",dangerouslySetInnerHTML:{__html:a}},n))}}),t})(e.content):e.content})}),(0,s.jsx)("div",{className:"border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-700/50 px-8 py-4",children:(0,s.jsxs)("div",{className:"flex items-center justify-between",children:[(0,s.jsxs)("div",{className:"text-sm text-gray-500 dark:text-gray-400",children:["Topic ",A.findIndex(n=>n.id===e.id)+1," of ",A.length]}),(0,s.jsxs)("div",{className:"flex space-x-3",children:[A.findIndex(n=>n.id===e.id)>0&&(0,s.jsxs)("button",{onClick:()=>n(A[A.findIndex(n=>n.id===e.id)-1]),className:"flex items-center space-x-2 px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors",children:[(0,s.jsx)(b.Z,{className:"h-4 w-4 rotate-180"}),(0,s.jsx)("span",{children:"Previous"})]}),A.findIndex(n=>n.id===e.id)<A.length-1&&(0,s.jsxs)("button",{onClick:()=>n(A[A.findIndex(n=>n.id===e.id)+1]),className:"flex items-center space-x-2 px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-blue-600 rounded-lg hover:bg-blue-700 transition-colors",children:[(0,s.jsx)("span",{children:"Next Topic"}),(0,s.jsx)(b.Z,{className:"h-4 w-4"})]})]})]})})]})]})})]})]})}}},function(e){e.O(0,[965,971,117,744],function(){return e(e.s=96977)}),_N_E=e.O()}]);