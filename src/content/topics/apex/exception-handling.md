---
title: "Exception Handling"
section: "apex"
order: 4
difficulty: "intermediate"
readTime: "25 min"
description: "Master exception handling in Apex with comprehensive examples covering try-catch, custom exceptions, and error handling best practices."
overview: "Learn how to handle errors gracefully using try-catch blocks, custom exceptions, and best practices for robust Apex applications."
concepts: ["exceptions", "try-catch", "custom-exceptions", "error-handling", "debugging", "fault-tolerance"]
prerequisites: ["variables-and-data-types", "control-flow-and-logic"]
relatedTopics: ["soql-fundamentals", "trigger-bulkification-best-practices"]
lastUpdated: "2025-01-15"
examWeight: "medium"
---

# Core Concepts

Exception handling is essential for building robust, production-ready Apex applications. Understanding how to handle errors gracefully prevents application failures and improves user experience.

## Understanding Exceptions

An exception is an event that disrupts the normal flow of program execution. In Apex, exceptions can be:
- **System-Thrown**: Generated by Salesforce (NullPointerException, DmlException, etc.)
- **Developer-Thrown**: Explicitly thrown using `throw` keyword
- **Caught**: Handled using try-catch blocks
- **Propagated**: Bubbles up the call stack if not caught

**Key Principles:**
- **Fail Gracefully**: Never let exceptions crash your application
- **Log Details**: Capture exception information for debugging
- **User-Friendly**: Provide clear error messages to users
- **Specific Handling**: Catch specific exceptions when possible

## Exception Categories

### Standard Exceptions
Built-in Salesforce exception types:
- **DmlException**: Database operation failures
- **QueryException**: SOQL query issues
- **NullPointerException**: Null reference access
- **ListException**: List index out of bounds
- **TypeException**: Type conversion failures

### Custom Exceptions
- **User-Defined**: Create your own exception classes
- **Business Logic**: Model domain-specific errors
- **Clarity**: Provide meaningful error context

---

# Code Examples

Let's explore exception handling with detailed, annotated examples.

## Try-Catch Basics

The foundation of error handling in Apex.

```apex
public class ExceptionHandlingBasics {

    public static void demonstrateTryCatch() {
        // Basic try-catch structure
        try {
            // ^^^^
            // TRY BLOCK: Code that might throw exception
            // ‚Üí Enclose potentially failing code
            // üí° SCOPE: Declare variables outside if needed later

            Integer result = 10 / 0; // Division by zero
            System.debug('Result: ' + result);

        } catch (Exception e) {
            // ^^^^^^^^^^^^^^^^^^^^^
            // CATCH BLOCK: Handles exception if thrown
            // ‚Üí Exception e contains error details
            // ‚úÖ BEST PRACTICE: Always handle exceptions

            System.debug('Error occurred: ' + e.getMessage());
            // ^^^^^^^^^^^^^^
            // EXCEPTION MESSAGE: Human-readable error description
            // ‚Üí Use for logging and debugging
        }
        // Program continues after catch block
    }

    public static void demonstrateMultipleCatch() {
        try {
            // Potentially problematic code
            List<Account> accounts = [SELECT Id, Name FROM Account WHERE Id = 'invalid'];
            Account acc = accounts[0];
            acc.Name = null;
            update acc;

        } catch (QueryException qe) {
            // ^^^^^^^^^^^^^^^^^^^^^^^^^^
            // SPECIFIC EXCEPTION: Handle query-specific errors
            // ‚Üí More specific catches go first
            // üí° TARGETED: Different handling per exception type

            System.debug('Query error: ' + qe.getMessage());
            // Handle query-specific error logic

        } catch (ListException le) {
            // ^^^^^^^^^^^^^^^^^^^^^^^^^^
            // LIST EXCEPTION: Array index out of bounds
            // ‚Üí Occurs when accessing invalid list index

            System.debug('List access error: ' + le.getMessage());

        } catch (DmlException de) {
            // ^^^^^^^^^^^^^^^^^^^^^^^^^
            // DML EXCEPTION: Database operation failed
            // ‚Üí Provides detailed DML failure information

            System.debug('DML error: ' + de.getMessage());
            System.debug('Failed record: ' + de.getDmlId(0));

        } catch (Exception e) {
            // ^^^^^^^^^^^^^^^^^^^^^
            // GENERAL EXCEPTION: Catch-all for other exceptions
            // ‚Üí Always put this last
            // üíÄ EXAM TRAP: Order matters - specific before general

            System.debug('Unexpected error: ' + e.getMessage());
        }
    }

    public static void demonstrateFinally() {
        Database.SaveResult result;

        try {
            Account acc = new Account(Name = 'Test Account');
            insert acc;
            System.debug('Account created successfully');

        } catch (DmlException e) {
            System.debug('Failed to create account: ' + e.getMessage());

        } finally {
            // ^^^^^^^^
            // FINALLY BLOCK: Always executes
            // ‚Üí Runs whether exception occurred or not
            // üí° USE CASE: Cleanup operations, logging

            System.debug('Operation completed');
            // Cleanup code here (close connections, release resources, etc.)
        }
        // ‚ö†Ô∏è NOTE: Apex doesn't have file handles, but finally useful for logging
    }

    public static Account getAccountSafely(Id accountId) {
        // Practical example: Safe record retrieval
        try {
            List<Account> accounts = [
                SELECT Id, Name, Industry, AnnualRevenue
                FROM Account
                WHERE Id = :accountId
                LIMIT 1
            ];

            if (accounts.isEmpty()) {
                // No exception thrown, but no record found
                System.debug('Account not found: ' + accountId);
                return null;
            }

            return accounts[0];

        } catch (QueryException e) {
            // Query failed (invalid Id format, etc.)
            System.debug('Query failed: ' + e.getMessage());
            return null;

        } catch (Exception e) {
            // Unexpected error
            System.debug('Unexpected error: ' + e.getMessage());
            return null;
        }
    }

    public static void demonstrateExceptionInfo() {
        try {
            throw new IllegalArgumentException('Invalid parameter value');

        } catch (Exception e) {
            // Exception information methods
            System.debug('Message: ' + e.getMessage());
            // ^^^^^^^^^^^^^^^^^^^
            // GET MESSAGE: Error description
            // ‚Üí Most commonly used for logging

            System.debug('Type: ' + e.getTypeName());
            // ^^^^^^^^^^^^^^^
            // GET TYPE NAME: Exception class name
            // ‚Üí Useful for categorizing errors

            System.debug('Stack trace: ' + e.getStackTraceString());
            // ^^^^^^^^^^^^^^^^^^^^^^^^^
            // STACK TRACE: Full call stack
            // ‚Üí Critical for debugging complex issues
            // üí° DEBUGGING: Shows exactly where error occurred

            System.debug('Line number: ' + e.getLineNumber());
            // ^^^^^^^^^^^^^^^^^^^^
            // LINE NUMBER: Where exception was thrown
            // ‚Üí Pinpoint error location in code
        }
    }
}
```

## DML Exception Handling

Special handling for database operations.

```apex
public class DMLExceptionHandling {

    public static void demonstrateDmlException() {
        try {
            // Create account without required Name field
            Account acc = new Account();
            insert acc; // Will fail - Name is required

        } catch (DmlException e) {
            // DML-specific information
            System.debug('DML Error: ' + e.getMessage());

            System.debug('Number of failures: ' + e.getNumDml());
            // ^^^^^^^^^^^^^^
            // NUM DML: Count of failed records
            // ‚Üí Useful for bulk operations

            // Get details about first failed record
            if (e.getNumDml() > 0) {
                System.debug('Failed record index: ' + e.getDmlIndex(0));
                // ^^^^^^^^^^^^^^^^^^
                // DML INDEX: Position in list that failed
                // ‚Üí Identify specific failed record

                System.debug('Failed record ID: ' + e.getDmlId(0));
                // ^^^^^^^^^^^^
                // DML ID: Record Id that failed (if available)

                System.debug('Failure message: ' + e.getDmlMessage(0));
                // ^^^^^^^^^^^^^^^
                // DML MESSAGE: Specific error for this record

                System.debug('Status code: ' + e.getDmlType(0));
                // ^^^^^^^^^^^^
                // DML TYPE: Type of DML operation that failed
            }

            // Get all field names that caused failure
            System.debug('Failed fields: ' + e.getDmlFieldNames(0));
            // ^^^^^^^^^^^^^^^^^^^^
            // DML FIELD NAMES: Which fields caused the error
            // ‚Üí List of problematic field names
        }
    }

    public static List<Database.SaveResult> bulkInsertWithErrorHandling(List<Account> accounts) {
        // Partial success with Database methods
        List<Database.SaveResult> results = Database.insert(accounts, false);
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // DATABASE.INSERT: Allow partial success
        // ‚Üí false parameter allows some records to fail
        // üí° BULK OPERATIONS: More resilient than all-or-nothing

        // Process results
        List<Account> successfulAccounts = new List<Account>();
        List<String> errors = new List<String>();

        for (Integer i = 0; i < results.size(); i++) {
            Database.SaveResult result = results[i];

            if (result.isSuccess()) {
                // ^^^^^^^^^^^^^^^^^^^^^
                // IS SUCCESS: Check if record saved
                // ‚Üí Individual record success status

                System.debug('Success: Account ' + i + ' created with Id ' + result.getId());
                successfulAccounts.add(accounts[i]);

            } else {
                // Process errors
                for (Database.Error error : result.getErrors()) {
                    // ^^^^^^^^^^^^^^^^^^^^^^
                    // GET ERRORS: List of errors for this record
                    // ‚Üí Multiple errors possible per record

                    String errorMsg = 'Error on account ' + i + ': ' +
                                    error.getMessage() + ' (Fields: ' +
                                    error.getFields() + ')';
                    errors.add(errorMsg);

                    System.debug(errorMsg);
                    System.debug('Status code: ' + error.getStatusCode());
                    // ^^^^^^^^^^^^^^^^^
                    // STATUS CODE: Specific error type
                    // ‚Üí REQUIRED_FIELD_MISSING, DUPLICATE_VALUE, etc.
                }
            }
        }

        System.debug('Successful: ' + successfulAccounts.size() +
                    ', Failed: ' + errors.size());

        return results;
    }

    public static void demonstrateDatabaseUpdate() {
        // Prepare test data
        List<Account> accounts = new List<Account>{
            new Account(Name = 'Valid Account', Industry = 'Technology'),
            new Account(Industry = 'Healthcare'), // Missing Name - will fail
            new Account(Name = 'Another Valid Account', Industry = 'Finance')
        };

        // Use Database.update with allOrNone = false
        List<Database.SaveResult> results = Database.insert(accounts, false);

        // Handle mixed success/failure
        for (Integer i = 0; i < results.size(); i++) {
            if (!results[i].isSuccess()) {
                // Add error to the record so user can see it
                for (Database.Error error : results[i].getErrors()) {
                    accounts[i].addError(error.getMessage());
                    // ^^^^^^^^^^^^^^^^^^^
                    // ADD ERROR: Attach error to record
                    // ‚Üí Visible to user in UI
                    // ‚úÖ USER EXPERIENCE: Clear feedback on failures
                }
            }
        }
    }

    public static void demonstrateUpsertException() {
        try {
            List<Account> accounts = new List<Account>();

            // Mix of new and existing records
            Account existingAcc = [SELECT Id, Name FROM Account LIMIT 1];
            existingAcc.Name = 'Updated Name';
            accounts.add(existingAcc);

            Account newAcc = new Account(Name = 'New Account');
            accounts.add(newAcc);

            upsert accounts;
            // ^^^^^^^^^^^^^^^^
            // UPSERT: Insert new, update existing
            // ‚Üí Can throw DmlException for either operation

        } catch (DmlException e) {
            System.debug('Upsert failed: ' + e.getMessage());

            // Check which operation failed
            for (Integer i = 0; i < e.getNumDml(); i++) {
                StatusCode status = e.getDmlType(i);
                if (status == StatusCode.REQUIRED_FIELD_MISSING) {
                    System.debug('Missing required field on record ' + e.getDmlIndex(i));
                } else if (status == StatusCode.DUPLICATE_VALUE) {
                    System.debug('Duplicate value on record ' + e.getDmlIndex(i));
                }
            }
        }
    }
}
```

## Custom Exceptions

Create meaningful, domain-specific exceptions.

```apex
// Define custom exception class
public class AccountValidationException extends Exception {}
public class InsufficientFundsException extends Exception {}
public class InvalidDataException extends Exception {}
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// CUSTOM EXCEPTION: Extend Exception class
// ‚Üí Naming convention: End with "Exception"
// üí° CLARITY: Domain-specific error types

public class CustomExceptionExamples {

    public static void demonstrateCustomException() {
        try {
            validateAccount(new Account());

        } catch (AccountValidationException e) {
            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // CATCH CUSTOM: Handle specific business exception
            // ‚Üí More meaningful than generic Exception
            // ‚úÖ BEST PRACTICE: Model business errors

            System.debug('Validation failed: ' + e.getMessage());
            // Implement business-specific error handling
        }
    }

    public static void validateAccount(Account acc) {
        // Business validation with custom exceptions
        if (acc == null) {
            throw new AccountValidationException('Account cannot be null');
            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // THROW CUSTOM: Raise custom exception
            // ‚Üí Stops execution at this point
            // üí° USAGE: Signal specific business rule violations
        }

        if (String.isBlank(acc.Name)) {
            throw new AccountValidationException('Account Name is required');
        }

        if (acc.AnnualRevenue != null && acc.AnnualRevenue < 0) {
            throw new AccountValidationException('Annual Revenue cannot be negative');
        }

        // All validations passed
        System.debug('Account is valid');
    }

    public static void processPayment(Decimal amount, Decimal balance) {
        // Business logic with custom exceptions
        if (amount <= 0) {
            throw new InvalidDataException('Payment amount must be positive');
        }

        if (amount > balance) {
            throw new InsufficientFundsException(
                'Insufficient funds. Balance: ' + balance + ', Required: ' + amount
            );
            // ^^^^^^^^^^^^^^^^^^^^^^^^^
            // DETAILED MESSAGE: Include context in exception
            // ‚Üí Helps with debugging and user feedback
        }

        // Process payment
        System.debug('Payment processed successfully');
    }

    public static void demonstrateExceptionChaining() {
        try {
            performComplexOperation();

        } catch (CustomException e) {
            // Re-throw with additional context
            throw new AccountValidationException(
                'Complex operation failed: ' + e.getMessage()
            );
            // ^^^^^^^^^^^^^^^^^^^^^^^
            // EXCEPTION WRAPPING: Add context when re-throwing
            // ‚Üí Preserves original error information
            // üí° DEBUGGING: Maintains full error trail
        }
    }

    private static void performComplexOperation() {
        // Simulate complex operation
        throw new CustomException('Internal operation failed');
    }

    // Helper custom exception
    public class CustomException extends Exception {}
}
```

## Error Handling Patterns

Production-ready error handling strategies.

```apex
public class ErrorHandlingPatterns {

    public static void demonstrateEarlyValidation() {
        // ‚úÖ Validate early pattern
        Account acc = getAccountFromUser();

        // Validate before processing
        if (acc == null) {
            System.debug('Error: Account is null');
            return;
        }

        if (String.isBlank(acc.Name)) {
            System.debug('Error: Account name is required');
            return;
        }

        // Proceed with valid data
        processAccount(acc);
    }

    public static void demonstrateDefensiveProgramming() {
        // Defensive programming with null checks
        List<Contact> contacts = getContacts();

        // Defensive null check
        if (contacts == null || contacts.isEmpty()) {
            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // DEFENSIVE CHECK: Handle unexpected null/empty
            // ‚Üí Prevents NullPointerException
            // ‚úÖ PRODUCTION: Always validate inputs

            System.debug('No contacts to process');
            return;
        }

        // Safe to process
        for (Contact con : contacts) {
            if (con != null && String.isNotBlank(con.Email)) {
                sendEmail(con.Email);
            }
        }
    }

    public static void demonstrateGracefulDegradation() {
        // Try primary approach, fall back if fails
        try {
            processWithPrimaryMethod();

        } catch (Exception e) {
            System.debug('Primary method failed: ' + e.getMessage());

            try {
                // Fall back to alternative method
                processWithFallbackMethod();
                // ^^^^^^^^^^^^^^^^^^^^^^^^^^
                // FALLBACK: Alternative approach if primary fails
                // ‚Üí Graceful degradation pattern
                // üí° RESILIENCE: Application continues functioning

            } catch (Exception fallbackException) {
                // Log both failures
                System.debug('Fallback also failed: ' + fallbackException.getMessage());
                // Last resort error handling
                notifyAdministrator(e, fallbackException);
            }
        }
    }

    public static List<Account> demonstrateBulkErrorHandling(List<Account> accounts) {
        List<Account> successfulAccounts = new List<Account>();
        List<String> errorMessages = new List<String>();

        for (Account acc : accounts) {
            try {
                // Validate each record
                validateAccount(acc);

                // Process if valid
                processAccount(acc);
                successfulAccounts.add(acc);

            } catch (Exception e) {
                // Continue processing other records
                String errorMsg = 'Failed to process account ' + acc.Name +
                                ': ' + e.getMessage();
                errorMessages.add(errorMsg);
                System.debug(errorMsg);
                // ^^^^^^^^^^^^^^^^^^^^
                // CONTINUE ON ERROR: Process other records
                // ‚Üí Bulk operation doesn't fail entirely
                // ‚úÖ BEST PRACTICE: Collect errors, continue processing
            }
        }

        // Log summary
        System.debug('Processed: ' + successfulAccounts.size() +
                    ', Failed: ' + errorMessages.size());

        return successfulAccounts;
    }

    public static void demonstrateLoggingPattern() {
        try {
            performRiskyOperation();

        } catch (Exception e) {
            // Comprehensive logging
            System.debug('=== ERROR OCCURRED ===');
            System.debug('Message: ' + e.getMessage());
            System.debug('Type: ' + e.getTypeName());
            System.debug('Line: ' + e.getLineNumber());
            System.debug('Stack Trace:');
            System.debug(e.getStackTraceString());
            System.debug('====================');
            // ^^^^^^^^^^^^^^^^^^^^^^^
            // DETAILED LOGGING: Capture all error context
            // ‚Üí Essential for production debugging
            // üí° OPERATIONS: Helps support team diagnose issues

            // Create error record for tracking
            createErrorLog(e);
        }
    }

    public static void demonstrateTransactionRollback() {
        Savepoint sp = Database.setSavepoint();
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // SAVEPOINT: Mark transaction state
        // ‚Üí Can rollback to this point if needed
        // üí° DATA INTEGRITY: Atomic operations

        try {
            // Perform multiple DML operations
            Account acc = new Account(Name = 'Test Account');
            insert acc;

            Contact con = new Contact(
                FirstName = 'John',
                LastName = 'Doe',
                AccountId = acc.Id
            );
            insert con;

            // Simulate error
            if (Math.random() > 0.5) {
                throw new CustomException('Random failure for demo');
            }

        } catch (Exception e) {
            // Rollback all changes
            Database.rollback(sp);
            // ^^^^^^^^^^^^^^^^^^^^
            // ROLLBACK: Undo changes to savepoint
            // ‚Üí All DML operations reversed
            // ‚úÖ DATA INTEGRITY: All-or-nothing transaction

            System.debug('Transaction rolled back: ' + e.getMessage());
        }
    }

    // Helper methods
    private static Account getAccountFromUser() {
        return new Account(Name = 'Sample Account');
    }

    private static List<Contact> getContacts() {
        return new List<Contact>();
    }

    private static void processAccount(Account acc) {
        System.debug('Processing account: ' + acc.Name);
    }

    private static void validateAccount(Account acc) {
        if (acc == null || String.isBlank(acc.Name)) {
            throw new AccountValidationException('Invalid account');
        }
    }

    private static void sendEmail(String email) {
        System.debug('Sending email to: ' + email);
    }

    private static void processWithPrimaryMethod() {
        throw new CustomException('Primary failed');
    }

    private static void processWithFallbackMethod() {
        System.debug('Using fallback method');
    }

    private static void notifyAdministrator(Exception e1, Exception e2) {
        System.debug('Notifying admin of failures');
    }

    private static void performRiskyOperation() {
        throw new CustomException('Risky operation failed');
    }

    private static void createErrorLog(Exception e) {
        System.debug('Creating error log entry');
    }

    public class AccountValidationException extends Exception {}
    public class CustomException extends Exception {}
}
```

---

# Common Gotchas

## üíÄ Catching Too Broad

```apex
// ‚ùå BAD - Catches everything, hides specific issues
try {
    // Complex logic
} catch (Exception e) {
    System.debug('Error: ' + e.getMessage());
}

// ‚úÖ GOOD - Handle specific exceptions
try {
    // Complex logic
} catch (DmlException e) {
    // Handle DML-specific error
} catch (QueryException e) {
    // Handle query-specific error
} catch (Exception e) {
    // Handle unexpected errors
}
```

## ‚ö†Ô∏è Swallowing Exceptions

```apex
// ‚ùå BAD - Empty catch block
try {
    update accounts;
} catch (DmlException e) {
    // Silent failure - very bad!
}

// ‚úÖ GOOD - Always log or handle
try {
    update accounts;
} catch (DmlException e) {
    System.debug('Update failed: ' + e.getMessage());
    // Take corrective action
}
```

## üí° Re-throwing Exceptions

```apex
// When to re-throw
try {
    criticalOperation();
} catch (Exception e) {
    logError(e);
    throw e; // Re-throw to let caller handle
}
```

---

# Exam Tips

## High-Priority Concepts

1. **Try-Catch-Finally**: Structure and execution order
2. **DmlException**: Special methods for DML error details
3. **Custom Exceptions**: Create by extending Exception
4. **Database Methods**: Partial success with allOrNone parameter
5. **Exception Order**: Specific exceptions before general

## Common Exam Scenarios

- Identifying proper exception handling order
- Understanding DmlException methods
- Database.insert vs insert for partial success
- Custom exception creation
- Finally block execution

## Key Points to Remember

- Finally always executes, even with exceptions
- More specific catch blocks must come first
- DmlException provides detailed DML failure information
- Database methods allow partial success
- Custom exceptions extend Exception class

---

# Related Topics

## Prerequisites
- **[Variables and Data Types](variables-and-data-types)** - Understanding types for exception handling
- **[Control Flow and Logic](control-flow-and-logic)** - Flow control with exceptions

## Next Steps
- **[SOQL Fundamentals](soql-fundamentals)** - Handling query exceptions
- **[Trigger Bulkification](trigger-bulkification-best-practices)** - Error handling in triggers

**Next Recommended Topic:** [Object-Oriented Programming](object-oriented-programming) - Build more complex applications with classes and objects.
